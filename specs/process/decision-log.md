# Decision Log

This log records decisions that intentionally constrain future changes.

---

## 2026-02-19 — Decision 0001: Premath Kernel bundle commitment ("v0.1")

### Decision
We commit to a **profile-preserving** specification structure:

1. **Kernel stays minimal and ontology-agnostic.**
   - The normative kernel is `draft/PREMATH-KERNEL`.
   - Definability is **behavior**: coherent reindexing + locality + **contractible descent** on the Grothendieck topology generated by the declared coverage.
   - The kernel does **not** hardcode a semantic universe (Set/Gpd/∞-groupoids). It is parameterized by an ambient sameness level `V` with a chosen notion of equivalence `≈`.

2. **Backend-generic binding is a first-class seam.**
   - Reference binding is delegated to profiles via `project_ref` / `verify_ref` (see `draft/REF-BINDING`).
   - Kernel and opcode contracts MUST be phrased in terms of canonical bytes + `project_ref`, never a specific hash function.

3. **Operational totality is expressed via normalization + obligation discharge.**
   - `raw/NORMALIZER` and `draft/BIDIR-DESCENT` are part of the baseline "full" story.
   - In `normalized` mode, equality is **only** reference equality on normalized comparison refs (`cmpRef`).

4. **Gemini-style ∞-topos framing is adopted only as a semantics profile / optional dial.**
   - `raw/SEMANTICS-INFTOPOS` is informational (model-theoretic).
   - `raw/HYPERDESCENT`, `raw/UNIVERSE`, and `raw/SPLIT-PRESENTATION` are optional capabilities/extensions.

### Rationale
This locks in the original intent: **Premath is a definability gate (a linter), not a foundation**.

We still gain reviewer-facing strength by providing a canonical ∞-topos semantics profile and optional "final dial" extensions, without forcing those commitments on all constructors/backends.

### Consequences
- Future work that strengthens coherence (hypercovers), adds universes/comprehension, or requires strict presentations MUST be introduced as explicit capabilities/extensions.
- The next engineering step is no longer "define definability"; it is to build **running code + vectors** for the baseline bundle.

### Next milestone (binding)
Milestone M1: a conformance suite + at least one reference verifier implementation that:

- computes `project_ref` for at least one backend profile,
- normalizes NF deterministically and compares by `cmpRef`,
- emits and discharges Gate obligations deterministically.

---

## 2026-02-19 — Decision 0002: Proof-carrying overlap + cocycle witnesses

### Decision
We standardize an **optional Gate-witness seam** for descent checks:

- `O_ASSERT_OVERLAP` (OBJ opcode `0x05`): certifies pairwise overlap compatibility.
- `O_ASSERT_TRIPLE`  (OBJ opcode `0x06`): certifies triple-overlap coherence ("cocycle" check).

Both opcodes return `Unit` and are parameterized by the active constructor's restriction + equality.

### Rationale
This makes descent **trace-internal**: the Gate does not need to recompute overlap constraints from scratch,
and implementations can move overlap checks into a verified certificate layer.

### Consequences
- These opcodes are OPTIONAL in the raw kernel: they are a certified seam, not a mandatory feature.
- They enable incremental hardening: later work can add proof-carrying *uniqueness/contractibility* witnesses
  beyond brute-force enumeration.

---

## 2026-02-20 — Decision 0003: Contractible gluing as a proof-scheme hook

### Decision
We standardize an **optional Gate-witness seam** for stack-safe uniqueness / contractible gluing that is
explicitly **proof-scheme driven**:

- `O_ASSERT_CONTRACTIBLE` (OBJ opcode `0x07`) takes:
  - `schemeId: Bytes32` (opaque label), and
  - `proofBytes: bytes` (opaque payload)

and certifies that the glue space for a descent datum is **contractible** at the constructor’s sameness level.

Unsupported `schemeId` values MUST be rejected deterministically.

### Rationale
The kernel requires *contractibility* (stack-safe uniqueness), but does not prescribe how to prove it.
In engineering settings, brute-force enumeration is sometimes acceptable (toy models), but production
settings may require compressed proofs (e.g. RLNC decoding, lattice/norm arguments, solver certificates).

Making contractibility verification scheme-driven preserves:

- **backend agnosticism** (no hardcoded cryptography), and
- **proof agnosticism** (no forced proof system),

while still allowing KCIR traces to carry their own uniqueness certificates.

### Consequences
- The toy suite may implement a default scheme (e.g. `toy.enumerate.v1`) purely for determinism.
- Production backends can adopt additional `schemeId` values without changing kernel law text.

---

## 2026-02-20 — Decision 0004: First promotion batch from raw to draft

### Decision
Promote the governance/conformance spine to `draft` status:

- `draft/SPEC-INDEX`
- `draft/CONFORMANCE`
- `draft/CAPABILITY-VECTORS`
- `draft/CHANGE-MORPHISMS`

These remain under `specs/premath/raw/` path for link stability; authoritative
status is the front-matter `status` field.

### Rationale
These documents now define the invariant closure contract used by implementation
and CI:

- profile-invariant kernel/Gate outcomes,
- explicit optional capability claims,
- canonical change-morphism discipline.

Promoting this layer first reduces process ambiguity while keeping technical
surface area controlled.

### Consequences
- Future changes in this layer are expected to behave as draft contracts between
  editor and implementers.
- Conformance and fixture scaffolding for these capabilities are now part of the
  expected running-code discipline.

---

## 2026-02-20 — Decision 0005: Semantic-core promotion from raw to draft

### Decision
Promote the semantic-core contract files to `draft` status:

- `draft/PREMATH-KERNEL`
- `draft/GATE`
- `draft/BIDIR-DESCENT`
- `draft/WITNESS-ID`

Files remain in `specs/premath/raw/` for stable path references; normative
status is the front-matter field.

### Rationale
These files are the load-bearing semantic contract for runtime invariance:

- kernel laws,
- admissibility gate classes,
- operational discharge model,
- deterministic witness identity.

Promoting this batch aligns process state with current implementation and vector
usage, and reduces ambiguity about contract maturity.

### Consequences
- Changes to these specs should now be treated as draft-contract changes and be
  paired with vector/runtime evidence.
- Remaining raw specs can be promoted in later focused batches.

---

## 2026-02-20 — Decision 0006: Interop-core promotion and KCIR core rename

### Decision
Promote the Interop Core contract files to `draft` status:

- `draft/KCIR-CORE` (renamed from legacy id `KCIR-V2-CORE`)
- `draft/NF`
- `draft/REF-BINDING`
- `draft/WIRE-FORMATS`
- `draft/ERROR-CODES`

Rename spec identity from `KCIR-V2-CORE` to `KCIR-CORE` across references.

### Rationale
This batch stabilizes the interop artifact boundary and removes version-biased
naming in the core model reference for greenfield evolution.

### Consequences
- Dependencies and cross-spec references now target `draft/KCIR-CORE`.
- Conformance/interop reading orders now resolve through the renamed core spec.
- Remaining `v2` labels outside this core reference are informational/versioned
  naming and can be migrated separately if desired.

---

## 2026-02-20 — Decision 0007: Draft specs moved to `specs/premath/draft/`

### Decision
Move all promoted draft specs out of `specs/premath/raw/` into
`specs/premath/draft/`.

### Rationale
Directory semantics should match lifecycle semantics:

- `raw/` for experimentation and informational material,
- `draft/` for active contract specs.

This removes ambiguity about normative authority and improves navigation.

### Consequences
- Internal references for promoted specs now use `draft/<SPEC>`.
- `raw/README.md` is narrowed to raw-only scope.
- `draft/README.md` becomes the contract entry point for promoted specs.

---

## 2026-02-20 — Decision 0008: Process docs moved to `specs/process/`

### Decision
Move process governance docs out of `specs/premath/process/` into:

- `specs/process/coss.md`
- `specs/process/decision-log.md`

### Rationale
Process policy applies across the Premath spec lifecycle and should not appear
as a subtype of one lifecycle bucket (`premath/`).

Placing process at `specs/process/` clarifies authority and reduces path
ambiguity in promoted draft/raw specs.

### Consequences
- Draft/raw spec front matter now points to `../../process/coss.md`.
- Repository-level references now use `specs/process/decision-log.md`.

---

## 2026-02-20 — Decision 0009: Add raw operational stack specs (`TUSK`, `SQUEAK`, `CI`)

### Decision
Publish the current operational architecture as raw specs:

- `raw/TUSK-CORE`
- `raw/SQUEAK-CORE`
- `raw/CI-TOPOS`

and index them from:

- `raw/V2-SPECS`
- `draft/SPEC-INDEX` (informative-only references)

### Rationale
We need a documented operational boundary while preserving kernel stability:

- `tusk-core` captures single-world execution contracts,
- `squeak-core` captures inter-world transport contracts,
- `ci-topos` captures closure-style conformance gating.

Keeping this layer raw allows iteration without prematurely hardening runtime
interfaces as conformance requirements.

### Consequences
- The kernel/draft conformance surface remains unchanged.
- KCIR remains optional capability/evidence machinery, not a kernel dependency.
- Promotion of operational specs to draft requires dedicated vectors and
  conformance claims.

---

## 2026-02-21 — Decision 0010: Doctrine-to-operation site map and checker

### Decision
Add a draft, machine-checkable doctrine-to-operation site contract:

- `specs/premath/draft/DOCTRINE-SITE.md`
- `specs/premath/draft/DOCTRINE-SITE.json`

and enforce it with:

- `tools/conformance/check_doctrine_site.py`
- `just doctrine-check`
- `mise run doctrine-check`

Baseline gates now include doctrine-site validation.

### Rationale
We need an explicit path from meta-doctrine (`DOCTRINE-INF`) to operational
entrypoints (`tools/ci/*`, `tools/conformance/*`) so architecture drift is
auditable and detectable.

The site map makes this path concrete as nodes/covers/edges and binds edge
morphism IDs to declared preservation contracts.

### Consequences
- Declaration-bearing specs must stay coherent with the site map.
- Operational gate entrypoints must remain reachable from doctrine root.
- Refactors touching doctrine declarations, site map, or gate tooling are now
  expected to pass the doctrine-site checker in baseline CI.

---

## 2026-02-21 — Decision 0011: Add LLM instruction doctrine contract

### Decision
Add a draft doctrine contract for typed LLM instruction handling:

- `specs/premath/draft/LLM-INSTRUCTION-DOCTRINE.md`

and map it into the doctrine-to-operation site:

- `specs/premath/draft/DOCTRINE-SITE.json`

### Rationale
Instruction-envelope execution is already operational in this repository
(`tools/ci/run_instruction.sh` + CI witness output), but it needed explicit
doctrine constraints for:

- typed vs unknown instruction classification,
- authority split (LLM proposal vs kernel/runtime admissibility),
- deterministic instruction-to-witness binding.

### Consequences
- Higher-order CI/CD reading order now includes `draft/LLM-INSTRUCTION-DOCTRINE`.
- Doctrine-site coherence checks now include instruction doctrine nodes/edges.
- Instruction tooling remains execution surface only; semantic authority remains
  in kernel/runtime layers.

---

## 2026-02-21 — Decision 0012: Add executable instruction-typing capability vectors

### Decision
Promote instruction typing checks into executable capability conformance with:

- capability id: `capabilities.instruction_typing`
- vectors under:
  `tests/conformance/fixtures/capabilities/capabilities.instruction_typing/`
- runner support in:
  `tools/conformance/run_capability_vectors.py`

### Rationale
The instruction doctrine requires explicit `typed(kind)` / `unknown(reason)`
classification and deterministic handling. We need executable vectors to keep
this behavior regression-resistant and profile-invariant.

### Consequences
- `python3 tools/conformance/run_capability_vectors.py` now executes instruction
  typing vectors by default.
- Fixture/invariance stub checks now include this capability track.
- Claim surfaces (`SPEC-INDEX`, `CAPABILITY-VECTORS`, `CONFORMANCE`) now
  include `capabilities.instruction_typing`.

---

## 2026-02-21 — Decision 0013: Wire instruction doctrine into runtime witness flow

### Decision
Extend `tools/ci/run_instruction.py` to enforce doctrine-level instruction
classification at runtime:

- classify each envelope as `typed(kind)` or `unknown(reason)`,
- reject `unknown(reason)` when `typingPolicy.allowUnknown` is false,
- emit `instructionClassification` and `typingPolicy` in CI witness artifacts.

### Rationale
Doctrine and conformance capability checks were in place, but the operational
instruction runner did not yet surface classification in runtime artifacts.
This closes the spec-to-operation loop.

### Consequences
- instruction witness records now carry explicit typing metadata.
- unroutable unknown instructions fail deterministically before gate execution.
- instruction envelope examples/documentation now include optional typing fields.
