# Decision Log

This log records decisions that intentionally constrain future changes.

---

## 2026-02-19 — Decision 0001: Premath Kernel bundle commitment ("v0.1")

### Decision
We commit to a **profile-preserving** specification structure:

1. **Kernel stays minimal and ontology-agnostic.**
   - The normative kernel is `draft/PREMATH-KERNEL`.
   - Definability is **behavior**: coherent reindexing + locality + **contractible descent** on the Grothendieck topology generated by the declared coverage.
   - The kernel does **not** hardcode a semantic universe (Set/Gpd/∞-groupoids). It is parameterized by an ambient sameness level `V` with a chosen notion of equivalence `≈`.

2. **Backend-generic binding is a first-class seam.**
   - Reference binding is delegated to profiles via `project_ref` / `verify_ref` (see `draft/REF-BINDING`).
   - Kernel and opcode contracts MUST be phrased in terms of canonical bytes + `project_ref`, never a specific hash function.

3. **Operational totality is expressed via normalization + obligation discharge.**
   - `raw/NORMALIZER` and `draft/BIDIR-DESCENT` are part of the baseline "full" story.
   - In `normalized` mode, equality is **only** reference equality on normalized comparison refs (`cmpRef`).

4. **Gemini-style ∞-topos framing is adopted only as a semantics profile / optional dial.**
   - `raw/SEMANTICS-INFTOPOS` is informational (model-theoretic).
   - `raw/HYPERDESCENT`, `raw/UNIVERSE`, and `raw/SPLIT-PRESENTATION` are optional capabilities/extensions.

### Rationale
This locks in the original intent: **Premath is a definability gate (a linter), not a foundation**.

We still gain reviewer-facing strength by providing a canonical ∞-topos semantics profile and optional "final dial" extensions, without forcing those commitments on all constructors/backends.

### Consequences
- Future work that strengthens coherence (hypercovers), adds universes/comprehension, or requires strict presentations MUST be introduced as explicit capabilities/extensions.
- The next engineering step is no longer "define definability"; it is to build **running code + vectors** for the baseline bundle.

### Next milestone (binding)
Milestone M1: a conformance suite + at least one reference verifier implementation that:

- computes `project_ref` for at least one backend profile,
- normalizes NF deterministically and compares by `cmpRef`,
- emits and discharges Gate obligations deterministically.

---

## 2026-02-19 — Decision 0002: Proof-carrying overlap + cocycle witnesses

### Decision
We standardize an **optional Gate-witness seam** for descent checks:

- `O_ASSERT_OVERLAP` (OBJ opcode `0x05`): certifies pairwise overlap compatibility.
- `O_ASSERT_TRIPLE`  (OBJ opcode `0x06`): certifies triple-overlap coherence ("cocycle" check).

Both opcodes return `Unit` and are parameterized by the active constructor's restriction + equality.

### Rationale
This makes descent **trace-internal**: the Gate does not need to recompute overlap constraints from scratch,
and implementations can move overlap checks into a verified certificate layer.

### Consequences
- These opcodes are OPTIONAL in the raw kernel: they are a certified seam, not a mandatory feature.
- They enable incremental hardening: later work can add proof-carrying *uniqueness/contractibility* witnesses
  beyond brute-force enumeration.

---

## 2026-02-20 — Decision 0003: Contractible gluing as a proof-scheme hook

### Decision
We standardize an **optional Gate-witness seam** for stack-safe uniqueness / contractible gluing that is
explicitly **proof-scheme driven**:

- `O_ASSERT_CONTRACTIBLE` (OBJ opcode `0x07`) takes:
  - `schemeId: Bytes32` (opaque label), and
  - `proofBytes: bytes` (opaque payload)

and certifies that the glue space for a descent datum is **contractible** at the constructor’s sameness level.

Unsupported `schemeId` values MUST be rejected deterministically.

### Rationale
The kernel requires *contractibility* (stack-safe uniqueness), but does not prescribe how to prove it.
In engineering settings, brute-force enumeration is sometimes acceptable (toy models), but production
settings may require compressed proofs (e.g. RLNC decoding, lattice/norm arguments, solver certificates).

Making contractibility verification scheme-driven preserves:

- **backend agnosticism** (no hardcoded cryptography), and
- **proof agnosticism** (no forced proof system),

while still allowing KCIR traces to carry their own uniqueness certificates.

### Consequences
- The toy suite may implement a default scheme (e.g. `toy.enumerate.v1`) purely for determinism.
- Production backends can adopt additional `schemeId` values without changing kernel law text.

---

## 2026-02-20 — Decision 0004: First promotion batch from raw to draft

### Decision
Promote the governance/conformance spine to `draft` status:

- `draft/SPEC-INDEX`
- `draft/CONFORMANCE`
- `draft/CAPABILITY-VECTORS`
- `draft/CHANGE-MORPHISMS`

These remain under `specs/premath/raw/` path for link stability; authoritative
status is the front-matter `status` field.

### Rationale
These documents now define the invariant closure contract used by implementation
and CI:

- profile-invariant kernel/Gate outcomes,
- explicit optional capability claims,
- canonical change-morphism discipline.

Promoting this layer first reduces process ambiguity while keeping technical
surface area controlled.

### Consequences
- Future changes in this layer are expected to behave as draft contracts between
  editor and implementers.
- Conformance and fixture scaffolding for these capabilities are now part of the
  expected running-code discipline.

---

## 2026-02-20 — Decision 0005: Semantic-core promotion from raw to draft

### Decision
Promote the semantic-core contract files to `draft` status:

- `draft/PREMATH-KERNEL`
- `draft/GATE`
- `draft/BIDIR-DESCENT`
- `draft/WITNESS-ID`

Files remain in `specs/premath/raw/` for stable path references; normative
status is the front-matter field.

### Rationale
These files are the load-bearing semantic contract for runtime invariance:

- kernel laws,
- admissibility gate classes,
- operational discharge model,
- deterministic witness identity.

Promoting this batch aligns process state with current implementation and vector
usage, and reduces ambiguity about contract maturity.

### Consequences
- Changes to these specs should now be treated as draft-contract changes and be
  paired with vector/runtime evidence.
- Remaining raw specs can be promoted in later focused batches.

---

## 2026-02-20 — Decision 0006: Interop-core promotion and KCIR core rename

### Decision
Promote the Interop Core contract files to `draft` status:

- `draft/KCIR-CORE` (renamed from legacy id `KCIR-V2-CORE`)
- `draft/NF`
- `draft/REF-BINDING`
- `draft/WIRE-FORMATS`
- `draft/ERROR-CODES`

Rename spec identity from `KCIR-V2-CORE` to `KCIR-CORE` across references.

### Rationale
This batch stabilizes the interop artifact boundary and removes version-biased
naming in the core model reference for greenfield evolution.

### Consequences
- Dependencies and cross-spec references now target `draft/KCIR-CORE`.
- Conformance/interop reading orders now resolve through the renamed core spec.
- Remaining `v2` labels outside this core reference are informational/versioned
  naming and can be migrated separately if desired.

---

## 2026-02-20 — Decision 0007: Draft specs moved to `specs/premath/draft/`

### Decision
Move all promoted draft specs out of `specs/premath/raw/` into
`specs/premath/draft/`.

### Rationale
Directory semantics should match lifecycle semantics:

- `raw/` for experimentation and informational material,
- `draft/` for active contract specs.

This removes ambiguity about normative authority and improves navigation.

### Consequences
- Internal references for promoted specs now use `draft/<SPEC>`.
- `raw/README.md` is narrowed to raw-only scope.
- `draft/README.md` becomes the contract entry point for promoted specs.

---

## 2026-02-20 — Decision 0008: Process docs moved to `specs/process/`

### Decision
Move process governance docs out of `specs/premath/process/` into:

- `specs/process/coss.md`
- `specs/process/decision-log.md`

### Rationale
Process policy applies across the Premath spec lifecycle and should not appear
as a subtype of one lifecycle bucket (`premath/`).

Placing process at `specs/process/` clarifies authority and reduces path
ambiguity in promoted draft/raw specs.

### Consequences
- Draft/raw spec front matter now points to `../../process/coss.md`.
- Repository-level references now use `specs/process/decision-log.md`.

---

## 2026-02-20 — Decision 0009: Add raw operational stack specs (`TUSK`, `SQUEAK`, `CI`)

### Decision
Publish the current operational architecture as raw specs:

- `raw/TUSK-CORE`
- `raw/SQUEAK-CORE`
- `raw/CI-TOPOS`

and index them from:

- `raw/V2-SPECS`
- `draft/SPEC-INDEX` (informative-only references)

### Rationale
We need a documented operational boundary while preserving kernel stability:

- `tusk-core` captures single-world execution contracts,
- `squeak-core` captures inter-world transport contracts,
- `ci-topos` captures closure-style conformance gating.

Keeping this layer raw allows iteration without prematurely hardening runtime
interfaces as conformance requirements.

### Consequences
- The kernel/draft conformance surface remains unchanged.
- KCIR remains optional capability/evidence machinery, not a kernel dependency.
- Promotion of operational specs to draft requires dedicated vectors and
  conformance claims.

---

## 2026-02-21 — Decision 0010: Doctrine-to-operation site map and checker

### Decision
Add a draft, machine-checkable doctrine-to-operation site contract:

- `specs/premath/draft/DOCTRINE-SITE.md`
- `specs/premath/draft/DOCTRINE-SITE.json`

and enforce it with:

- `tools/conformance/check_doctrine_site.py`
- `mise run doctrine-check`

Baseline gates now include doctrine-site validation.

### Rationale
We need an explicit path from meta-doctrine (`DOCTRINE-INF`) to operational
entrypoints (`tools/ci/*`, `tools/conformance/*`) so architecture drift is
auditable and detectable.

The site map makes this path concrete as nodes/covers/edges and binds edge
morphism IDs to declared preservation contracts.

### Consequences
- Declaration-bearing specs must stay coherent with the site map.
- Operational gate entrypoints must remain reachable from doctrine root.
- Refactors touching doctrine declarations, site map, or gate tooling are now
  expected to pass the doctrine-site checker in baseline CI.

---

## 2026-02-21 — Decision 0011: Add LLM instruction doctrine contract

### Decision
Add a draft doctrine contract for typed LLM instruction handling:

- `specs/premath/draft/LLM-INSTRUCTION-DOCTRINE.md`

and map it into the doctrine-to-operation site:

- `specs/premath/draft/DOCTRINE-SITE.json`

### Rationale
Instruction-envelope execution is already operational in this repository
(`tools/ci/run_instruction.sh` + CI witness output), but it needed explicit
doctrine constraints for:

- typed vs unknown instruction classification,
- authority split (LLM proposal vs kernel/runtime admissibility),
- deterministic instruction-to-witness binding.

### Consequences
- Higher-order CI/CD reading order now includes `draft/LLM-INSTRUCTION-DOCTRINE`.
- Doctrine-site coherence checks now include instruction doctrine nodes/edges.
- Instruction tooling remains execution surface only; semantic authority remains
  in kernel/runtime layers.

---

## 2026-02-21 — Decision 0012: Add executable instruction-typing capability vectors

### Decision
Promote instruction typing checks into executable capability conformance with:

- capability id: `capabilities.instruction_typing`
- vectors under:
  `tests/conformance/fixtures/capabilities/capabilities.instruction_typing/`
- runner support in:
  `tools/conformance/run_capability_vectors.py`

### Rationale
The instruction doctrine requires explicit `typed(kind)` / `unknown(reason)`
classification and deterministic handling. We need executable vectors to keep
this behavior regression-resistant and profile-invariant.

### Consequences
- `python3 tools/conformance/run_capability_vectors.py` now executes instruction
  typing vectors by default.
- Fixture/invariance stub checks now include this capability track.
- Claim surfaces (`SPEC-INDEX`, `CAPABILITY-VECTORS`, `CONFORMANCE`) now
  include `capabilities.instruction_typing`.

---

## 2026-02-21 — Decision 0013: Wire instruction doctrine into runtime witness flow

### Decision
Extend `tools/ci/run_instruction.py` to enforce doctrine-level instruction
classification at runtime:

- classify each envelope as `typed(kind)` or `unknown(reason)`,
- reject `unknown(reason)` when `typingPolicy.allowUnknown` is false,
- emit `instructionClassification` and `typingPolicy` in CI witness artifacts.

### Rationale
Doctrine and conformance capability checks were in place, but the operational
instruction runner did not yet surface classification in runtime artifacts.
This closes the spec-to-operation loop.

### Consequences
- instruction witness records now carry explicit typing metadata.
- unroutable unknown instructions fail deterministically before gate execution.
- instruction envelope examples/documentation now include optional typing fields.

---

## 2026-02-21 — Decision 0014: Collapse capability IDs to minimal canonical set

### Decision
Align executable capability IDs with the draft governance vocabulary by
collapsing aliases:

- `capabilities.change_projection` -> `capabilities.change_morphisms`
- `capabilities.ci_required_witness` -> `capabilities.ci_witnesses`

The executable conformance surface now uses:

- `capabilities.normal_forms`
- `capabilities.kcir_witnesses`
- `capabilities.commitment_checkpoints`
- `capabilities.squeak_site`
- `capabilities.ci_witnesses`
- `capabilities.instruction_typing`
- `capabilities.change_morphisms`

### Rationale
Governance drift appeared when runtime/docs used capability IDs not present in
`draft/CAPABILITY-VECTORS` and `draft/CONFORMANCE`. We prefer minimal encoding:
one canonical identifier per capability claim unless expansion is explicitly
promoted as new doctrine.

### Consequences
- `tools/conformance/run_capability_vectors.py` defaults are now canonical and
  draft-aligned.
- capability fixtures were merged/renamed to match canonical IDs.
- docs and command-surface references now use the canonical capability names.

---

## 2026-02-21 — Decision 0015: Introduce explicit profile-overlay lane (`specs/premath/profile`)

### Decision
Add an explicit profile-overlay lane under `specs/premath/profile/` and treat
overlay specs as:

- additive to base draft claims,
- normative only when explicitly claimed,
- required to compile into deterministic checker/discharge behavior.

Initial overlay adopted in-repo:

- `profile/ADJOINTS-AND-SITES`

`draft/SPEC-INDEX` is updated to include:

- profile-overlay claim guidance,
- normative scope for claimed overlays,
- a reading order for adjoints-and-sites implementation.

### Rationale
We need a place for mathematically stronger but optional structures (for example
adjoint/Beck-Chevalley overlays) without inflating baseline kernel obligations.

This keeps the kernel small while allowing policy-scoped strengthening that is
auditable and capability-claim driven.

### Consequences
- Base kernel and existing capability claims remain unchanged unless an overlay
  is explicitly claimed.
- Future overlays should land in `specs/premath/profile/` and wire through
  `draft/SPEC-INDEX` and conformance claims.
- Overlay work should avoid duplicating semantic authority in orchestration
  layers; checker/discharge remains the authority boundary.

---

## 2026-02-22 — Decision 0016: Pre-execution instruction failures MUST emit typed reject witnesses

### Decision
Instruction-envelope execution now emits first-class reject witness artifacts
when validation fails before check execution (schema/shape, policy allowlist,
proposal binding):

- witness kind remains `ci.instruction.v1`,
- verdict is `rejected`,
- `rejectStage` is `pre_execution`,
- `failureClasses` are deterministic typed classes.

Provider-neutral instruction pipeline behavior is updated so validation failures
still produce these artifacts rather than returning only stderr/exit status.

### Rationale
The control plane needs one auditable witness surface for both runtime check
failures and pre-execution admission failures. Without this, invalid envelopes
create blind spots in observation and multiagent coordination.

### Consequences
- `tools/ci/run_instruction.py` now writes reject witnesses on invalid envelopes.
- `tools/ci/pipeline_instruction.py` now ensures invalid-envelope runs still
  emit witness artifacts.
- CI witness conformance now includes reject-witness determinism checks for
  failure-class stability.

---

## 2026-02-22 — Decision 0017: Add executable adjoints/sites capability vectors

### Decision
Introduce executable capability claim `capabilities.adjoints_sites` for the
`profile/ADJOINTS-AND-SITES` overlay with vectors that enforce deterministic
obligation compilation/discharge bound to `(normalizerId, policyDigest)`.

The executable surface now checks obligations for:

- `adjoint_triangle`
- `beck_chevalley_sigma`
- `beck_chevalley_pi`
- `refinement_invariance`

### Rationale
The profile overlay existed as normative text but had no executable claim
surface. This left adjoint/site coherence behavior outside the conformance loop.
Adding vectors keeps overlay claims auditable and regression-resistant.

### Consequences
- `tools/conformance/run_capability_vectors.py` now runs
  `capabilities.adjoints_sites`.
- Conformance fixtures now include golden/adversarial/invariance vectors for
  adjoint/site obligations.
- `draft/CAPABILITY-VECTORS`, `draft/CONFORMANCE`, and `draft/SPEC-INDEX`
  now include the new capability claim semantics.

---

## 2026-02-22 — Decision 0018: Enforce capability-gated instruction-linked issue mutations

### Decision
Strengthen MCP `instruction-linked` mutation policy for issue/dep writes:

- instruction witness must be `accepted`,
- instruction witness must carry `policyDigest` in an allowed mutation scope,
- instruction witness must carry capability claims including:
  - base: `capabilities.change_morphisms`
  - per-action claim (or wildcard `capabilities.change_morphisms.all`)

Action claims are enforced for:
`issue.add`, `issue.update`, `issue.claim`, `issue.discover`, and `dep.add`.

### Rationale
Instruction linkage by presence alone is too permissive. Mutation authorization
must be capability-scoped and policy-scoped so agents cannot mutate long-running
work memory outside declared boundaries.

### Consequences
- `crates/premath-cli/src/commands/mcp_serve.rs` now enforces capability and
  policy gating on instruction-linked mutations.
- instruction witness links now expose `capabilityClaims`.
- instruction runner/checker surfaces now validate/carry optional
  `capabilityClaims` fields.

---

## 2026-02-22 — Decision 0019: Introduce deterministic multiagent claim-lease protocol

### Decision
Extend issue mutation surface with deterministic lease lifecycle semantics:

- `issue.claim` now binds claim ownership to a lease tuple
  (`lease_id`, owner, expiry),
- add `issue.lease_renew` and `issue.lease_release` mutations,
- add `issue.lease_projection` read model for deterministic stale/contended
  lease classification.

Lease-contention and lease-lifecycle failures are typed with deterministic
failure classes (for example `lease_contention_active`, `lease_stale`,
`lease_owner_mismatch`, `lease_id_mismatch`).

### Rationale
Instruction-scoped mutation authorization was in place, but concurrent agents
still needed deterministic coordination primitives to avoid implicit work
stealing and long-running claim drift. A lease protocol narrows operational
degrees of freedom while preserving explicit handoff/renew flows.

### Consequences
- `premath-bd` issue schema now includes first-class lease state.
- MCP mutation surface includes renew/release actions and lease projection.
- `capabilities.change_morphisms` executable vectors now cover lease claim
  transitions, active-contention rejects, and stale/contended projection
  invariants.

---

## 2026-02-22 — Decision 0020: Adopt draft spec traceability matrix with explicit coverage targets

### Decision
Adopt `draft/SPEC-TRACEABILITY` as the canonical matrix mapping promoted draft
specs to executable conformance/check surfaces.

The matrix introduces explicit status classes:

- `covered`
- `instrumented`
- `gap`

and requires every `gap` row to reference a concrete target ID.

### Rationale
Conformance vectors were strong for capability claims, but coverage boundaries
for several promoted draft specs were implicit and distributed across docs/tests.

A single traceability surface reduces planning drift, makes gaps explicit, and
gives issue discovery a deterministic source of truth.

### Consequences
- `draft/SPEC-TRACEABILITY` is now part of promoted draft documentation and is
  linked from `draft/README`, `draft/SPEC-INDEX`, and `draft/CONFORMANCE`.
- current explicit targets include:
  - `T-IC-01` (interop-core executable vectors),
  - `T-GATE-01` (canonical gate vectors),
  - `T-WID-01` (witness-id conformance vectors),
  - `T-DINF-01` (doctrine-inf semantic coverage upgrade),
  - `T-KERNEL-01` (cross-model kernel vector profile),
  - `T-INDEX-01` (index/traceability integrity check).
