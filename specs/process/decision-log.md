# Decision Log

This log records decisions that intentionally constrain future changes.

---

## 2026-02-19 — Decision 0001: Premath Kernel bundle commitment ("v0.1")

### Decision
We commit to a **profile-preserving** specification structure:

1. **Kernel stays minimal and ontology-agnostic.**
   - The normative kernel is `draft/PREMATH-KERNEL`.
   - Definability is **behavior**: coherent reindexing + locality + **contractible descent** on the Grothendieck topology generated by the declared coverage.
   - The kernel does **not** hardcode a semantic universe (Set/Gpd/∞-groupoids). It is parameterized by an ambient sameness level `V` with a chosen notion of equivalence `≈`.

2. **Backend-generic binding is a first-class seam.**
   - Reference binding is delegated to profiles via `project_ref` / `verify_ref` (see `draft/REF-BINDING`).
   - Kernel and opcode contracts MUST be phrased in terms of canonical bytes + `project_ref`, never a specific hash function.

3. **Operational totality is expressed via normalization + obligation discharge.**
   - `draft/NORMALIZER` and `draft/BIDIR-DESCENT` are part of the baseline "full" story.
   - In `normalized` mode, equality is **only** reference equality on normalized comparison refs (`cmpRef`).

4. **Gemini-style ∞-topos framing is adopted only as a semantics profile / optional dial.**
   - `raw/SEMANTICS-INFTOPOS` is informational (model-theoretic).
   - `raw/HYPERDESCENT`, `raw/UNIVERSE`, and `raw/SPLIT-PRESENTATION` are optional capabilities/extensions.

### Rationale
This locks in the original intent: **Premath is a definability gate (a linter), not a foundation**.

We still gain reviewer-facing strength by providing a canonical ∞-topos semantics profile and optional "final dial" extensions, without forcing those commitments on all constructors/backends.

### Consequences
- Future work that strengthens coherence (hypercovers), adds universes/comprehension, or requires strict presentations MUST be introduced as explicit capabilities/extensions.
- The next engineering step is no longer "define definability"; it is to build **running code + vectors** for the baseline bundle.

### Next milestone (binding)
Milestone M1: a conformance suite + at least one reference verifier implementation that:

- computes `project_ref` for at least one backend profile,
- normalizes NF deterministically and compares by `cmpRef`,
- emits and discharges Gate obligations deterministically.

---

## 2026-02-19 — Decision 0002: Proof-carrying overlap + cocycle witnesses

### Decision
We standardize an **optional Gate-witness seam** for descent checks:

- `O_ASSERT_OVERLAP` (OBJ opcode `0x05`): certifies pairwise overlap compatibility.
- `O_ASSERT_TRIPLE`  (OBJ opcode `0x06`): certifies triple-overlap coherence ("cocycle" check).

Both opcodes return `Unit` and are parameterized by the active constructor's restriction + equality.

### Rationale
This makes descent **trace-internal**: the Gate does not need to recompute overlap constraints from scratch,
and implementations can move overlap checks into a verified certificate layer.

### Consequences
- These opcodes are OPTIONAL in the raw kernel: they are a certified seam, not a mandatory feature.
- They enable incremental hardening: later work can add proof-carrying *uniqueness/contractibility* witnesses
  beyond brute-force enumeration.

---

## 2026-02-20 — Decision 0003: Contractible gluing as a proof-scheme hook

### Decision
We standardize an **optional Gate-witness seam** for stack-safe uniqueness / contractible gluing that is
explicitly **proof-scheme driven**:

- `O_ASSERT_CONTRACTIBLE` (OBJ opcode `0x07`) takes:
  - `schemeId: Bytes32` (opaque label), and
  - `proofBytes: bytes` (opaque payload)

and certifies that the glue space for a descent datum is **contractible** at the constructor’s sameness level.

Unsupported `schemeId` values MUST be rejected deterministically.

### Rationale
The kernel requires *contractibility* (stack-safe uniqueness), but does not prescribe how to prove it.
In engineering settings, brute-force enumeration is sometimes acceptable (toy models), but production
settings may require compressed proofs (e.g. RLNC decoding, lattice/norm arguments, solver certificates).

Making contractibility verification scheme-driven preserves:

- **backend agnosticism** (no hardcoded cryptography), and
- **proof agnosticism** (no forced proof system),

while still allowing KCIR traces to carry their own uniqueness certificates.

### Consequences
- The toy suite may implement a default scheme (e.g. `toy.enumerate.v1`) purely for determinism.
- Production backends can adopt additional `schemeId` values without changing kernel law text.

---

## 2026-02-20 — Decision 0004: First promotion batch from raw to draft

### Decision
Promote the governance/conformance spine to `draft` status:

- `draft/SPEC-INDEX`
- `draft/CONFORMANCE`
- `draft/CAPABILITY-VECTORS`
- `draft/CHANGE-MORPHISMS`

These remain under `specs/premath/raw/` path for link stability; authoritative
status is the front-matter `status` field.

### Rationale
These documents now define the invariant closure contract used by implementation
and CI:

- profile-invariant kernel/Gate outcomes,
- explicit optional capability claims,
- canonical change-morphism discipline.

Promoting this layer first reduces process ambiguity while keeping technical
surface area controlled.

### Consequences
- Future changes in this layer are expected to behave as draft contracts between
  editor and implementers.
- Conformance and fixture scaffolding for these capabilities are now part of the
  expected running-code discipline.

---

## 2026-02-20 — Decision 0005: Semantic-core promotion from raw to draft

### Decision
Promote the semantic-core contract files to `draft` status:

- `draft/PREMATH-KERNEL`
- `draft/GATE`
- `draft/BIDIR-DESCENT`
- `draft/WITNESS-ID`

Files remain in `specs/premath/raw/` for stable path references; normative
status is the front-matter field.

### Rationale
These files are the load-bearing semantic contract for runtime invariance:

- kernel laws,
- admissibility gate classes,
- operational discharge model,
- deterministic witness identity.

Promoting this batch aligns process state with current implementation and vector
usage, and reduces ambiguity about contract maturity.

### Consequences
- Changes to these specs should now be treated as draft-contract changes and be
  paired with vector/runtime evidence.
- Remaining raw specs can be promoted in later focused batches.

---

## 2026-02-20 — Decision 0006: Interop-core promotion and KCIR core rename

### Decision
Promote the Interop Core contract files to `draft` status:

- `draft/KCIR-CORE` (renamed from legacy id `KCIR-V2-CORE`)
- `draft/NF`
- `draft/REF-BINDING`
- `draft/WIRE-FORMATS`
- `draft/ERROR-CODES`

Rename spec identity from `KCIR-V2-CORE` to `KCIR-CORE` across references.

### Rationale
This batch stabilizes the interop artifact boundary and removes version-biased
naming in the core model reference for greenfield evolution.

### Consequences
- Dependencies and cross-spec references now target `draft/KCIR-CORE`.
- Conformance/interop reading orders now resolve through the renamed core spec.
- Remaining `v2` labels outside this core reference are informational/versioned
  naming and can be migrated separately if desired.

---

## 2026-02-20 — Decision 0007: Draft specs moved to `specs/premath/draft/`

### Decision
Move all promoted draft specs out of `specs/premath/raw/` into
`specs/premath/draft/`.

### Rationale
Directory semantics should match lifecycle semantics:

- `raw/` for experimentation and informational material,
- `draft/` for active contract specs.

This removes ambiguity about normative authority and improves navigation.

### Consequences
- Internal references for promoted specs now use `draft/<SPEC>`.
- `raw/README.md` is narrowed to raw-only scope.
- `draft/README.md` becomes the contract entry point for promoted specs.

---

## 2026-02-20 — Decision 0008: Process docs moved to `specs/process/`

### Decision
Move process governance docs out of `specs/premath/process/` into:

- `specs/process/coss.md`
- `specs/process/decision-log.md`

### Rationale
Process policy applies across the Premath spec lifecycle and should not appear
as a subtype of one lifecycle bucket (`premath/`).

Placing process at `specs/process/` clarifies authority and reduces path
ambiguity in promoted draft/raw specs.

### Consequences
- Draft/raw spec front matter now points to `../../process/coss.md`.
- Repository-level references now use `specs/process/decision-log.md`.

---

## 2026-02-20 — Decision 0009: Add raw operational stack specs (`TUSK`, `SQUEAK`, `CI`)

### Decision
Publish the current operational architecture as raw specs:

- `raw/TUSK-CORE`
- `raw/SQUEAK-CORE`
- `raw/CI-TOPOS`

and index them from:

- `raw/V2-SPECS`
- `draft/SPEC-INDEX` (informative-only references)

### Rationale
We need a documented operational boundary while preserving kernel stability:

- `tusk-core` captures single-world execution contracts,
- `squeak-core` captures inter-world transport contracts,
- `ci-topos` captures closure-style conformance gating.

Keeping this layer raw allows iteration without prematurely hardening runtime
interfaces as conformance requirements.

### Consequences
- The kernel/draft conformance surface remains unchanged.
- KCIR remains optional capability/evidence machinery, not a kernel dependency.
- Promotion of operational specs to draft requires dedicated vectors and
  conformance claims.

---

## 2026-02-21 — Decision 0010: Doctrine-to-operation site map and checker

### Decision
Add a draft, machine-checkable doctrine-to-operation site contract:

- `specs/premath/draft/DOCTRINE-SITE.md`
- `specs/premath/draft/DOCTRINE-SITE.json`

and enforce it with:

- `tools/conformance/check_doctrine_site.py`
- `mise run doctrine-check`

Baseline gates now include doctrine-site validation.

### Rationale
We need an explicit path from meta-doctrine (`DOCTRINE-INF`) to operational
entrypoints (`tools/ci/*`, `tools/conformance/*`) so architecture drift is
auditable and detectable.

The site map makes this path concrete as nodes/covers/edges and binds edge
morphism IDs to declared preservation contracts.

### Consequences
- Declaration-bearing specs must stay coherent with the site map.
- Operational gate entrypoints must remain reachable from doctrine root.
- Refactors touching doctrine declarations, site map, or gate tooling are now
  expected to pass the doctrine-site checker in baseline CI.

---

## 2026-02-21 — Decision 0011: Add LLM instruction doctrine contract

### Decision
Add a draft doctrine contract for typed LLM instruction handling:

- `specs/premath/draft/LLM-INSTRUCTION-DOCTRINE.md`

and map it into the doctrine-to-operation site:

- `specs/premath/draft/DOCTRINE-SITE.json`

### Rationale
Instruction-envelope execution is already operational in this repository
(`tools/ci/run_instruction.sh` + CI witness output), but it needed explicit
doctrine constraints for:

- typed vs unknown instruction classification,
- authority split (LLM proposal vs kernel/runtime admissibility),
- deterministic instruction-to-witness binding.

### Consequences
- Higher-order CI/CD reading order now includes `draft/LLM-INSTRUCTION-DOCTRINE`.
- Doctrine-site coherence checks now include instruction doctrine nodes/edges.
- Instruction tooling remains execution surface only; semantic authority remains
  in kernel/runtime layers.

---

## 2026-02-21 — Decision 0012: Add executable instruction-typing capability vectors

### Decision
Promote instruction typing checks into executable capability conformance with:

- capability id: `capabilities.instruction_typing`
- vectors under:
  `tests/conformance/fixtures/capabilities/capabilities.instruction_typing/`
- runner support in:
  `tools/conformance/run_capability_vectors.py`

### Rationale
The instruction doctrine requires explicit `typed(kind)` / `unknown(reason)`
classification and deterministic handling. We need executable vectors to keep
this behavior regression-resistant and profile-invariant.

### Consequences
- `python3 tools/conformance/run_capability_vectors.py` now executes instruction
  typing vectors by default.
- Fixture/invariance stub checks now include this capability track.
- Claim surfaces (`SPEC-INDEX`, `CAPABILITY-VECTORS`, `CONFORMANCE`) now
  include `capabilities.instruction_typing`.

---

## 2026-02-21 — Decision 0013: Wire instruction doctrine into runtime witness flow

### Decision
Extend `tools/ci/run_instruction.py` to enforce doctrine-level instruction
classification at runtime:

- classify each envelope as `typed(kind)` or `unknown(reason)`,
- reject `unknown(reason)` when `typingPolicy.allowUnknown` is false,
- emit `instructionClassification` and `typingPolicy` in CI witness artifacts.

### Rationale
Doctrine and conformance capability checks were in place, but the operational
instruction runner did not yet surface classification in runtime artifacts.
This closes the spec-to-operation loop.

### Consequences
- instruction witness records now carry explicit typing metadata.
- unroutable unknown instructions fail deterministically before gate execution.
- instruction envelope examples/documentation now include optional typing fields.

---

## 2026-02-21 — Decision 0014: Collapse capability IDs to minimal canonical set

### Decision
Align executable capability IDs with the draft governance vocabulary by
collapsing aliases:

- `capabilities.change_projection` -> `capabilities.change_morphisms`
- `capabilities.ci_required_witness` -> `capabilities.ci_witnesses`

The executable conformance surface now uses:

- `capabilities.normal_forms`
- `capabilities.kcir_witnesses`
- `capabilities.commitment_checkpoints`
- `capabilities.squeak_site`
- `capabilities.ci_witnesses`
- `capabilities.instruction_typing`
- `capabilities.change_morphisms`

### Rationale
Governance drift appeared when runtime/docs used capability IDs not present in
`draft/CAPABILITY-VECTORS` and `draft/CONFORMANCE`. We prefer minimal encoding:
one canonical identifier per capability claim unless expansion is explicitly
promoted as new doctrine.

### Consequences
- `tools/conformance/run_capability_vectors.py` defaults are now canonical and
  draft-aligned.
- capability fixtures were merged/renamed to match canonical IDs.
- docs and command-surface references now use the canonical capability names.

---

## 2026-02-21 — Decision 0015: Introduce explicit profile-overlay lane (`specs/premath/profile`)

### Decision
Add an explicit profile-overlay lane under `specs/premath/profile/` and treat
overlay specs as:

- additive to base draft claims,
- normative only when explicitly claimed,
- required to compile into deterministic checker/discharge behavior.

Initial overlay adopted in-repo:

- `profile/ADJOINTS-AND-SITES`

`draft/SPEC-INDEX` is updated to include:

- profile-overlay claim guidance,
- normative scope for claimed overlays,
- a reading order for adjoints-and-sites implementation.

### Rationale
We need a place for mathematically stronger but optional structures (for example
adjoint/Beck-Chevalley overlays) without inflating baseline kernel obligations.

This keeps the kernel small while allowing policy-scoped strengthening that is
auditable and capability-claim driven.

### Consequences
- Base kernel and existing capability claims remain unchanged unless an overlay
  is explicitly claimed.
- Future overlays should land in `specs/premath/profile/` and wire through
  `draft/SPEC-INDEX` and conformance claims.
- Overlay work should avoid duplicating semantic authority in orchestration
  layers; checker/discharge remains the authority boundary.

---

## 2026-02-22 — Decision 0016: Pre-execution instruction failures MUST emit typed reject witnesses

### Decision
Instruction-envelope execution now emits first-class reject witness artifacts
when validation fails before check execution (schema/shape, policy allowlist,
proposal binding):

- witness kind remains `ci.instruction.v1`,
- verdict is `rejected`,
- `rejectStage` is `pre_execution`,
- `failureClasses` are deterministic typed classes.

Provider-neutral instruction pipeline behavior is updated so validation failures
still produce these artifacts rather than returning only stderr/exit status.

### Rationale
The control plane needs one auditable witness surface for both runtime check
failures and pre-execution admission failures. Without this, invalid envelopes
create blind spots in observation and multiagent coordination.

### Consequences
- `tools/ci/run_instruction.py` now writes reject witnesses on invalid envelopes.
- `tools/ci/pipeline_instruction.py` now ensures invalid-envelope runs still
  emit witness artifacts.
- CI witness conformance now includes reject-witness determinism checks for
  failure-class stability.

---

## 2026-02-22 — Decision 0017: Add executable adjoints/sites capability vectors

### Decision
Introduce executable capability claim `capabilities.adjoints_sites` for the
`profile/ADJOINTS-AND-SITES` overlay with vectors that enforce deterministic
obligation compilation/discharge bound to `(normalizerId, policyDigest)`.

The executable surface now checks obligations for:

- `adjoint_triangle`
- `beck_chevalley_sigma`
- `beck_chevalley_pi`
- `refinement_invariance`

### Rationale
The profile overlay existed as normative text but had no executable claim
surface. This left adjoint/site coherence behavior outside the conformance loop.
Adding vectors keeps overlay claims auditable and regression-resistant.

### Consequences
- `tools/conformance/run_capability_vectors.py` now runs
  `capabilities.adjoints_sites`.
- Conformance fixtures now include golden/adversarial/invariance vectors for
  adjoint/site obligations.
- `draft/CAPABILITY-VECTORS`, `draft/CONFORMANCE`, and `draft/SPEC-INDEX`
  now include the new capability claim semantics.

---

## 2026-02-22 — Decision 0018: Enforce capability-gated instruction-linked issue mutations

### Decision
Strengthen MCP `instruction-linked` mutation policy for issue/dep writes:

- instruction witness must be `accepted`,
- instruction witness must carry `policyDigest` in an allowed mutation scope,
- instruction witness must carry capability claims including:
  - base: `capabilities.change_morphisms`
  - per-action claim (or wildcard `capabilities.change_morphisms.all`)

Action claims are enforced for:
`issue.add`, `issue.update`, `issue.claim`, `issue.discover`, and `dep.add`.

### Rationale
Instruction linkage by presence alone is too permissive. Mutation authorization
must be capability-scoped and policy-scoped so agents cannot mutate long-running
work memory outside declared boundaries.

### Consequences
- `crates/premath-cli/src/commands/mcp_serve.rs` now enforces capability and
  policy gating on instruction-linked mutations.
- instruction witness links now expose `capabilityClaims`.
- instruction runner/checker surfaces now validate/carry optional
  `capabilityClaims` fields.

---

## 2026-02-22 — Decision 0019: Introduce deterministic multiagent claim-lease protocol

### Decision
Extend issue mutation surface with deterministic lease lifecycle semantics:

- `issue.claim` now binds claim ownership to a lease tuple
  (`lease_id`, owner, expiry),
- add `issue.lease_renew` and `issue.lease_release` mutations,
- add `issue.lease_projection` read model for deterministic stale/contended
  lease classification.

Lease-contention and lease-lifecycle failures are typed with deterministic
failure classes (for example `lease_contention_active`, `lease_stale`,
`lease_owner_mismatch`, `lease_id_mismatch`).

### Rationale
Instruction-scoped mutation authorization was in place, but concurrent agents
still needed deterministic coordination primitives to avoid implicit work
stealing and long-running claim drift. A lease protocol narrows operational
degrees of freedom while preserving explicit handoff/renew flows.

### Consequences
- `premath-bd` issue schema now includes first-class lease state.
- MCP mutation surface includes renew/release actions and lease projection.
- `capabilities.change_morphisms` executable vectors now cover lease claim
  transitions, renew/release lifecycle transitions, active-contention rejects,
  and stale/contended projection invariants.

---

## 2026-02-22 — Decision 0020: Adopt draft spec traceability matrix with explicit coverage targets

### Decision
Adopt `draft/SPEC-TRACEABILITY` as the canonical matrix mapping promoted draft
specs to executable conformance/check surfaces.

The matrix introduces explicit status classes:

- `covered`
- `instrumented`
- `gap`

and requires every `gap` row to reference a concrete target ID.

### Rationale
Conformance vectors were strong for capability claims, but coverage boundaries
for several promoted draft specs were implicit and distributed across docs/tests.

A single traceability surface reduces planning drift, makes gaps explicit, and
gives issue discovery a deterministic source of truth.

### Consequences
- `draft/SPEC-TRACEABILITY` is now part of promoted draft documentation and is
  linked from `draft/README`, `draft/SPEC-INDEX`, and `draft/CONFORMANCE`.
- current explicit targets include:
  - `T-IC-01` (interop-core executable vectors),
  - `T-GATE-01` (canonical gate vectors),
  - `T-WID-01` (witness-id conformance vectors),
  - `T-DINF-01` (doctrine-inf semantic coverage upgrade),
  - `T-KERNEL-01` (cross-model kernel vector profile),
  - `T-INDEX-01` (index/traceability integrity check).

---

## 2026-02-22 — Decision 0021: Execute T-IC-01 with first-class interop-core vectors

### Decision
Implement and merge executable Interop Core vector coverage under
`tests/conformance/fixtures/interop-core/` with deterministic runner
`tools/conformance/run_interop_core_vectors.py`, and wire it into
`mise run conformance-run`.

Covered slices:

- `draft/KCIR-CORE` (domain table minimum),
- `draft/REF-BINDING` (projection + verify digest/profile/domain semantics),
- `draft/NF` (ObjNF/MorNF parser contracts, including `PullAtom` claim gate),
- `draft/WIRE-FORMATS` (registered wire parse behavior),
- `draft/ERROR-CODES` (registry membership checks).

### Rationale
`T-IC-01` was the largest explicit traceability gap for promoted draft specs.
Closing it converts Interop Core from mostly indirect instrumentation into a
deterministic vectored surface in merge-gated conformance runs.

### Consequences
- `mise run conformance-run` now executes interop-core vectors before capability
  vectors.
- `draft/SPEC-TRACEABILITY` rows for `KCIR-CORE`, `REF-BINDING`, `NF`,
  `WIRE-FORMATS`, and `ERROR-CODES` move to `covered`.
- Remaining open coverage upgrades continue under `T-GATE-01`, `T-WID-01`,
  `T-DINF-01`, `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0022: Execute T-GATE-01 with canonical gate vectors

### Decision
Implement and merge executable Gate vectors under
`tests/conformance/fixtures/gate/` with deterministic runner
`tools/conformance/run_gate_vectors.py`, and wire it into
`mise run conformance-run`.

Covered gate-law classes:

- `stability_failure` (`GATE-3.1`)
- `locality_failure` (`GATE-3.2`)
- `descent_failure` (`GATE-3.3`)
- `glue_non_contractible` (`GATE-3.4`)

### Rationale
`GATE` coverage previously depended on unit/toy paths without a canonical
conformance fixture suite in `tests/conformance/fixtures/gate/`. This made the
traceability target `T-GATE-01` an explicit open gap.

### Consequences
- `mise run conformance-run` now executes gate vectors in addition to interop
  and capability vectors.
- `draft/SPEC-TRACEABILITY` marks `GATE.md` as `covered`.
- Open traceability upgrades now continue under `T-WID-01`, `T-DINF-01`,
  `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0023: Execute T-WID-01 with witness-id conformance vectors

### Decision
Implement and merge executable Witness-ID vectors under
`tests/conformance/fixtures/witness-id/` with deterministic runner
`tools/conformance/run_witness_id_vectors.py`, and wire it into
`mise run conformance-run` through the fixture-suite runner.

Covered Witness-ID requirements:

- stability under excluded-field variation (`message`, `sources`, `details`),
- sensitivity to canonical witness-key fields (`class`, `lawRef`, `tokenPath`,
  `context`),
- deterministic witness-id computation for fixed key material.

### Rationale
`WITNESS-ID.md` was only instrumented via unit tests. `T-WID-01` required a
first-class conformance vector suite in the merge-gated conformance surface so
determinism/sensitivity behavior is validated at fixture level.

### Consequences
- `mise run conformance-run` now executes witness-id vectors alongside interop,
  gate, and capability suites.
- `draft/SPEC-TRACEABILITY` marks `WITNESS-ID.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01`, `T-KERNEL-01`, and
  `T-INDEX-01`.

---

## 2026-02-22 — Decision 0024: Execute T-INDEX-01 with deterministic traceability matrix check

### Decision
Implement and merge deterministic traceability matrix integrity validation via
`tools/conformance/check_spec_traceability.py`, and wire it into
`mise run baseline` as `mise run traceability-check`.

Coverage checks enforce:

- every promoted draft spec under `specs/premath/draft/` appears exactly once
  in `draft/SPEC-TRACEABILITY`,
- matrix status classes are restricted to `covered|instrumented|gap`,
- `gap` rows require concrete target IDs (`T-*-*`),
- no matrix rows reference unknown draft specs.

### Rationale
`SPEC-INDEX`/traceability coverage was previously instrumentation-by-convention.
`T-INDEX-01` required a deterministic executable surface to prevent drift
between promoted draft spec inventory and matrix rows.

### Consequences
- `mise run baseline` now includes `mise run traceability-check`.
- `draft/SPEC-TRACEABILITY` marks `SPEC-INDEX.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01` and `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0025: Execute T-DINF-01 with doctrine-inf semantic boundary vectors

### Decision
Extend doctrine validation with executable law-level checks for declared
preserved/not-preserved morphism boundaries via
`tools/conformance/run_doctrine_inf_vectors.py` and fixture suite
`tests/conformance/fixtures/doctrine-inf/`, and include these vectors in
`mise run doctrine-check`.

Covered doctrine boundary checks:

- edge morphisms must lie within destination `preserved` declarations,
- edge morphisms declared `notPreserved` reject deterministically,
- overlap between `preserved` and `notPreserved` declarations rejects
  deterministically.

### Rationale
`DOCTRINE-INF.md` coverage was previously graph/declaration coherence only.
`T-DINF-01` required executable semantic boundary checks that enforce doctrine
declaration meaning, not just declaration presence.

### Consequences
- `mise run doctrine-check` now runs both doctrine-site coherence and
  doctrine-inf semantic boundary vectors.
- `draft/SPEC-TRACEABILITY` marks `DOCTRINE-INF.md` as `covered`.
- Open traceability upgrades continue under `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0026: Execute T-KERNEL-01 with cross-model kernel profile vectors

### Decision
Implement and merge a canonical cross-model kernel profile vector suite under
`tests/conformance/fixtures/kernel-profile/` with deterministic runner
`tools/conformance/run_kernel_profile_vectors.py`, and wire it into
`mise run conformance-run` via the cached fixture-suite runner.

Covered kernel profile checks:

- stable semantic result parity (`accepted|rejected`) across toy and KCIR toy
  evidence surfaces for shared scenarios,
- stable failure tuple parity (`class`, `lawRef`, `witnessId`) across both
  surfaces for rejected scenarios,
- deterministic expected-outcome validation for each canonical vector.

### Rationale
`PREMATH-KERNEL.md` coverage previously remained `instrumented` through host
tests and toy suites without a canonical cross-model profile for reproducible
comparison. `T-KERNEL-01` required a dedicated deterministic conformance vector
surface that compares kernel-law outcomes across multiple evidence
representations.

### Consequences
- `mise run conformance-run` now executes `kernel-profile` vectors alongside
  interop-core, gate, witness-id, and capability suites under KCIR-style cache
  bindings.
- `draft/SPEC-TRACEABILITY` marks `PREMATH-KERNEL.md` as `covered`.
- The traceability target backlog (`T-*-*`) is currently empty.

---

## 2026-02-22 — Decision 0027: Expand Observation Surface with coherence projections

### Decision
Extend `Observation Surface v0` to include explicit coherence projections in
`summary.coherence` and expose them through observe query surfaces and the docs
dashboard:

- policy drift projection,
- unknown instruction-classification rate,
- proposal reject-class aggregation,
- ready-vs-blocked open-issue partition integrity,
- stale/contended lease-claim health.

Implementation surfaces:

- reducer/query: `tools/ci/observation_surface.py`
- semantic invariance checks: `premath observation-semantics-check`
- reducer tests: `tools/ci/test_observation_surface.py`
- observe read models: `crates/premath-surreal/src/observation.rs`,
  `crates/premath-ux/src/lib.rs`,
  `crates/premath-cli/src/commands/observe.rs`
- dashboard: `docs/observation/index.html`

### Rationale
Coherence v1 needed a single operator-facing observation surface that reports
not only required-gate verdict state but also control-plane coherence risks
(policy drift, unknown typing pressure, proposal failure shape, issue partition
integrity, and lease staleness/contention). Without these projections,
attention routing remained under-specified.

### Consequences
- `observe latest` and `observe needs_attention` now include coherence
  projection data for downstream tools/dashboards.
- `needsAttention` is now raised for rejected/error state *or* coherence
  attention reasons.
- Observation semantics checks now validate coherence-attention consistency.

---

## 2026-02-22 — Decision 0028: Extend doctrine-site operation coverage to doctrine-inf vectors

### Decision
Add the doctrine-inf executable vector runner as a first-class doctrine-site
operation node:

- `op/conformance.doctrine_inf` ->
  `tools/conformance/run_doctrine_inf_vectors.py`

and bind it into `draft/DOCTRINE-SITE.json` covers/edges so it is reachable
from doctrine root under the same CI control-loop ancestry as other doctrine
operations.

### Rationale
`mise run doctrine-check` executes both doctrine-site coherence checks and
doctrine-inf semantic boundary vectors. The site map previously represented only
`check_doctrine_site.py`, leaving the second doctrine-check operation outside
the audited doctrine-to-operation graph.

### Consequences
- doctrine-site reachability checks now include
  `tools/conformance/run_doctrine_inf_vectors.py`.
- `draft/DOCTRINE-SITE.md` repository notes now enumerate both doctrine
  conformance operation nodes.

---

## 2026-02-22 — Decision 0029: Add coherence contract checker and unify bidir proposal canonicalization

### Decision
Introduce a typed coherence-contract execution surface with deterministic
witnesses:

- new contract/checker crate: `crates/premath-coherence/`
- new CLI command: `premath coherence-check`
- canonical contract artifact: `specs/premath/draft/COHERENCE-CONTRACT.json`
- normative draft doc: `specs/premath/draft/PREMATH-COHERENCE.md`
- baseline gate integration: `mise run baseline` now includes
  `mise run coherence-check`.

For instruction proposal checking, remove duplicated conformance
canonicalization logic and require conformance vectors to use
`tools/ci/instruction_proposal.py` as the single source of canonical proposal
typing/digest behavior.

Additionally tighten envelope binding hygiene by rejecting leading/trailing
whitespace in top-level `normalizerId` and `policyDigest`.

### Rationale
The doctrine/checker split requires one deterministic control-plane coherence
surface that can reject contradictory docs/capability/gate/operation mappings
as typed obligations, and one canonical checker implementation for LLM proposal
canonicalization/discharge semantics. Duplicated canonicalizers create silent
drift risk between executable conformance and runtime instruction checking.

### Consequences
- Coherence is now executable and witness-producing through a merge-gated
  command surface (`coherence-check`).
- Bidir proposal typing/discharge semantics are now anchored to one Python
  checker implementation for both instruction execution and conformance vectors.
- Reject witnesses now fail closed on whitespace-bound binding fields that would
  otherwise bypass canonical policy/normalizer matching.

---

## 2026-02-22 — Decision 0030: Adopt issue.event.v1 replay boundary and projected dependency views

### Decision
For issue memory evolution, keep a single canonical edge encoding and add
deterministic projection/replay surfaces:

- add `issue.event.v1` in `premath-bd` as an append-only event envelope with
  deterministic migration from issue snapshot JSONL and deterministic replay.
- add `premath issue migrate-events` to emit `.premath/memory/events.jsonl`
  and fail closed on replay mismatch.
- keep one dependency encoding (`DepType`) and add semantic projections
  (`execution`, `gtd`, `groupoid`) via `premath dep project`.

### Rationale
The issue system needs minimum encoding with maximum expressiveness. Multiple
parallel edge schemas would duplicate semantics and drift. A single canonical
encoding plus projection views gives expressiveness for different workflows
(execution/GTD/groupoid) while preserving deterministic replay and auditable
state evolution.

### Consequences
- Snapshot memory now has a deterministic migration path to event-log memory.
- Replay equivalence is executable and test-gated.
- Workflow-specific dependency interpretations are explicit projection views,
  not schema forks.

---

## 2026-02-22 — Decision 0031: Align lease-claim conformance semantics with runtime state machine

### Decision
For issue lease/claim workflow semantics, make conformance vectors enforce the
same state machine as MCP runtime claim paths:

- stale lease claims are reclaimable (state may be normalized before claim),
- lease binding rejects ambiguous claim inputs (`ttl` + explicit expiry),
- lease TTL range is bounded,
- explicit lease expiry must be in the future,
- default lease-id derivation uses the same token normalization shape as runtime.

Add executable vectors for:

- stale lease reclaim golden path,
- invalid expiry reject,
- invalid TTL reject.

### Rationale
Lease/workflow control is a high-leverage orchestration boundary. Any drift
between executable conformance and runtime mutation semantics creates silent
multiagent coordination bugs.

### Consequences
- change-morphism conformance now catches stale-claim and lease-binding drift.
- runtime and conformance both fail-closed on invalid claim lease bindings.

---

## 2026-02-22 — Decision 0032: Make issue event memory projection bidirectional at CLI surface

### Decision
Expose deterministic event replay alongside migration:

- `premath issue migrate-events`: snapshot (`issues.jsonl`) -> event log
  (`issue.event.v1`)
- `premath issue replay-events`: event log (`issue.event.v1`) -> snapshot
  (`issues.jsonl`)

Replay writes a deterministic snapshot projection and reports equivalence to any
pre-existing snapshot at the target path.

### Rationale
Event memory should not be write-only from snapshot state. Operators and agents
need a deterministic, auditable projection path in both directions to support
rebuilds, cache invalidation, and reproducible substrate recovery.

### Consequences
- issue memory CLI now supports deterministic snapshot/event round-trips.
- replay idempotence and projection behavior are smoke-tested.

---

## 2026-02-22 — Decision 0033: Bind replay-cache hits to deterministic event and snapshot refs

### Decision
For event-memory replay, add deterministic cache binding and executable
conformance coverage:

- `premath issue replay-events` now accepts `--cache` (default derived from the
  target issues path) and emits:
  - `eventStreamRef` (`ev1_*`)
  - `snapshotRef` (`iss1_*`)
  - `cacheHit` and `cachePath`.
- cache hits are only valid when `(eventsPath, issuesPath, eventStreamRef,
  snapshotRef)` agree with current surfaces.
- replay writes are skipped on cache hit and on equivalent pre-existing
  snapshots.
- `capabilities.change_morphisms` gains replay-cache vectors:
  - golden stable hit,
  - adversarial ref mismatch reject,
  - local/external invariance pair.

### Rationale
Replay caching should reduce work without introducing hidden authority. The
cache must be a deterministic witness-bound optimization, not a separate state
oracle.

### Consequences
- replay projections are content-addressed and auditable.
- conformance enforces replay-cache binding semantics and invariance profiles.

---

## 2026-02-22 — Decision 0034: Promote NORMALIZER to draft and align Interop Full normative surface

### Decision
Promote `NORMALIZER` from raw to draft lifecycle and make all normative
Interop Full references point to `draft/NORMALIZER`.

Concretely:

- move `specs/premath/raw/NORMALIZER.md` to
  `specs/premath/draft/NORMALIZER.md`,
- set lifecycle frontmatter to `slug: draft` and `status: draft`,
- update cross-spec references from `raw/NORMALIZER` to `draft/NORMALIZER`,
- add `NORMALIZER.md` to the draft traceability matrix.

### Rationale
`NORMALIZER` is required for Interop Full claims and is already treated as a
normative dependency by `BIDIR-DESCENT`, capability vectors, and conformance
surfaces. Keeping it in raw status created lifecycle ambiguity and weakened
spec-index coherence.

### Consequences
- Interop Full normative scope is lifecycle-consistent.
- draft traceability now includes explicit coverage for `NORMALIZER.md`.
- raw-spec surface is reduced to genuinely non-promoted tracks.

---

## 2026-02-22 — Decision 0035: Add KCIR proposal refs as the canonical instruction/proposal boundary

### Decision
Extend instruction proposal ingestion so canonical proposal payloads produce a
deterministic KCIR ref and carry it through witness surfaces:

- add deterministic `proposalKcirRef` (`kcir1_*`) derivation in
  `tools/ci/instruction_proposal.py`,
- permit optional declared `proposalKcirRef` in proposal payloads and reject on
  mismatch (`proposal_kcir_ref_mismatch`),
- emit `proposalKcirRef` inside `proposalIngest` witness payloads from
  `tools/ci/run_instruction.py`,
- expose `proposal kcir ref` in instruction pipeline summaries,
- add instruction-typing adversarial vector
  `proposal_kcir_ref_mismatch_reject`.

### Rationale
`proposalDigest` alone is a local digest. The unification path needs one
portable IR boundary so instruction/proposal/coherence surfaces can reference
the same canonical proposal identity in a KCIR-compatible namespace.

### Consequences
- proposal witness lineage is now KCIR-addressable (`kcir1_*`).
- deterministic conformance coverage now rejects declared KCIR ref drift.
- docs now prefer `proposalKcirRef` as canonical external key while retaining
  `proposalDigest` for compatibility.

---

## 2026-02-22 — Decision 0036: Promote unification doctrine for minimum encoding and maximum expressiveness

### Decision
Add `draft/UNIFICATION-DOCTRINE` as a normative architecture doctrine surface
and link it from `SPEC-INDEX`, `draft/README`, and `SPEC-TRACEABILITY`.

Doctrine rule:

- one canonical encoding per authority boundary,
- deterministic expressive projections layered over that encoding.

### Rationale
Multiple ongoing threads (issue memory, instruction/proposal checking,
coherence, capability overlays) share the same reduction objective. A single
doctrine avoids local schema forks and keeps expressiveness in projections
instead of authority duplication.

### Consequences
- architectural coherence now has an explicit draft doctrine anchor.
- future reductions can be judged against a single canonical boundary rule.

---

## 2026-02-22 — Decision 0037: Deprecate ROADMAP as planning authority; issue graph + decision log are canonical

### Decision
Keep `specs/premath/raw/ROADMAP.md` as an informative orientation document,
but explicitly deprecate it as a source of active execution truth.

Canonical planning authority is now:

- `.premath/issues.jsonl` for active work graph/state,
- `specs/process/decision-log.md` for binding architectural/process decisions.

Add docs-coherence enforcement so `raw/ROADMAP` must contain explicit authority
markers pointing to those surfaces.

### Rationale
The roadmap phase sketch is useful context but drifts quickly. Active work
selection and ordering is already deterministic and queryable via the issue
graph. Binding intent is already captured in the decision log. Treating roadmap
text as execution authority duplicates state and reintroduces ambiguity.

### Consequences
- planning authority is now singular and machine-checkable.
- roadmap drift can no longer silently become a competing source of truth.

---

## 2026-02-22 — Decision 0038: Define raw capability-spec promotion policy and queue

### Decision
Define and publish lifecycle policy for optional capability-adjacent raw specs:
`raw/SQUEAK-SITE` and `raw/TUSK-CORE`.

Policy:

- raw capability specs may be exercised by executable vectors while still
  lifecycle-raw;
- capability claims bind only the capability-scoped normative clauses listed in
  `SPEC-INDEX` §5.4;
- promotion to draft requires deterministic vectors, deterministic
  witness/failure mappings, and an issue-backed migration plan with decision-log
  record.

Track promotion-prep as explicit issue queue:

- `bd-44` for `raw/SQUEAK-SITE`,
- `bd-45` for `raw/TUSK-CORE`.

### Rationale
Capability scope and lifecycle scope are different axes. We need explicit rules
that preserve expressive optionality while preventing accidental draft-level
authority from raw text drift.

### Consequences
- optional raw capability docs now have explicit retention/promotion criteria.
- promotion work is queryable as first-class issue graph state, not implicit
  intent.

---

## 2026-02-22 — Decision 0039: Adopt phased parity migration contract for Python adapters -> premath-coherence core

### Decision
Add a normative migration profile in `draft/PREMATH-COHERENCE` defining how
Python checker/gate surfaces move to `premath-coherence` core authority.

The profile fixes:

- authority boundary (Python as adapter only; no semantic duplication),
- parity contract keys (result, failure classes, binding fields, projection
  digests, proposal identity keys),
- phased cutover (`phase_0_inventory` -> `phase_4_deprecate_legacy`),
- rollback safety constraints (path switch only, witness-first fail-closed).

### Rationale
Without a concrete migration contract, the repo can drift into parallel
authoritative semantics between Python and Rust paths. The phased parity rule
keeps one authority boundary while preserving safe operational cutover.

### Consequences
- migration work for `bd-27`/`bd-34` now has explicit phase and parity targets.
- future cutovers can be judged by deterministic witness parity rather than
  narrative equivalence.

---

## 2026-02-22 — Decision 0040: Keep SQUEAK-SITE lifecycle-raw with explicit law/vector mapping

### Decision
Retain `raw/SQUEAK-SITE` in raw lifecycle state (do not promote to draft yet),
while tightening capability-scoped law coverage:

- add explicit adversarial vector for `site_glue_missing`,
- publish explicit law-boundary -> vector mapping inside `raw/SQUEAK-SITE`,
- keep `capabilities.squeak_site` normative scope bound to claimed clauses and
  executable vectors.

### Rationale
Squeak runtime-location contracts are still an active operational design surface
across local/external runner profiles. Promotion now would freeze a surface that
is still being normalized. We can preserve determinism and safety by tightening
vector-mapped capability boundaries while keeping the full spec lifecycle-raw.

### Consequences
- all currently declared site-class reject outcomes are now explicitly mapped to
  executable vectors (`site_overlap_mismatch`, `site_glue_missing`,
  `site_glue_non_contractible`).
- lifecycle authority remains coherent: capability clauses are executable and
  claim-bound, while full-document evolution remains open until promotion
  criteria are met.

---

## 2026-02-22 — Decision 0041: Keep TUSK-CORE lifecycle-raw with explicit runtime vector mapping

### Decision
Retain `raw/TUSK-CORE` in raw lifecycle state (do not promote to draft yet),
while tightening deterministic boundary evidence through a dedicated fixture
suite:

- add executable `tusk-core` conformance vectors run via
  `tools/conformance/run_tusk_core_vectors.py`,
- wire `tusk-core` into cached `conformance-run` suite execution,
- map `raw/TUSK-CORE` runtime boundary clauses to explicit vector IDs and
  Gate-class/law-ref outcomes.

### Rationale
`tusk-core` remains an active runtime contract surface with ongoing profile and
execution-shape iteration. Promotion now would freeze a boundary still under
active operational refinement. We can preserve deterministic authority by
binding runtime failure-class semantics to explicit vectors while keeping full
document lifecycle-raw.

### Consequences
- required mapping paths in `raw/TUSK-CORE` (§5.2/§8) now have executable
  vector evidence across accepted, locality, descent, and glue-contractibility
  outcomes.
- lifecycle authority remains coherent: contract text can iterate, while
  failure mapping behavior is pinned by deterministic vectors and merge gates.

---

## 2026-02-22 — Decision 0042: Unify proposal identity validation through one KCIR-bound authority path

### Decision
Complete the next `bd-31` unification slice by enforcing one shared proposal
identity validator and documenting the explicit KCIR boundary profile:

- add `validate_proposal_payload(...)` in `tools/ci/instruction_proposal.py` as
  the single validator for canonical proposal payload + declared
  `proposalDigest`/`proposalKcirRef` checks,
- route capability vector proposal checks through that shared validator (remove
  duplicated in-file declared-ref validation),
- publish explicit KCIR proposal projection mapping and deprecation rule in
  `draft/UNIFICATION-DOCTRINE` and `draft/LLM-PROPOSAL-CHECKING`,
- add dedicated unit tests for proposal validator behavior and include them in
  `ci-pipeline-test`.

### Rationale
Duplicate proposal identity validation logic across CI and conformance surfaces
creates unnecessary degrees of freedom and drift risk. A single validation path
keeps minimum encoding at the authority boundary while preserving expressive
projections.

### Consequences
- proposal identity checks now have one authoritative implementation path
  reused by instruction and conformance surfaces.
- KCIR proposal projection shape is explicit and portable (`kcir.proposal.v1`).
- migration away from duplicate proposal identity encodings is now concrete and
  test-gated.

---

## 2026-02-22 — Decision 0043: Route instruction proposal discharge through core-backed CLI checker path

### Decision
Advance `bd-34` migration execution by moving instruction proposal semantic
evaluation off Python-local kernels and onto a core-backed CLI path:

- add `premath proposal-check --proposal <proposal.json> --json`,
- implement proposal canonicalization/digest/KCIR ref checks and deterministic
  obligation compile/discharge in `premath-coherence`,
- update `tools/ci/run_instruction.py` to delegate proposal ingest checks to the
  new CLI command (Python remains orchestration/witness shaping wrapper).

### Rationale
`run_instruction.py` previously executed proposal semantic kernels directly in
Python (`compile_proposal_obligations`/`discharge_proposal_obligations`), which
left a parallel authority path during migration. This step reduces that degree
of freedom by shifting the live instruction gate path to the core-backed
checker surface.

### Consequences
- instruction gate execution now uses core-backed proposal checking semantics.
- Python keeps policy/env orchestration responsibility but no longer owns
  proposal discharge semantics on the authoritative instruction path.
- migration work for `bd-34` is now in-progress with one concrete cutover lane
  completed; remaining parity migration surfaces still need consolidation.

---

## 2026-02-22 — Decision 0044: Run coherence-contract checks through cached conformance fixture-suite surface

### Decision
Add `coherence-contract` as a first-class suite in
`tools/conformance/run_fixture_suites.py`, executed by the authoritative
command:

- `premath coherence-check --contract specs/premath/draft/COHERENCE-CONTRACT.json --repo-root . --json`

and bind cache materialization to:

- `draft/COHERENCE-CONTRACT.json`,
- `tests/conformance/fixtures/coherence-transport`,
- `crates/premath-coherence/src`,
- CLI coherence command wrapper source.

### Rationale
`coherence-check` existed as a standalone baseline gate but not as part of the
shared cached fixture-suite execution surface. This left a duplicate execution
shape for conformance-style determinism and slowed repeated runs. Routing it
through the same cache scheme reduces degrees of freedom while preserving one
semantic authority path.

### Consequences
- coherence transport obligations are now executed on the same KCIR-style cache
  substrate as other executable fixture suites.
- repeated coherence-contract runs can short-circuit on deterministic cache
  hits.
- docs/fixture entrypoints now expose `coherence-contract` as a first-class
  executable suite in the conformance surface.

---

## 2026-02-22 — Decision 0045: Add raw site/sheaf/torsor semantics lane with foundations companion

### Decision
Add a new informational semantics lane for site/topos abstractions:

- `raw/CTX-SITE`
- `raw/SHEAF-STACK`
- `raw/TORSOR-EXT`

and add a foundations companion note:

- `docs/foundations/SITE-AND-TORSOR-NOTES.md`

without changing checker authority or conformance claims.

### Rationale
We need a compact expression of base/fibre, coverage, descent, and extension
ideas to guide coherence evolution, but we do not want to recreate Premath as a
parallel architecture. This lane provides semantic compression while preserving
the existing acceptance boundary (`checker -> obligations -> discharge ->
witness`).

### Consequences
- site/sheaf/stack/torsor vocabulary is now available as a shared design
  language for future coherence obligations.
- no new normative claim is introduced; all additions are lifecycle-raw or
  foundations notes.
- `draft/SPEC-INDEX` and `raw/README` now reference this lane explicitly so the
  abstraction path remains discoverable and coherent.

---

## 2026-02-22 — Decision 0046: Add site-coverage and glue-or-witness obligations to coherence-contract checker

### Decision
Extend `draft/COHERENCE-CONTRACT.json` and `premath-coherence` with three new
required obligations:

- `coverage_base_change`
- `coverage_transitivity`
- `glue_or_witness_contractibility`

backed by executable vectors under `tests/conformance/fixtures/coherence-site`.

### Rationale
Transport functoriality alone does not cover the full site/descent contract.
We need deterministic checks for cover pullback stability, cover transitivity,
and explicit glue-or-obstruction outcomes to keep the checker aligned with the
site/sheaf abstractions while preserving one acceptance authority path.

### Consequences
- coherence checker now enforces site-level coverage and descent outcome
  invariants in addition to transport law.
- cached `conformance-run` coherence-contract suite now depends on
  `coherence-site` fixtures for deterministic cache invalidation and replay.
- no new authority layer is introduced; all outcomes still flow through
  `premath coherence-check` witness emission.

---

## 2026-02-22 — Decision 0047: Kernel-own obligation->Gate authority registry with machine export

### Decision
Move canonical obligation->Gate mapping authority into `premath-kernel` and
export it as one typed registry surface:

- source authority: `crates/premath-kernel/src/obligation_registry.rs`
- Rust APIs: `obligation_to_failure_class`, `failure_class_to_law_ref`,
  `obligation_gate_registry`, `obligation_gate_registry_json`
- machine export command: `premath obligation-registry --json`

Downstream checker paths consume this authority instead of local duplicated
mapping constants.

### Rationale
The mapping is normative (`draft/BIDIR-DESCENT` §8.1 + `draft/GATE` class/law
surface) and should not live in a downstream checker implementation file. A
kernel-owned export reduces duplication and keeps the semantic boundary
single-source.

### Consequences
- proposal discharge in `premath-coherence` now imports kernel mapping APIs.
- coherence contract parity surface now points to kernel registry source for
  obligation-vocabulary checks.
- CLI/automation can consume one deterministic JSON registry artifact for
  cross-surface parity work (`bd-58`, `bd-59`, `bd-63`).

---

## 2026-02-22 — Decision 0048: Introduce shared CONTROL-PLANE-CONTRACT artifact for projection parity

### Decision
Add `draft/CONTROL-PLANE-CONTRACT.json` as a shared typed control-plane
artifact and wire two independent surfaces to consume it:

- CI projection engine (`tools/ci/change_projection.py`) now loads
  `projectionPolicy` + `checkIds` + `checkOrder` from this contract.
- Coherence gate-chain parity (`premath coherence-check`) now compares CI
  closure projected checks against the contract’s `requiredGateProjection`
  section instead of parsing Python source constants.

### Rationale
Control-plane constants (projection policy/check order) were duplicated in code
and checked by source scraping. Moving them to one typed artifact reduces
encoding duplication and establishes a common contract consumed by both CI
execution and coherence checking.

### Consequences
- `COHERENCE-CONTRACT` now references `controlPlaneContractPath` as the
  projection authority input.
- docs coherence checker now validates CI closure projected checks against
  `CONTROL-PLANE-CONTRACT` instead of `CHECK_ORDER` source parsing.
- this is the first `bd-63` slice; remaining scope includes migrating
  additional control-plane constants (witness class/binding keys and related
  roundtrip conformance vectors) onto the same contract artifact.

---

## 2026-02-22 — Decision 0049: Split CI witness failure lineage into operational vs semantic classes

### Decision
Adopt a typed failure-lineage split for CI witness summaries:

- `operationalFailureClasses`: control-plane execution classes.
- `semanticFailureClasses`: semantic lineage classes derived from Gate/proposal
  surfaces when available.
- `failureClasses`: deterministic set-union compatibility field.

Apply this split to `ci.required` and `ci.instruction` witnesses, and enforce
deterministic mapping in `verify_required_witness_payload` (used by both
`ci-verify-required` and `ci-decide-required`).

### Rationale
The prior single `failureClasses` surface collapsed operational and semantic
causes. That made CI decision surfaces less informative and weakened semantic
lineage preservation across kernel/coherence/CI boundaries.

### Consequences
- `ci.required` now carries semantic classes threaded from linked gate witness
  payloads (`gateWitnessRefs[].failureClasses`) while preserving operational
  `check_failed` classification.
- `ci.instruction` now separates pre-execution/control-plane failures from
  proposal-discharge semantic failures, while preserving the union field for
  compatibility.
- verification/decision paths now reject lineage-shape mismatches instead of
  accepting collapsed failure-class summaries when semantic lineage is present.

---

## 2026-02-22 — Decision 0050: Make capability parity generation-first via typed registry artifact

### Decision
Introduce `draft/CAPABILITY-REGISTRY.json` as the canonical typed executable
capability registry and consume it across parity surfaces:

- `tools/conformance/run_capability_vectors.py` default capability selection,
- `tools/conformance/check_docs_coherence.py` docs parity checks,
- `premath coherence-check` (`capability_parity` obligation).

Also replace coherence bidirectional checker source parsing with kernel-owned
typed obligation registry APIs (`obligation_gate_registry`,
`obligation_gate_registry_json`).

### Rationale
Capability and obligation parity checks still depended on language-specific
source scraping (`DEFAULT_EXECUTABLE_CAPABILITIES` tuple and map parsing).
That made parity fragile and duplicated authority across implementation files.
Typed registry artifacts/API exports preserve one authority path and reduce
hidden drift.

### Consequences
- capability parity now binds to a machine artifact (`CAPABILITY-REGISTRY.json`)
  instead of source constants.
- conformance/docs/coherence surfaces now share the same executable capability
  authority input.
- coherence scope checks now bind to kernel registry kind + obligation set via
  typed API export rather than parsing source text maps.

---

## 2026-02-22 — Decision 0051: Add machine branch-policy contract and live ruleset checker

### Decision
Introduce a tracked process policy artifact and checker for server-side GitHub
enforcement on `main`:

- policy artifact: `specs/process/GITHUB-BRANCH-POLICY.json`
- checker: `tools/ci/check_branch_policy.py`
  - fixture mode: `--rules-json ...` (deterministic local/CI parser check)
  - live mode: `--fetch-live` against
    `/repos/{owner}/{repo}/rules/branches/{branch}`
- baseline task integration (fixture mode):
  `mise run ci-branch-policy-check`
- manual live governance workflow:
  `.github/workflows/branch-policy.yml`

### Rationale
The repository observed remote push acceptance with bypass messaging despite
local `ci-required-attested` success. This indicates branch/ruleset authority
must be checked at the server surface, not inferred from local gate execution.

### Consequences
- branch-protection/ruleset shape now has a tracked policy contract in-repo.
- parser/contract drift is covered by deterministic test + fixture surfaces.
- live server checks are available as a first-class workflow with explicit
  admin-read token requirement (`PREMATH_BRANCH_POLICY_TOKEN`).
- governance hardening remains fail-closed on bypass actors under the tracked
  policy.

---

## 2026-02-22 — Decision 0052: Make doctrine-site mapping generation-first with typed source + operation registry

### Decision
Adopt a generation-first doctrine-site contract flow:

- add `draft/DOCTRINE-SITE-SOURCE.json` as the non-operation topology source,
- add `draft/DOCTRINE-OP-REGISTRY.json` as operation-node + CI-edge registry,
- generate `draft/DOCTRINE-SITE.json` deterministically from:
  - source topology,
  - operation registry,
  - declaration-bearing spec sections (`Doctrine Preservation Declaration (v0)`).

Require doctrine-site checker roundtrip parity (`generated == tracked`) in
addition to existing morphism/declaration/reachability checks.

### Rationale
`DOCTRINE-SITE.json` previously duplicated declaration sets directly, creating a
hand-maintained drift surface. Generation-first removes duplicate encoding,
keeps operation ancestry auditable, and preserves one canonical projection path.

### Consequences
- doctrine-site authority now has three explicit artifacts:
  `DOCTRINE-SITE-SOURCE.json` + `DOCTRINE-OP-REGISTRY.json` ->
  `DOCTRINE-SITE.json`.
- `tools/conformance/check_doctrine_site.py` now enforces roundtrip drift
  rejection and points to the generator for repair.
- new helper/generator/test surfaces:
  - `tools/conformance/doctrine_site_contract.py`
  - `tools/conformance/generate_doctrine_site.py`
  - `tools/conformance/test_doctrine_site_contract.py`

---

## 2026-02-22 — Decision 0053: Add boundary-authority invariance vectors across kernel/coherence/CI witness surfaces

### Decision
Extend `capabilities.ci_witnesses` executable vectors with a boundary-authority
lineage slice that validates one shared authority chain:

- kernel obligation registry mapping (`obligationKind -> failureClass`),
- proposal discharge failed-obligation classes,
- coherence scope registry kind + bidir obligation surface,
- CI witness semantic failure lineage (`semanticFailureClasses` plus union shape).

Add adversarial vectors for:

- obligation-registry mapping mismatch,
- stale generated doctrine-site digest material.

Add paired local/external invariance vectors for the same boundary-authority
scenario.

### Rationale
`bd-61` requires proving that authority mappings remain invariant across the
kernel/coherence/CI projection boundary, not just inside one witness format.
This closes the remaining parity gap after typed registry and generation-first
surfaces were introduced (`bd-57`, `bd-58`, `bd-59`, `bd-60`, `bd-63`).

### Consequences
- `tools/conformance/run_capability_vectors.py` now includes boundary-authority
  lineage validation in the `capabilities.ci_witnesses` evaluator.
- `tests/conformance/fixtures/capabilities/capabilities.ci_witnesses/` now
  contains:
  - `golden/boundary_authority_lineage_accept`,
  - `adversarial/boundary_authority_registry_mismatch_reject`,
  - `adversarial/boundary_authority_stale_generated_reject`,
  - `invariance/same_boundary_authority_local`,
  - `invariance/same_boundary_authority_external`.
- capability/conformance docs now explicitly require boundary-authority lineage
  parity and stale generated doctrine-site rejection under
  `capabilities.ci_witnesses`.

---

## 2026-02-22 — Decision 0054: Bind Interop ref vectors to a real profile-backed verifier surface

### Decision
Adopt a first-class reference profile artifact and route Interop ref vectors
through the canonical CLI verifier surface:

- add `policies/ref/sha256_detached_v1.json` as profile kind
  `premath.ref_profile.v1`,
- add `premath ref project` and `premath ref verify` commands in
  `premath-cli`,
- execute `interop-core` ref projection/verification vectors by invoking those
  CLI commands (not a Python-local digest shim),
- pin fixture refs to the profile fields
  (`schemeId=ref.sha256.detached.v1`,
  `paramsHash=sha256.detached.params.v1`).

### Rationale
`bd-36` requires "at least one real backend profile + reference verifier
implementation" for M1 coherence. The previous interop runner validated ref
logic using a Python simulation; that validated behavior but left the canonical
command surface unexercised. Binding vectors to the CLI closes that boundary and
reduces duplicate encoding.

### Consequences
- `project_ref`/`verify_ref` now have one typed implementation path in
  `premath-cli` with deterministic rejection classes.
- interop ref vectors now test the same command surface users and CI consume.
- CLI smoke coverage includes `ref project` and `ref verify` JSON surfaces.
- M1 reference verifier milestone criteria are satisfied at command surface +
  conformance levels.

---

## 2026-02-22 — Decision 0055: Retire legacy Python instruction-policy shim authority

### Decision
Remove `tools/ci/instruction_policy.py` and its dedicated unit surface
`tools/ci/test_instruction_policy.py`.

Keep instruction policy/allowlist/binding authority exclusively on the core
`premath instruction-check` path consumed via:

- `tools/ci/instruction_check_client.py`,
- `tools/ci/run_instruction.py`,
- `tools/ci/test_instruction_reject_witness.py`.

Update pipeline and traceability surfaces to reference core-backed tests only.

### Rationale
The Python instruction-policy module had become an unreferenced duplicate
semantic surface after instruction envelope validation moved into
`premath-coherence` and `premath-cli`. Keeping it introduced avoidable encoding
drift risk.

### Consequences
- `mise run ci-pipeline-test` no longer executes `test_instruction_policy.py`.
- traceability for `draft/LLM-PROPOSAL-CHECKING` now points to
  `test_instruction_check_client.py` + `test_instruction_reject_witness.py`.
- instruction policy semantics remain single-path and checker-owned.

---

## 2026-02-22 — Decision 0056: Add CwF strict presentation obligations to coherence-check

### Decision
Extend `premath coherence-check` and `draft/COHERENCE-CONTRACT.json` with four
strict CwF obligations:

- `cwf_substitution_identity`
- `cwf_substitution_composition`
- `cwf_comprehension_beta`
- `cwf_comprehension_eta`

Bind them to executable vectors under
`tests/conformance/fixtures/coherence-site/` and evaluate them through the same
deterministic site-obligation runner already used for cover/glue obligations.

### Rationale
Premath already separates semantic `≈` (kernel/fibration/site) from operational
`≡` surfaces used by deterministic CI/witness pipelines. CwF laws provide the
minimal strict substitution/comprehension contract needed at that operational
boundary without redefining kernel semantic authority.

### Consequences
- coherence contract required-obligation set grows by four CwF IDs.
- coherence-site fixture manifest now includes golden/adversarial vectors for
  strict substitution identity/composition and comprehension beta/eta.
- `draft/PREMATH-COHERENCE` now specifies CwF strictification obligations
  explicitly.

---

## 2026-02-22 — Decision 0057: Make instruction digest checker-authoritative on the instruction path

### Decision
Extend `premath instruction-check` output with canonical
`instructionDigest` (`instr1_<sha256(canonical-json)>`) and consume that value
directly in `tools/ci/run_instruction.py` when building instruction witnesses.

Keep Python wrappers as transport adapters only:

- no Python-side canonical digest recomputation on accepted instruction paths,
- stale local binary payload-shape drift is auto-healed by retrying through
  `cargo run --package premath-cli -- instruction-check ...`.

### Rationale
`bd-34` targets one authority path for checker semantics. Instruction digest
computation duplicated in Python was an avoidable parallel encoding surface.
Moving digest authority to core reduces drift risk and tightens deterministic
lineage from envelope check to witness emission.

### Consequences
- `ValidatedInstructionEnvelope` now includes `instructionDigest`.
- `run_instruction.py` now uses core-emitted digest for witness runtime payloads
  on accepted envelopes.
- `instruction_check_client.py` validates presence of `instructionDigest` and
  retries through cargo when a stale local binary emits older payload shape.
- instruction-path smoke and client/unit tests cover this fallback behavior.

---

## 2026-02-22 — Decision 0058: Move ci.required witness assembly to core `premath required-witness`

### Decision
Add a core `required-witness` command path and route
`tools/ci/run_required_checks.py` witness assembly through it.

This introduces:

- `premath-coherence` required witness runtime/output types and deterministic
  lineage assembly (`verdictClass`, operational/semantic failure unions),
- `premath-cli required-witness --runtime <json> --json`,
- `tools/ci/required_witness_client.py` as a thin transport adapter with
  stale-local-binary fallback to cargo.

### Rationale
`bd-34` requires reducing Python semantic authority in gate/check pipelines.
`run_required_checks.py` previously built `ci.required.v1` witness semantics
locally; that duplicated authority with the checker layer. Moving witness
assembly to core keeps wrappers transport-only and reduces drift risk.

### Consequences
- `run_required_checks.py` now sends runtime payload to core and consumes one
  authoritative `ci.required.v1` witness JSON output.
- CI pipeline test surface now includes dedicated required-witness client tests.
- CLI smoke coverage now includes `required-witness` JSON command surface.

---

## 2026-02-22 — Decision 0059: Move ci.required verification semantics to core `premath required-witness-verify`

### Decision
Add a core required witness verification path:

- `premath-coherence` now exposes deterministic required witness verification
  (`verify_required_witness_payload`) including projection parity, gate witness
  linkage integrity, native-required source constraints, and failure-lineage
  union checks.
- `premath-cli` adds `required-witness-verify --input <json> --json`.
- Python verifier helpers now delegate to core through
  `tools/ci/required_witness_verify_client.py` and keep filesystem loading as
  adapter-only behavior.

### Rationale
`bd-34` aims to remove Python-local checker authority from required/instruction
gate paths. Required witness validation previously lived in
`tools/ci/required_witness.py`, creating a parallel semantic surface.

### Consequences
- `tools/ci/required_witness.py` is now a thin adapter that forwards
  `{witness, changedPaths, nativeRequiredChecks, gateWitnessPayloads}` to core.
- `verify_required_witness.py` keeps orchestration but semantic verdicts come
  from core output (`errors`, `derived`).
- pipeline and CLI smoke surfaces now include
  `required-witness-verify` client/command tests.

---

## 2026-02-22 — Decision 0060: Move Delta→requiredChecks projection semantics to core `premath required-projection`

### Decision
Make required-check projection (`changedPaths -> requiredChecks + reasons +
projectionDigest`) core-owned:

- add `premath-coherence` projection evaluator
  (`project_required_checks`, `normalize_projection_paths`) with deterministic
  result shape,
- add `premath-cli required-projection --input <json> --json`,
- route `tools/ci/change_projection.py` projection evaluation through
  `tools/ci/required_projection_client.py` and keep Python-side logic limited to
  git delta discovery + wrapper orchestration.

Also bind required-witness verification to the same projection authority by
reusing `required_projection` logic inside `required_verify`.

### Rationale
`bd-34` requires one semantic authority path for CI gate projection surfaces.
Projection logic previously lived in Python (`change_projection.py`) and was
duplicated in core verification code. Moving this boundary to core removes
parallel encodings and reduces drift risk across run/verify/decide paths.

### Consequences
- `run_required_checks.py`, `verify_required_witness.py`,
  `decide_required.py`, and capability/conformance helpers now consume projection
  semantics through the core command/client path.
- `required_verify` and runtime projection now share one core implementation.
- pipeline and CLI smoke surfaces now include required-projection client/command
  tests.

---

## 2026-02-22 — Decision 0061: Move git/workspace delta detection to core `premath required-delta`

### Decision
Make changed-path detection (`repoRoot + optional fromRef/toRef -> {changedPaths,
source, fromRef, toRef}`) core-owned:

- add `premath-cli required-delta --input <delta_input.json> --json`,
- route `tools/ci/change_projection.py` delta detection through
  `tools/ci/required_delta_client.py`,
- keep Python wrappers as adapter-only orchestration surfaces.

### Rationale
`bd-34` targets one checker-owned semantic authority path for required-gate
planning. After Decision 0060, Python still owned git/workspace delta detection
rules; that left a second semantic boundary outside core command surfaces.
Moving this path into `premath-cli` reduces drift risk and aligns run/verify/
decide consumers on the same deterministic delta semantics.

### Consequences
- `change_projection.py` no longer embeds git ref fallback/source classification
  logic.
- required-gate pipeline tests now include `test_required_delta_client.py`.
- CLI smoke coverage now includes `required-delta` against a temporary git repo
  fixture.

---

## 2026-02-22 — Decision 0062: Move required decision attestation verification to core `premath required-decision-verify`

### Decision
Move decision-chain verification semantics (`decision + witness + delta +
actual digest bindings`) into core:

- add `premath-coherence` verifier
  (`verify_required_decision_request`),
- add `premath-cli required-decision-verify --input <json> --json`,
- route `tools/ci/verify_decision.py` through
  `tools/ci/required_decision_verify_client.py` and keep Python path as
  filesystem/path transport only.

### Rationale
After projection/delta/witness/verify/decide migrations, `verify_decision.py`
still carried cross-artifact semantic checks. This kept a second decision
authority surface in Python. Moving those checks into core keeps attestation
semantics checker-authoritative and reduces wrapper drift risk.

### Consequences
- decision-chain semantic checks now execute through one core command surface.
- pipeline tests include `test_required_decision_verify_client.py`.
- CLI smoke coverage includes `required-decision-verify`.

---

## 2026-02-22 — Decision 0063: Move required gate-ref and fallback payload synthesis to core `premath required-gate-ref`

### Decision
Move per-check gate reference assembly and fallback gate payload synthesis into
core semantics:

- add `premath-coherence` gate-ref builder (`build_required_gate_ref`),
- add `premath-cli required-gate-ref --input <json> --json`,
- route `tools/ci/run_required_checks.py` native/fallback gate ref assembly
  through `tools/ci/required_gate_ref_client.py`,
- route `tools/ci/emit_gate_witness.py` fallback envelope emission through the
  same core command surface.

### Rationale
`run_required_checks.py` previously owned semantic pieces of gate lineage
assembly (`sha256` projection, failure-class extraction, fallback envelope
materialization). That left a parallel authority path outside core checker
surfaces. This decision keeps wrappers in transport mode and makes gate-ref
lineage deterministic under one command surface.

### Consequences
- required-gate runtime wrappers no longer compute gate ref semantics locally.
- pipeline tests include `test_required_gate_ref_client.py`.
- CLI smoke coverage includes `required-gate-ref`.

---

## 2026-02-22 — Decision 0064: Deduplicate required client transport into shared `core_cli_client`

### Decision
Consolidate repeated Python wrapper transport behavior for required gate command
clients into one helper module:

- add `tools/ci/core_cli_client.py`,
- centralize premath binary resolution, temp JSON input handoff, stale local
  binary retry-to-cargo, deterministic failure-class extraction, and JSON
  decode/retry handling,
- keep per-client payload-shape validation local in each
  `required_*_client.py`.

### Rationale
After moving required gate semantics into core commands, wrappers still carried
duplicated transport code across seven client modules. That duplication
increased drift risk without adding semantic expressiveness. Centralizing
transport keeps wrappers thinner while preserving command-specific validation.

### Consequences
- `required_*_client.py` modules now encode only command metadata and payload
  shape validation.
- behavior parity remains covered by existing required-client tests and
  `ci-pipeline-test`.

---

## 2026-02-22 — Decision 0065: Route proposal-check Python client through shared core transport

### Decision
Adopt `tools/ci/core_cli_client.py` in
`tools/ci/proposal_check_client.py` and keep only proposal payload validation
plus proposal-specific failure-class mapping in the proposal client.

### Rationale
After Decision 0064, `proposal_check_client.py` still carried duplicate command
transport behavior. Reusing the shared helper removes another parallel wrapper
surface while keeping proposal-domain error semantics explicit.

### Consequences
- `proposal_check_client.py` now shares command transport behavior with
  required-gate clients.
- proposal-specific validation classes remain stable
  (`proposal_nondeterministic`, `proposal_kcir_ref_mismatch`,
  `proposal_invalid_step`).

---

## 2026-02-22 — Decision 0066: Route instruction-check/instruction-witness clients through shared core transport

### Decision
Adopt `tools/ci/core_cli_client.py` transport helpers in
`tools/ci/instruction_check_client.py` for both:

- `instruction-check` (path-input command),
- `instruction-witness` (runtime payload-input command with optional
  pre-execution flags).

Extend shared transport helpers with:

- path-input execution mode (`run_core_json_command_from_path`),
- optional extra command args,
- explicit invalid-json failure-class override.

### Rationale
Instruction clients still carried duplicated command transport logic after
Decision 0064/0065. Moving them onto the shared helper removes another
wrapper-level authority duplicate while preserving instruction-domain failure
classes.

### Consequences
- instruction client wrappers now follow the same minimum-encoding transport
  surface as required/proposal wrappers.
- `instruction_envelope_invalid_shape` remains the parse/shape failure class for
  instruction-check payload decoding failures.

---

## 2026-02-22 — Decision 0067: Enforce CI client transport parity with executable tests

### Decision
Add deterministic parity enforcement for CI command wrapper transport surfaces:

- introduce `tools/ci/test_client_transport_parity.py`,
- require required/proposal/instruction clients to import and use
  `tools/ci/core_cli_client.py`,
- ban reintroduction of local transport loops in those clients
  (tempfile command loops, inline stale-subcommand handling),
- include this test in `mise run ci-pipeline-test`.

### Rationale
After transport consolidation, parity needed an executable guard so wrapper
surfaces could not silently regress to duplicated local transport behavior.

### Consequences
- command-wrapper reduction has a concrete, merge-gated invariant.
- bd-33 parity scope now includes wrapper transport surface checks, not only
  docs/spec-level coherence.

---

## 2026-02-22 — Decision 0068: Add PREMATH-COHERENCE obligation-set parity to scope checker

### Decision
Extend `scope_noncontradiction` in `premath-coherence` to enforce parity between:

- required coherence obligation IDs implemented by the checker, and
- obligation IDs listed in `draft/PREMATH-COHERENCE` §3.

Add explicit contract surface bindings for the PREMATH-COHERENCE obligation
section bounds (`coherenceSpecPath`, `coherenceSpecObligationStart`,
`coherenceSpecObligationEnd`) and fail with deterministic classes when drift is
detected (`coherence_spec_missing_obligation`,
`coherence_spec_unknown_obligation`).

### Rationale
The checker already enforced parity between BIDIR obligation vocabulary and
kernel registry exports, but the coherence-obligation normative list itself was
not executable. This created a doc/runtime drift gap in the same obligation
family.

### Consequences
- coherence checker now guards PREMATH-COHERENCE §3 as an executable parity
  surface.
- contract surfaces explicitly bind both BIDIR and PREMATH-COHERENCE obligation
  sections.
- bd-33 parity coverage includes required coherence obligation vocabulary drift.

---

## 2026-02-22 — Decision 0069: Add end-to-end CLI rejection witness for coherence obligation drift

### Decision
Add a `premath-cli` smoke test that mutates `PREMATH-COHERENCE` §3 obligation
IDs via a temporary coherence contract binding and asserts `coherence-check`
returns a rejected witness with deterministic drift classes:

- `coherence.scope_noncontradiction.coherence_spec_missing_obligation`
- `coherence.scope_noncontradiction.coherence_spec_unknown_obligation`

### Rationale
Decision 0068 added checker-level parity enforcement and unit coverage, but the
CLI surface did not yet prove this drift path end-to-end. The smoke test closes
that boundary by validating witness behavior through the canonical command
surface.

### Consequences
- coherence obligation-list drift is now covered at both checker unit and CLI
  witness layers.
- bd-33 parity scope gains executable E2E regression protection for this drift
  class.

---

## 2026-02-22 — Decision 0070: Close coherence-contract cache bindings over contract-declared surfaces

### Decision
Update `tools/conformance/run_fixture_suites.py` so the `coherence-contract`
suite cache-input closure is derived from `draft/COHERENCE-CONTRACT.json`:

- include all `surfaces.*Path` and `surfaces.*Root` entries,
- include top-level `expectedOperationPaths[]`,
- keep baseline fallback inputs for deterministic behavior if contract parsing
  fails.

Add `tools/conformance/test_run_fixture_suites.py` and gate it in
`ci-pipeline-test`.

### Rationale
The prior cache binding for `coherence-contract` omitted several files read by
`coherence-check` (for example `PREMATH-COHERENCE`, `SPEC-INDEX`, capability
manifests, and operation paths). That allowed stale cache hits when those
surfaces changed.

### Consequences
- conformance cache validity for `coherence-contract` now tracks the full
  checker-read surface declared by contract.
- cache hits cannot bypass coherence-check execution after relevant doc/surface
  edits.

---

## 2026-02-22 — Decision 0071: Add cache-ref drift proof for coherence-spec changes

### Decision
Add a deterministic unit test in
`tools/conformance/test_run_fixture_suites.py` proving
`coherence-contract` suite cache refs drift when
`PREMATH-COHERENCE` content changes.

The test:

- uses the real `coherence-contract` suite input closure,
- swaps only the coherence-spec input path with a mutated temporary copy,
- asserts `params_hash` stays constant while `material_digest` and `cache_ref`
  both change.

### Rationale
Decision 0070 closed cache input coverage, but we still needed an executable
proof that the suite plan actually responds to edits on a contract-declared doc
surface and cannot produce stale cache hits.

### Consequences
- cache drift on coherence-spec edits is now explicitly regression-tested.
- `bd-33` gains stronger cache correctness evidence without expanding command
  surface.

---

## 2026-02-22 — Decision 0072: Add overlayDocs-derived files to coherence cache input closure

### Decision
Extend `load_coherence_contract_input_paths()` so `coherence-contract` cache
inputs include overlay markdown files derived from contract `overlayDocs`:

- each `overlayDocs` entry `x` maps to `specs/premath/{x}.md`.

Add unit coverage asserting inclusion of
`specs/premath/profile/ADJOINTS-AND-SITES.md`.

### Rationale
`coherence-check` evaluates overlay file existence in
`overlay_traceability`, but prior cache-input closure did not include those
derived file paths. That could allow stale cache hits when overlay files drift.

### Consequences
- coherence-contract cache bindings now include overlay file surfaces read by
  checker semantics.
- cache hits remain invalidated when overlay docs change or disappear.

---

## 2026-02-22 — Decision 0073: Bind coherence-contract cache inputs to kernel obligation authority source

### Decision
Extend `load_coherence_contract_input_paths()` to include:

- `crates/premath-kernel/src`

for the `coherence-contract` suite cache-input closure.

### Rationale
`coherence-check` consumes kernel obligation registry authority from
`premath-kernel`. Without binding kernel source into the suite cache plan,
changes to obligation authority could be skipped by stale conformance cache
hits.

### Consequences
- coherence-contract cache refs now drift when kernel obligation authority
  source changes.
- cache validity aligns with checker authority dependencies across
  kernel/coherence layers.

---

## 2026-02-22 — Decision 0074: Bind coherence-contract cache inputs to Cargo manifests

### Decision
Extend `load_coherence_contract_input_paths()` to include repository Cargo
manifests:

- `Cargo.toml`
- `Cargo.lock`

for `coherence-contract` suite cache-input closure.

### Rationale
`coherence-check` behavior can drift when dependency graph or crate feature
resolution changes. Without Cargo manifests in cache bindings, those changes
could be skipped by stale conformance cache hits.

### Consequences
- coherence-contract cache refs now invalidate on workspace dependency/feature
  changes.
- cache validity remains aligned with executable checker runtime composition.

---

## 2026-02-22 — Decision 0075: Introduce span/square commutation obligation and draft spec

### Decision
Add a first-class coherence obligation for typed span/square commutation:

- new required obligation id: `span_square_commutation`,
- new draft spec: `draft/SPAN-SQUARE-CHECKING`,
- new coherence-site vectors:
  - `golden/span_square_commutation_accept`
  - `adversarial/span_square_commutation_reject`.

Implement checker hook in `premath-coherence` via site-obligation evaluator
`evaluate_site_case_span_square_commutation`.

### Rationale
Pipeline/base-change witness squares were previously implicit across checker and
CI surfaces. Adding a minimal span/square typed layer makes this boundary
explicit without introducing a parallel authority surface.

### Consequences
- span/square commutation is now merge-gated under `coherence-check`.
- the new typed layer is integrated across spec index, unification doctrine,
  traceability matrix, and executable fixtures.

---

## 2026-02-22 — Decision 0076: Tighten span/square vectors with invariance and digest-mismatch adversarial coverage

### Decision
Extend `coherence-site` vectors for `span_square_commutation` with:

- invariance case:
  - `invariance/span_square_commutation_permuted_accept`
- adversarial digest mismatch case:
  - `adversarial/span_square_commutation_digest_mismatch_reject`.

### Rationale
Initial span/square vectors proved baseline accept/reject behavior. Additional
coverage closes two important boundaries:

- permutation invariance of span declarations,
- deterministic rejection when square witness digest is not bound to canonical
  square fields.

### Consequences
- span/square layer now has explicit invariance + digest-integrity checks in
  executable conformance fixtures.

---

## 2026-02-22 — Decision 0077: Require golden/adversarial polarity coverage per coherence-site obligation

### Decision
Tighten `coherence-site` checker semantics so each matched site obligation
vector set must include:

- at least one `golden/` vector, and
- at least one `adversarial/` vector.

Missing either polarity now rejects with deterministic failure classes:

- `coherence.<obligation_id>.missing_golden_vector`
- `coherence.<obligation_id>.missing_adversarial_vector`.

### Rationale
Site obligations are checker authority surfaces. Requiring both acceptance and
rejection exemplars for each obligation keeps the fixture contract expressive
while minimizing accidental under-specification.

### Consequences
- coherence checker now enforces per-obligation fixture polarity coverage.
- new unit tests cover missing-golden, missing-adversarial, and both-present
  passing cases.

---

## 2026-02-22 — Decision 0078: Require semantic polarity coverage for coherence-site obligations

### Decision
Extend `coherence-site` polarity enforcement so each matched site obligation
vector set must include semantic result polarity from `expect.result`:

- at least one vector with `accepted`,
- at least one vector with `rejected`.

Missing either semantic result polarity now rejects with deterministic failure
classes:

- `coherence.<obligation_id>.missing_expected_accepted_vector`
- `coherence.<obligation_id>.missing_expected_rejected_vector`.

### Rationale
Path prefix polarity (`golden/` and `adversarial/`) is necessary but not
sufficient. Semantic result polarity closes mislabeling gaps where prefixes can
look balanced while all vectors assert the same expected result.

### Consequences
- coherence checker now enforces both path polarity and semantic result
  polarity for site obligations.
- unit tests now cover missing-expected-accept, missing-expected-reject, and
  mixed semantic polarity pass cases.

---

## 2026-02-22 — Decision 0079: Scope coherence-site vector parsing by obligation map

### Decision
Require `coherence-site/manifest.json` to declare `obligationVectors` mapping
from obligation id to vector ids. Update checker semantics so each obligation
parses/evaluates only vectors in its mapped scope.

### Rationale
With one shared site manifest, malformed unrelated vectors could fail multiple
obligations. Obligation-scoped vector parsing removes that blast radius while
preserving one canonical fixture surface.

### Consequences
- coherence checker now emits deterministic manifest-scope failures when
  obligation mappings are missing or inconsistent.
- unscoped malformed vectors no longer fail untouched obligations.
- regression test added for scope isolation behavior.

---

## 2026-02-22 — Decision 0080: Enforce invariance-pair contract for coherence-site vectors

### Decision
Require `invariance/` site vectors to carry scenario/profile metadata and to be
validated as deterministic profile pairs:

- each invariance vector case MUST declare non-empty
  `semanticScenarioId` and `profile`,
- for each obligation id + `semanticScenarioId`, checker input MUST include
  exactly two invariance vectors with distinct profiles,
- paired vectors MUST evaluate to the same result and failure-class set.

### Rationale
Invariance vectors existed but were not structurally constrained as profile
pairs. Enforcing pair shape prevents drift where invariance is nominally present
but not actually tested across profile choices.

### Consequences
- coherence checker now emits deterministic invariance failures for missing
  metadata, missing/extra pairs, non-distinct profiles, or semantic mismatch.
- coherence-site fixtures now include explicit local/external pair vectors for
  invariance scenarios.
- unit tests now cover pair-count mismatch, pair-result mismatch, and passing
  invariance pairs.

---

## 2026-02-22 — Decision 0081: Harmonize invariance-pair contract across coherence fixture families

### Decision
Apply the same invariance-pair contract used by `coherence-site` to
`coherence-transport`:

- `invariance/` transport vectors MUST declare non-empty
  `semanticScenarioId` and `profile`,
- for each `semanticScenarioId` under `transport_functoriality`, checker input
  MUST include exactly two invariance vectors with distinct profiles,
- paired vectors MUST evaluate to identical result and failure-class sets.

### Rationale
Coherence fixture families were drifting: site vectors had enforced invariance
pair semantics while transport vectors only had single-vector invariance
coverage. One shared contract keeps the checker surface minimal and expressive.

### Consequences
- transport checker now emits deterministic invariance-pair failure classes
  aligned with site semantics.
- transport fixtures now include explicit local/external invariance pair vectors
  for the same semantic scenario.
- unit coverage now includes transport invariance pair-count mismatch,
  pair-result mismatch, and passing pair cases.

---

## 2026-02-22 — Decision 0082: Enforce transport polarity coverage parity

### Decision
Apply site-style polarity requirements to `coherence-transport` vectors under
`transport_functoriality`:

- require at least one matched `golden/` vector,
- require at least one matched `adversarial/` vector,
- require at least one matched `expectedResult = accepted`,
- require at least one matched `expectedResult = rejected`.

### Rationale
Transport checker semantics were still weaker than site semantics on polarity
coverage. Enforcing the same minimal polarity contract closes under-specification
without adding new surface types.

### Consequences
- transport checker now emits deterministic polarity failures aligned with site
  vocabulary:
  - `missing_golden_vector`
  - `missing_adversarial_vector`
  - `missing_expected_accepted_vector`
  - `missing_expected_rejected_vector`
- transport witness details now expose matched vector-kind and expected-result
  counters.
- unit tests now cover all four missing-polarity modes and one passing mixed
  polarity case.

---

## 2026-02-22 — Decision 0083: Clarify lane separation for SigPi, CwF, spans, and Squeak

### Decision
Adopt an explicit lane-separation contract for architectural composition:

1. semantic doctrine lane: kernel + Gate + bidirectional obligation authority,
2. strict checker lane: coherence/CwF strict-equality control-plane checks,
3. witness commutation lane: span/square typed commutation artifacts,
4. runtime transport lane: Squeak world/location transport and site checks.

SigPi (`\Sigma_f -| f* -| \Pi_f`, shorthand `sig\Pi`) obligations remain
semantic-lane authority.
Squeak transport/site evidence remains capability-scoped transport lane.
Composition between these lanes MUST route through one canonical obligation and
witness authority boundary; no second semantic authority schema is allowed.

### Rationale
Recent capability growth (adjoints-sites + Squeak + span/square + CwF
obligations) increases expressiveness but risks architectural duplication if lane
ownership is implicit.

Making lane boundaries explicit preserves the doctrine rule:
minimum canonical encoding, maximum derived expressiveness.

### Consequences
- `draft/UNIFICATION-DOCTRINE` now includes a normative lane map and composition
  constraints for SigPi + Squeak integration.
- `draft/SPEC-INDEX` now documents joint capability guidance and reading order
  for composed SigPi + Squeak systems.
- Future composed profiles should add vectors/contracts by routing through
  existing obligation/witness authority, not by adding parallel semantic
  encodings.

---

## 2026-02-22 — Decision 0084: Normalize SigPi naming and require spans in composed overlays

### Decision
Adopt one naming/notation convention and one composition boundary rule:

1. prose and identifier surfaces MUST use `SigPi` (not `Sig/Pi`),
2. mathematical rendering SHOULD use `\Sigma_f -| f* -| \Pi_f`
   (shorthand `sig\Pi` allowed),
3. composed SigPi + Squeak systems MUST route cross-lane pullback/base-change
   claims through typed span/square witnesses (`draft/SPAN-SQUARE-CHECKING`).

### Rationale
Topos/site and profile docs now rely on one composed semantic story. Keeping
names aligned and making spans explicit prevents drift where composition is
described semantically but under-specified operationally.

### Consequences
- `profile/ADJOINTS-AND-SITES` now includes explicit SigPi naming/notation and
  span/square projection boundary text.
- `draft/UNIFICATION-DOCTRINE` and `draft/SPEC-INDEX` now state SigPi +
  Squeak + spans composition in the same lane-separation language.
- Open issue wording should align with the same convention (`SigPi`, spans
  explicit in composition scope).

---

## 2026-02-22 — Decision 0085: Clarify Unified Evidence Plane contract and lane registry scaffold

### Decision
Clarify unification direction by adding two explicit artifacts:

1. `draft/UNIFICATION-DOCTRINE` §10 now defines a Unified Evidence Plane
   contract (`Ev : Ctx^op -> V`) with:
   - canonical attested evidence surface semantics,
   - universal factoring rule (`F => Ev`) for control-plane artifact families,
   - compact law set (transport, descent/glue-or-witness, determinism binding,
     authority-boundary non-bypass),
   - explicit span/square routing for cross-lane pullback/base-change claims.
2. `draft/CONTROL-PLANE-CONTRACT.json` now carries a machine-readable lane
   registry scaffold:
   - `evidenceLanes`,
   - `laneArtifactKinds`,
   - `laneOwnership`,
   - `laneFailureClasses`.

### Rationale
Unification intent was distributed across lane-separation prose and issue notes.
Adding an explicit `Ev` contract and lane constants reduces ambiguity and gives
one stable reference for future checker/conformance integration.

### Consequences
- `draft/SPEC-INDEX` now points to the Unified Evidence Plane contract in
  `UNIFICATION-DOCTRINE` §10 and adds a dedicated reading path.
- `tools/ci/control_plane_contract.py` now validates and exports optional lane
  registry fields for deterministic adapter use.
- Full lane-registry enforcement in `premath-coherence` remains tracked as
  implementation work (contract constants exist; checker parity enforcement is
  a follow-up).

---

## 2026-02-22 — Decision 0086: Add composed overlay execution contract and ordering guidance

### Decision
Clarify the composed SigPi + spans + Squeak path by adding one explicit profile
execution contract:

1. `profile/ADJOINTS-AND-SITES` adds Section 10 with:
   - capability/required-check routing guidance,
   - composed obligation boundary language,
   - authority mapping table across kernel/coherence/span-square/profile/runtime,
   - deterministic witness-lineage requirements.
2. `draft/SPEC-INDEX` reading guidance now points composed integrations to
   `profile/ADJOINTS-AND-SITES` Section 10.
3. `docs/design/ARCHITECTURE-MAP` includes a current unification execution
   order to keep issue execution aligned with one authority path.

### Rationale
Lane-separation and Unified Evidence Plane rules existed, but composed-overlay
execution details were split across multiple docs. A single composed profile
section plus explicit ordering guidance reduces drift during active unification
work.

### Consequences
- composed overlay ownership and required-check routing are now explicit in one
  profile location.
- architecture-level docs now show an operational sequence that matches active
  unification issues.
- no semantic authority moved: kernel/gate remain admissibility authority.

---

## 2026-02-22 — Decision 0087: Consolidate design docs into explicit runtime/control lanes

### Decision
Consolidate non-normative design surfaces into explicit lanes and add a
canonical Squeak transport/placement design entrypoint:

1. `docs/design/README.md` now defines lane groups:
   - Tusk runtime (inside one world),
   - Squeak/SigPi transport+placement (between worlds),
   - control/CI architecture composition.
2. Add `docs/design/SQUEAK-DESIGN.md` as canonical design guidance for Squeak
   transport/placement.
3. Retain `docs/design/TUSK-SIGPI.md` as a compatibility alias that points to
   `SQUEAK-DESIGN.md`.

### Rationale
`docs/design` mixed Tusk-specific and cross-layer control/transport material in
one presentation, which made boundary ownership unclear and increased drift risk
between runtime and transport guidance.

### Consequences
- design docs now have one explicit canonical path for Squeak transport and
  runtime placement.
- legacy references to `TUSK-SIGPI.md` continue to resolve without breakage.
- normative authority remains unchanged under `specs/`.

---

## 2026-02-22 — Decision 0088: Enforce lane-registry parity in coherence gate-chain checks

### Decision
Close the contract-to-checker gap for lane registry scaffolding by enforcing
optional `CONTROL-PLANE-CONTRACT` lane fields in `gate_chain_parity`:

1. when lane fields are present, `premath-coherence` MUST validate lane IDs for
   non-empty uniqueness,
2. `laneArtifactKinds` MUST bind only to declared lane IDs with non-empty kind
   sets,
3. `laneOwnership` MUST preserve checker-core CwF ownership boundaries and
   require cross-lane witness routing through `span_square_commutation`,
4. `laneFailureClasses` MUST include the required lane-boundary class surface.

### Rationale
Decision 0085 introduced the lane-registry scaffold as a typed contract
artifact, but checker parity enforcement remained a follow-up. Leaving this gap
open risked contract drift where lane boundaries existed in schema only.

### Consequences
- `crates/premath-coherence` now emits deterministic
  `coherence.gate_chain_parity.*` failures for lane registry violations.
- unit tests cover accept/reject cases for duplicate lane IDs, unknown lane-kind
  bindings, missing cross-lane routes, and ownership boundary violations.
- `draft/PREMATH-COHERENCE` §4.3 now states lane-registry fail-closed parity
  behavior when lane fields are present.

---

## 2026-02-22 — Decision 0089: Add executable lane-ownership vectors to gate-chain parity

### Decision
Extend `gate_chain_parity` with executable vector coverage for lane-ownership
boundaries by routing it through the existing coherence-site fixture harness:

1. add `gate_chain_parity` vector scope to
   `tests/conformance/fixtures/coherence-site/manifest.json`,
2. add smoke vectors for:
   - accepted canonical lane ownership + span/square route,
   - rejected checker-core ownership violation,
   - rejected missing cross-lane route,
3. add invariance pair vectors (`local`/`external`) for the same semantic lane
   ownership scenario.

### Rationale
Unit tests covered lane-registry enforcement, but boundary behavior still lacked
fixture-level executable evidence in the same conformance path used by other
coherence obligations.

### Consequences
- `gate_chain_parity` now emits `laneOwnershipVectors` witness details with
  matched polarity/invariance accounting.
- conformance closure validates lane-ownership boundaries through
  `premath coherence-check` and `mise run conformance-run`.

---

## 2026-02-22 — Decision 0090: Add composed SigPi+Squeak+span capability vectors

### Decision
Extend `capabilities.adjoints_sites` vectors with a composed cross-lane slice
that requires:

1. combined capability claim surface (`capabilities.adjoints_sites` +
   `capabilities.squeak_site`),
2. cross-lane pullback/base-change routing through
   `span_square_commutation`,
3. deterministic span-square witness digest material,
4. deterministic runtime transport location binding (`loc1_*` refs),
5. local/external invariance for the same composed semantic scenario.

### Rationale
Composed overlay contract text existed in profile/spec docs, but executable
capability vectors were still lane-local. Adding composed vectors closes the
traceability gap between profile doctrine and conformance execution.

### Consequences
- `tools/conformance/run_capability_vectors.py` now evaluates composed
  adjoints-site vectors with deterministic failure classes:
  `cross_lane_capability_missing`, `cross_lane_route_missing`,
  `cross_lane_witness_mismatch`, and `cross_lane_transport_mismatch`.
- `tests/conformance/fixtures/capabilities/capabilities.adjoints_sites/`
  includes composed golden/adversarial/invariance vectors.
- `draft/CAPABILITY-VECTORS` and
  `profile/ADJOINTS-AND-SITES` now explicitly require composed route/transport
  vector coverage.

---

## 2026-02-22 — Decision 0091: Route Observation projection through one core projector path

### Decision
Unify Observation Surface projection for CI/CLI consumers through one core
projector command path:

1. add `premath observe-build` as the canonical projector entrypoint,
2. implement projection/build logic in `premath-surreal` (`build_surface`,
   `build_events`) with deterministic fail-closed behavior,
3. migrate `mise run ci-observation-build` to `premath observe-build`,
4. migrate semantic invariance check to compare against a fresh
   `premath observe-build` result,
5. keep `tools/ci/observation_surface.py` as a compatibility wrapper that calls
   the core projector command (no parallel reducer authority).

### Rationale
Observation projection semantics were previously encoded in Python while CLI/MCP
query surfaces consumed a separate Rust path. That duplicated projector logic
and created drift risk in summary/coherence projections.

### Consequences
- CI build/check and CLI observation surfaces now share one projector authority
  path.
- deterministic observation projection remains available to scripts/tests via a
  compatibility wrapper.
- new CLI smoke coverage and `premath-surreal` unit coverage guard the unified
  projector behavior.

---

## 2026-02-22 — Decision 0092: Add fail-closed drift-budget sentinel gate

### Decision
Add one deterministic drift-budget checker task to the baseline closure:

1. introduce `tools/ci/check_drift_budget.py` and `mise run ci-drift-budget-check`,
2. fail closed with deterministic `driftClasses` across:
   - SPEC-INDEX capability map vs CAPABILITY-REGISTRY/COHERENCE-CONTRACT docs map,
   - CONTROL-PLANE lane bindings vs coherence checker lane expectations,
   - COHERENCE-CONTRACT required obligation sets vs checker-exported required sets,
   - canonical SigPi notation policy in normative docs,
   - coherence-suite cache input closure for coherence/control-plane loaders.

### Rationale
`coherence-check` and docs-coherence checks validate many invariants, but drift
signals were distributed across outputs and not exposed as one compact control
plane sentinel surface. A single fail-closed drift-budget check tightens
unification execution and gives one deterministic summary for CI consumption.

### Consequences
- baseline now includes `ci-drift-budget-check`,
- CI tooling docs and command surfaces include the new gate,
- added deterministic unit tests (`tools/ci/test_drift_budget.py`) covering each
  drift class and cache-closure input scope expectations.

---

## 2026-02-22 — Decision 0093: Add control-plane schema lifecycle contract and alias-window enforcement

### Decision
Adopt one typed schema lifecycle table in
`draft/CONTROL-PLANE-CONTRACT.json` and route client-side kind validation
through it.

Implemented scope:

1. add `schemaLifecycle` with canonical kind families for:
   - `*.contract.v*` control-plane kind,
   - required/instruction witness kinds,
   - required decision kind,
   - required projection policy kind,
   - required delta kind;
2. allow compatibility aliases only with explicit `supportUntilEpoch` and
   canonical `replacementKind`,
3. resolve accepted aliases to canonical kind during validation,
4. fail closed deterministically when alias windows are expired or kinds are
   unsupported.

### Rationale
Version and alias handling existed as ad-hoc string checks across CI clients.
That made compatibility policy implicit and harder to audit. A single lifecycle
table keeps minimum encoding while preserving controlled compatibility windows.

### Consequences
- `tools/ci/control_plane_contract.py` is now the canonical lifecycle resolver
  for schema kind families.
- required witness/decision/projection/delta and instruction witness client
  validators now consume the shared resolver.
- tests now cover:
  - accepted legacy alias behavior inside support window,
  - deterministic rejection past support window (`expired` failure path).
- `draft/UNIFICATION-DOCTRINE` now states normative lifecycle/deprecation rules
  for contract/witness/projection kind families and migration witness
  expectations.

---

## 2026-02-22 — Decision 0094: Enforce schema lifecycle epoch discipline in CI loader paths

### Decision
Tighten `schemaLifecycle` validation in `tools/ci/control_plane_contract.py`
with one deterministic rollover policy:

1. all compatibility aliases in one lifecycle table MUST share one
   `supportUntilEpoch` rollover epoch,
2. rollover runway (`supportUntilEpoch - activeEpoch`) MUST be strictly
   positive,
3. rollover runway MUST be bounded to 12 months in the CI implementation
   profile.

Validation remains fail-closed during control-plane contract load.

### Rationale
Alias-window checks were present, but rollover discipline across families was
implicit. Without one shared epoch and bounded runway, compatibility windows can
drift and silently accumulate long-lived aliases.

### Consequences
- CI loader/import surfaces now reject mixed rollover epochs and unbounded alias
  runway at contract load time.
- exported lifecycle metadata now includes deterministic epoch-discipline fields
  (`rolloverEpoch`, `aliasRunwayMonths`, `maxAliasRunwayMonths`) for downstream
  diagnostics.
- unit coverage in `tools/ci/test_control_plane_contract.py` now includes
  mixed-epoch and overlong-runway rejection paths.

---

## 2026-02-22 — Decision 0095: Make Unified Evidence Plane factorization explicitly fail-closed

### Decision
Tighten `draft/UNIFICATION-DOCTRINE` Unified Evidence Plane (`§10`) to require
explicit universal factorization semantics:

1. implementations claiming Unified Evidence Plane MUST define one indexed
   evidence family `Ev : Ctx^op -> V`,
2. each control-plane artifact family MUST factor through one deterministic
   natural transformation `eta_F : F => Ev`,
3. factorization MUST be unique up to canonical projection equality for fixed
   deterministic bindings,
4. non-factorable or ambiguous factorization MUST reject deterministically via
   fail-closed factorization classes.

### Rationale
The doctrine already declared one evidence surface, but wording remained partly
advisory (`SHOULD`) and did not state the fail-closed boundary when routing is
missing or ambiguous. Explicit factorization semantics tighten the authority
boundary with minimum additional encoding.

### Consequences
- `draft/UNIFICATION-DOCTRINE` now defines deterministic fail-closed
  factorization classes:
  - `unification.evidence_factorization.missing`
  - `unification.evidence_factorization.ambiguous`
  - `unification.evidence_factorization.unbound`
- `draft/SPEC-INDEX` now requires (MUST) unified evidence factoring in lane
  ownership guidance.
- `tools/conformance/check_docs_coherence.py` now enforces marker-level presence
  for Unified Evidence factoring and fail-closed boundary language in normative
  docs.

---

## 2026-02-22 — Decision 0096: Promote span/square composition laws to executable coherence surface

### Decision
Extend `draft/SPAN-SQUARE-CHECKING` and `span_square_commutation` checking to
cover composition laws explicitly:

1. add optional `compositionLaws` witness surface for span/square law rows,
2. bind each composition law row to deterministic digest
   (`sqlw1_ + SHA256(JCS(LawCore))`),
3. require accepted-law coverage for:
   - `span_identity`,
   - `span_associativity`,
   - `square_identity`,
   - `square_associativity_horizontal`,
   - `square_associativity_vertical`,
   - `square_hv_compatibility`,
   - `square_interchange`,
4. evaluate square expressions through deterministic horizontal/vertical
   composition normalization with fail-closed shape checks.

### Rationale
Span/square checking previously validated only single-square commutation. The
algebraic closure track (`bd-123`) requires composition as first-class witness
data so pipeline/base-change coherence is expressed as one typed executable
surface, not as implicit prose-only laws.

### Consequences
- `premath-coherence` now evaluates optional composition-law expressions and
  enforces deterministic accepted/rejected law semantics.
- coherence-site fixtures include new vectors:
  - `golden/span_square_commutation_composition_accept`
  - `adversarial/span_square_commutation_composition_missing_law_reject`
  - `invariance/span_square_commutation_composition_accept`
  - `invariance/span_square_commutation_composition_accept_external`
- docs coherence checks now enforce composition-law markers in
  `SPAN-SQUARE-CHECKING` and `PREMATH-COHERENCE`.

---

## 2026-02-22 — Decision 0097: Define CwF <-> sig\Pi bridge as vocabulary-preserving boundary

### Decision
Specify an explicit bridge contract between strict CwF checker equalities and
semantic SigPi obligations without changing ownership lanes.

Implemented scope:

1. add normative bridge section to `profile/ADJOINTS-AND-SITES`:
   - strict vs semantic authority split,
   - admissible bridge morphisms,
   - CwF->semantic law mapping table,
   - deterministic failure/ownership constraints;
2. add checker-boundary clause in `draft/PREMATH-COHERENCE` requiring bridge
   routing to preserve existing obligation IDs;
3. add lane-reference updates in `draft/SPEC-INDEX` and
   `draft/UNIFICATION-DOCTRINE` so bridge behavior remains explicit in the
   canonical unification path.

### Rationale
CwF strict equalities and SigPi semantic obligations were already present but
their translation boundary was implicit. Explicit bridge mapping closes a drift
gap while preserving the minimum-encoding rule: no new authority vocabulary and
no re-ownership of checker/semantic lanes.

### Consequences
- CwF bridge semantics are now explicit and traceable in normative docs.
- Bridge mapping is fail-closed and vocabulary-preserving:
  checker keeps `cwf_*`; semantic lane keeps
  `stability/locality/descent_*/adjoint_*`.
- `tools/conformance/check_docs_coherence.py` now enforces bridge markers in
  `ADJOINTS-AND-SITES`, `PREMATH-COHERENCE`, and `SPEC-INDEX`.

---

## 2026-02-22 — Decision 0098: Add cross-layer obstruction algebra and conformance roundtrip

### Decision
Adopt a typed cross-layer obstruction algebra as a secondary projection over
existing failure classes, with deterministic roundtrip semantics.

Implemented scope:

1. `draft/UNIFICATION-DOCTRINE` now defines §11 (`Cross-layer Obstruction
   Algebra`) with:
   - constructor families (`semantic`, `structural`, `lifecycle`,
     `commutation`),
   - deterministic projection pair (`project_obstruction`,
     `canonical_obstruction_class`),
   - initial mapping table spanning Gate/BIDIR, coherence, lifecycle, and
     unification factorization classes,
   - issue-memory projection tag convention (`obs.<family>.<tag>`).
2. `capabilities.ci_witnesses` now includes executable obstruction roundtrip
   vectors (golden + adversarial).
3. capability evaluator now checks deterministic constructor/class roundtrip and
   deterministic issue-tag projection for fixed source classes.

### Rationale
Failure classes were already deterministic inside each lane, but cross-layer
reasoning lacked one typed projection surface for analysis/discovery. Adding an
algebraic projection keeps minimum encoding (source classes unchanged) while
improving expressiveness for coherence/issue-memory workflows.

### Consequences
- Source failure-class authority remains unchanged; obstruction constructors are
  additive metadata only.
- Cross-layer roundtrip is now executable under `capabilities.ci_witnesses`.
- docs coherence checks enforce presence of obstruction algebra clauses and
  capability-vector coverage language.

---

## 2026-02-22 — Decision 0099: Define Tusk harness contract as runtime-control overlay

### Decision
Adopt a concise harness contract for long-running agents as a Tusk runtime
control overlay (design layer), without adding a new semantic authority path.

Implemented scope:

1. add `docs/design/TUSK-HARNESS-CONTRACT.md` defining:
   - hook model: `boot` / `step` / `stop`,
   - durability boundaries (fresh-context restartability, compaction/offload,
     explicit sub-agent boundaries),
   - deterministic verification/retry boundary,
   - trajectory/evidence capture contract;
2. map harness clauses to existing surfaces:
   - `mcp-serve` (instruction-linked mutation path),
   - instruction pipeline + witness verification/decision,
   - Observation Surface v0 projection/query,
   - issue/event memory substrates;
3. record explicit current gaps and a 2-4 slice implementation plan
   (handoff artifact, feature ledger, trajectory rows, retry-policy table);
4. cross-link harness overlay from `docs/design/README.md`,
   `docs/design/TUSK-ARCHITECTURE.md`, and `docs/design/ARCHITECTURE-MAP.md`.

### Rationale
The unification closure track needs a concrete long-run execution contract for
agents, but semantic authority must remain in kernel/checker/discharge
surfaces. A Tusk harness overlay gives operational structure with minimum
encoding and avoids duplicating admissibility semantics in CI or planner layers.

### Consequences
- Harness behavior is now explicit and composable with existing runtime/control
  surfaces.
- No change to semantic authority boundaries:
  model outputs remain proposals; checker/discharge/witness artifacts remain
  authoritative.
- Follow-on implementation can proceed as bounded slices without forcing full
  mathematical generalization up front.

---

## 2026-02-22 — Decision 0100: Canonical harness retry-policy contract for pipeline wrappers

### Decision
Adopt one digest-bound retry-policy artifact for provider-neutral pipeline
wrappers and enforce it through a shared helper.

Implemented scope:

1. add canonical retry policy registry + artifact:
   - `policies/control/README.md`
   - `policies/control/harness-retry-policy-v1.json`
2. add shared deterministic policy helper:
   - `tools/ci/harness_retry_policy.py`
   - validates schema + digest
   - parses witness failure classes
   - returns typed attempt-level retry/escalation decisions
3. enforce policy in wrapper entrypoints:
   - `tools/ci/pipeline_required.py`
   - `tools/ci/pipeline_instruction.py`
4. emit retry policy + retry history in wrapper summary outputs.

### Rationale
The harness contract required fail-closed classify/retry/escalate behavior, but
the operational table was implicit. A single digest-bound policy keeps retry
logic deterministic and shared across required/instruction wrapper paths without
moving semantic authority out of checker/witness surfaces.

### Consequences
- Retry behavior is now explicit, auditable, and test-covered in one policy
  surface.
- Wrapper failures classify from emitted witness artifacts, not ad-hoc stderr.
- Escalation actions are typed (`issue_discover`, `mark_blocked`, `stop`), with
  automatic issue-memory mutation wiring left as follow-on work.

---

## 2026-02-22 — Decision 0101: Bind terminal retry escalation actions to premath-bd mutations

### Decision
Bind terminal retry escalation actions from provider-neutral pipeline wrappers
to `premath issue` mutation commands via one shared bridge.

Implemented scope:

1. add shared bridge:
   - `tools/ci/harness_escalation.py`
2. wrapper integration:
   - `tools/ci/pipeline_required.py`
   - `tools/ci/pipeline_instruction.py`
3. action mapping:
   - `issue_discover` -> `premath issue discover`
   - `mark_blocked` -> `premath issue update --status blocked --notes ...`
   - `stop` -> no mutation
4. active issue context contract:
   - `PREMATH_ACTIVE_ISSUE_ID` (fallback `PREMATH_ISSUE_ID`)
   - optional `PREMATH_ISSUES_PATH`

### Rationale
Retry policy classification without mutation execution leaves escalation as
informational output only. Binding terminal actions into `premath-bd` keeps
harness state progression in the same issue-memory authority surface and closes
the operational loop for long-running workflows.

### Consequences
- Terminal escalation now creates/updates issue-memory state deterministically
  when active issue context is present.
- Missing issue context produces deterministic skipped-escalation metadata.
- Mutation command failures are fail-closed in wrappers (non-success return
  with typed escalation error metadata).

---

## 2026-02-22 — Decision 0102: Promote harness retry/escalation bindings into typed spec surfaces

### Decision
Bind harness retry/escalation semantics into normative control-plane spec
artifacts rather than design docs only.

Implemented scope:

1. extend `draft/CONTROL-PLANE-CONTRACT.json` with `harnessRetry`:
   - policy kind/path,
   - escalation action vocabulary,
   - active issue context env keys and issues-path env key.
2. extend `tools/ci/control_plane_contract.py` loader + exported constants for
   `harnessRetry` and fail-closed contract validation.
3. extend drift-budget sentinel parity checks for harness retry fields.
4. update spec text:
   - `draft/PREMATH-COHERENCE` gate-chain parity semantics include
     `harnessRetry` contract presence/shape checks.
   - `raw/PREMATH-CI` adds retry/escalation control-loop binding clauses.
   - `draft/SPEC-INDEX` marks harness retry/escalation as part of
     `draft/CONTROL-PLANE-CONTRACT` informative control-plane constants.

### Rationale
The implementation had working retry/escalation behavior, but spec authority
was primarily in design docs + decision log. Typing these bindings into the
control-plane contract reduces drift risk and keeps CI/coherence loaders
fail-closed on schema divergence.

### Consequences
- Harness retry/escalation contract is now machine-bound in typed spec payloads.
- Drift checks enforce loader/contract parity for retry/escalation fields.
- Control-plane semantics remain non-authoritative for kernel admissibility.

---

## 2026-02-22 — Decision 0103: Resolve retry escalation issue context via harness-session fallback

### Decision
Extend terminal retry escalation issue-context resolution with a deterministic
fallback to harness-session artifacts, and bind that fallback into control-plane
contract checks.

Implemented scope:

1. escalation issue-context resolution order in `tools/ci/harness_escalation.py`:
   - `PREMATH_ACTIVE_ISSUE_ID`,
   - `PREMATH_ISSUE_ID`,
   - harness-session artifact `issueId` from:
     - `PREMATH_HARNESS_SESSION_PATH` (override),
     - `.premath/harness_session.json` (default).
2. fail-closed behavior for malformed/unreadable harness-session artifacts:
   - `escalation_session_invalid`,
   - `escalation_session_read_failed`.
3. contract + loader + drift-budget bindings:
   - `draft/CONTROL-PLANE-CONTRACT.json` `harnessRetry` adds:
     `sessionPathEnvKey`, `sessionPathDefault`, `sessionIssueField`,
   - `tools/ci/control_plane_contract.py` exports corresponding constants,
   - `tools/ci/check_drift_budget.py` enforces parity.
4. tests/docs/spec updates:
   - escalation fallback + fail-closed tests,
   - design docs now document env+session fallback as canonical path,
   - `draft/PREMATH-COHERENCE` parity text includes harness-session bindings.

### Rationale
Retry escalation mutation paths were wired but depended on explicit env setup in
every run context. Harness-session artifacts already carry active issue identity
for long-run continuity, so they should participate in deterministic fallback
resolution to reduce skipped escalations without adding parallel semantics.

### Consequences
- Escalation mutation paths are available in more harness executions by default.
- Missing issue context remains explicit (`skipped_missing_issue_context`) only
  after env+session resolution fails.
- Control-plane drift checks now fail closed if harness-session contract fields
  drift between spec payload and loader/checker surfaces.

---

## 2026-02-22 — Decision 0104: Adopt multi-lane work-memory contract

### Decision
Adopt one explicit work-memory lane split and write-discipline contract:

1. issue graph lane: `.premath/issues.jsonl` (authoritative mutable work state),
2. operations lane: `.premath/OPERATIONS.md` (operational conventions/evidence),
3. doctrine/decision lane: `specs/*` + `specs/process/decision-log.md`
   (boundary/lifecycle authority).

Implementation documentation:

- `docs/design/MEMORY-LANES-CONTRACT.md`

Associated surface updates:

- `docs/design/README.md` lane-map index,
- `AGENTS.md` memory-lane discipline section,
- `.premath/OPERATIONS.md` evidence table now carries `Issue` + `Decision`
  columns for deterministic cross-lane references.

### Rationale
Issue rows alone are insufficient for long-run agent memory: we also need stable
operational conventions/evidence and explicit doctrine decisions. Making the
lane split explicit keeps memory expressive while preserving one authority
boundary per concern.

### Consequences
- Agents/operators now have a canonical location for each class of memory write.
- Cross-lane references become deterministic (`issue-id`, optional
  `decision-id`) instead of ad-hoc note expansion.
- Issue-note compaction work (`bd-129`) is now naturally scoped as lane hygiene
  instead of implicit style preference.

---

## 2026-02-22 — Decision 0105: Add schema lifecycle governance modes (`rollover|freeze`)

### Decision
Extend control-plane schema lifecycle semantics with explicit governance mode
metadata and fail-closed validation.

Implemented scope:

1. add `schemaLifecycle.governance` in
   `draft/CONTROL-PLANE-CONTRACT.json` with:
   - `mode` (`rollover|freeze`)
   - `decisionRef`
   - `owner`
   - `rolloverCadenceMonths` (rollover-only)
   - `freezeReason` (freeze-only)
2. enforce deterministic governance validation in
   `tools/ci/control_plane_contract.py`:
   - rollover requires aliases and cadence-bound runway,
   - freeze requires no aliases and explicit freeze reason.
3. enforce schema-lifecycle governance checking in
   `crates/premath-coherence` gate-chain parity path.
4. extend drift-budget parity checks for loader-exported governance fields.
5. add process-level governance contract doc:
   - `specs/process/SCHEMA-LIFECYCLE-GOVERNANCE.md`
6. wire cross-references from lifecycle specs/design docs.

### Rationale
Lifecycle policy previously encoded epoch/runway mechanics but did not make
governance state explicit. We need deterministic distinction between active
rollover and explicit freeze states, plus accountable references for each
transition.

### Consequences
- Lifecycle checks now fail closed on governance-state mismatches, not only on
  alias expiry/format errors.
- Rollover cadence and freeze exceptions are now machine-checkable and linked to
  decision-log authority.
- Lifecycle semantics are no longer CI-loader-only; coherence checker now
  enforces the same governance state boundary.

---

## 2026-02-22 — Decision 0106: Stage Unified Evidence Plane typed internalization with deterministic rollback

### Decision
Define a normative staged migration path for Premath-native typed evidence
objects under `draft/UNIFICATION-DOCTRINE` §10.6.

Implemented scope:

1. add `§10.6 Typed evidence-object internalization stages (v0)` with four
   stages:
   - Stage 0: projection-locked parity,
   - Stage 1: typed-core dual projection,
   - Stage 2: canonical typed authority with compatibility alias,
   - Stage 3: typed-first cleanup.
2. require deterministic stage-gate preservation of:
   - universal factoring (`eta_F : F => Ev`),
   - deterministic bindings (`normalizerId + policyDigest`),
   - fail-closed factorization boundaries.
3. require deterministic rollback semantics:
   - no second authority artifact,
   - prior canonical identity bindings preserved,
   - decision-log + issue linkage before re-promotion.
4. cross-link migration guidance from `draft/SPEC-INDEX` lane ownership and the
   Unified Evidence Plane reading path.
5. enforce marker-level docs coherence checks for the new staged contract.

### Rationale
Unified Evidence Plane factorization was explicit, but migration from
payload-first witnesses to typed evidence objects remained roadmap-level.
Explicit staged gates and rollback constraints keep migration expressive while
preserving the minimum-encoding authority boundary.

### Consequences
- Typed `Ev` migration is now normative and replay-auditable.
- Compatibility windows remain lifecycle-governed rather than ad-hoc.
- Stage failures are handled by deterministic rollback, not parallel authority
  execution paths.

---

## 2026-02-22 — Decision 0107: Define Stage 1 typed-core profile and parity class boundary for `Ev`

### Decision
Add a minimal normative Stage 1 profile/class contract under
`draft/UNIFICATION-DOCTRINE` §10.6 to make typed-core dual-projection claims
machine-checkable.

Implemented scope:

1. add `§10.6.1 Stage 1 typed-core profile (minimum)` requiring:
   - one profile kind identifier,
   - deterministic binding fields (`normalizerId`, `policyDigest`),
   - one canonical typed-core identity function,
   - one deterministic authority->typed-core projection.
2. add `§10.6.2 Stage 1 dual-projection parity contract` requiring deterministic
   parity tuple evaluation and fail-closed rejection classes:
   - `unification.evidence_stage1.parity.missing`
   - `unification.evidence_stage1.parity.mismatch`
   - `unification.evidence_stage1.parity.unbound`
3. clarify in `draft/SPEC-INDEX` lane guidance that Stage 1 parity claims are
   bound to `§10.6.2` fail-closed class boundary.
4. extend docs-coherence checks/tests to enforce marker-level presence for the
   new Stage 1 profile and class contract text.

### Rationale
`§10.6` already defined staged internalization, but Stage 1 lacked explicit
minimal profile fields and deterministic parity error vocabulary. That left the
first implementation step underspecified.

### Consequences
- Stage 1 now has a precise minimum contract without introducing parallel
  semantic authority.
- Implementations can assert/reject Stage 1 parity deterministically with one
  stable class surface.
- Docs coherence checks now fail closed if Stage 1 profile/class clauses drift.

---

## 2026-02-22 — Decision 0108: Bind Stage 1 parity/rollback to executable vectors and deterministic rollback witness classes

### Decision
Complete Stage 1 execution slices by binding parity + rollback contracts into
coherence-site vectors, checker details, and normative rollback class surfaces.

Implemented scope:

1. extend `draft/UNIFICATION-DOCTRINE` with
   `§10.6.3 Stage 1 deterministic rollback witness contract`, including
   canonical rollback classes:
   - `unification.evidence_stage1.rollback.precondition`
   - `unification.evidence_stage1.rollback.identity_drift`
   - `unification.evidence_stage1.rollback.unbound`
2. extend `draft/CONTROL-PLANE-CONTRACT.json` with:
   - `evidenceStage1Parity` (typed-core parity metadata),
   - `evidenceStage1Rollback` (rollback witness metadata).
3. extend `premath-coherence` `gate_chain_parity` checks with fail-closed
   Stage 1 rollback validation classes:
   - `coherence.gate_chain_parity.stage1_rollback_invalid`
   - `coherence.gate_chain_parity.stage1_rollback_precondition_missing`
   - `coherence.gate_chain_parity.stage1_rollback_failure_class_mismatch`
   - `coherence.gate_chain_parity.stage1_rollback_unbound`
4. extend coherence-site `gate_chain_parity` vectors with Stage 1
   accept/reject rows (`gate_chain_parity_stage1_*`) and route site evaluator
   details through `stage1Parity` + `stage1Rollback`.
5. extend docs/traceability + control-plane loader parity:
   - docs coherence enforces Stage 1 parity/rollback marker language and
     contract shape checks,
   - traceability row for `UNIFICATION-DOCTRINE` now names Stage 1 vector
     surface,
   - `tools/ci/control_plane_contract.py` + drift-budget checks include Stage 1
     parity/rollback typed fields.

### Rationale
Stage 1 parity classes existed normatively, but executable coverage and rollback
class boundaries were still split across prose/checker-only surfaces. We need
one deterministic contract path from doctrine text to vectors to checker output.

### Consequences
- Stage 1 parity and rollback paths are now machine-checkable end-to-end in
  the same gate-chain parity pipeline.
- Rollback metadata is no longer an implicit design note; it is typed contract
  material with deterministic class mapping.
- Coherence and drift-budget checks now fail closed on Stage 1 parity/rollback
  contract drift.

---

## 2026-02-22 — Decision 0109: Close Stage 2 authority-flip docs/traceability with executable clause mapping

### Decision
Promote Stage 2 authority-flip documentation from prose-only status to explicit
clause-to-surface executable mapping and close traceability status for
`UNIFICATION-DOCTRINE`.

Implemented scope:

1. extend `draft/UNIFICATION-DOCTRINE` with
   `§10.6.4 Stage 2 authority mapping table (normative)` binding Stage 2
   doctrine clauses to:
   - typed contract fields (`draft/CONTROL-PLANE-CONTRACT.json`),
   - coherence checker surfaces (`gate_chain_parity` Stage 2 checks),
   - executable vector rows (`gate_chain_parity_stage2_*` and
     `capabilities.ci_witnesses` boundary-authority vectors).
2. update `draft/SPEC-INDEX` to state Stage 2 typed-authority claims must bind
   to `§10.6.4` mapping (including boundary-authority vectors).
3. update `draft/SPEC-TRACEABILITY` to mark `UNIFICATION-DOCTRINE.md` as
   `covered` with Stage 1+Stage 2 checker/vector surfaces explicitly listed.

### Rationale
Stage 2 implementation surfaces were already executable, but the documentation
still left the authority-flip closure partially implicit. We need one explicit
normative map from doctrine clauses to checker/vector evidence so Stage 2
status is auditable and replayable.

### Consequences
- Stage 2 authority boundaries are now documented as executable mappings, not
  narrative guidance.
- Traceability status for `UNIFICATION-DOCTRINE` now reflects actual checker and
  vector coverage.
- Future Stage 2 drift can be detected against one canonical docs contract.

---

## 2026-02-23 — Decision 0110: Close Stage 3 typed-first authority cleanup with bounded fallback and rollback

### Decision
Close Stage 3 authority cleanup by making direct checker/discharge evidence the
canonical Stage 2 authority route, documenting Stage 3 closure mapping, and
recording explicit fallback/rollback bounds.

Implemented scope:

1. migrate Stage 2 authority contract/checker surfaces to direct bidir route:
   - canonical field `evidenceStage2Authority.bidirEvidenceRoute`,
   - required constants `routeKind=direct_checker_discharge` and
     `obligationFieldRef=bidirCheckerObligations`,
   - canonical obligation + failure-class parity checks through
     `gate_chain_parity`.
2. keep transitional sentinel path compatibility-only and bounded:
   - optional `kernelComplianceSentinel` accepted only when
     `bidirEvidenceRoute.fallback.mode=profile_gated_sentinel`,
   - current profile kind MUST be explicitly allowlisted in
     `fallback.profileKinds`,
   - default contract keeps fallback allowlist empty.
3. close docs/traceability loop:
   - add `§10.6.5 Stage 3 typed-first closure mapping (normative)` to
     `draft/UNIFICATION-DOCTRINE`,
   - update `draft/SPEC-INDEX` staged-gate lane note to include Stage 3 closure
     constraints,
   - update `draft/SPEC-TRACEABILITY` Stage 3 surface wording.

Rollback notes (bounded):

1. rollback MAY temporarily re-enable sentinel fallback for a profile only under
   the profile-gated rule above;
2. rollback MUST NOT introduce a second authority artifact or alias-as-authority
   path;
3. rollback + re-promotion MUST be issue-linked and decision-logged before
   widening profile allowlists.

### Rationale
Stage 3 intent (typed-first authority) was implemented in code paths but remained
partly implicit in doctrine closure language and decision-bound fallback limits.
This decision makes the migration boundary explicit and replay-auditable.

### Consequences
- Stage 3 now has one canonical authority route across contract/checker/docs.
- Transitional fallback is explicit, narrow, and profile-scoped instead of open-ended.
- Future fallback expansion/reduction is constrained by deterministic governance
  instead of ad-hoc implementation drift.

---

## 2026-02-23 — Decision 0111: Promote harness runtime/retry contracts to draft surfaces

### Decision
Promote stable harness operational contracts from design docs into draft spec
surfaces:

1. add `draft/HARNESS-RUNTIME` for `boot/step/stop`, session/feature/trajectory
   artifact contracts, and deterministic multithread worker/coordinator loop
   behavior.
2. add `draft/HARNESS-RETRY-ESCALATION` for canonical retry-policy digest
   binding, failure-class routing, and escalation context resolution.
3. update `draft/SPEC-INDEX`, `draft/SPEC-TRACEABILITY`, and draft/design
   READMEs to route harness surfaces through existing doctrine-site operation
   IDs only (no new operation authority paths).

### Rationale
Harness behavior was already live in command and test surfaces, but contract
language remained split across non-normative design docs. Promotion provides one
draft-contract surface for runtime and retry/escalation behavior while keeping
existing semantic authority boundaries unchanged.

### Consequences
- Harness runtime/retry behavior is now traceable in promoted draft specs.
- Doctrine-site routing for harness session/escalation paths is explicit in the
  index and promoted docs.
- Design docs remain implementation runbooks and must not diverge from promoted
  harness contract surfaces.

---

## 2026-02-23 — Decision 0112: Add harness-v1 and multi-writer claim conformance vectors

### Decision
Extend executable capability vectors to close harness-v1 and multi-writer claim
coverage gaps:

1. `capabilities.ci_witnesses` gains harness runtime vectors for deterministic
   boot/stop/recovery behavior:
   - bootstrap mode contract (`attach|resume`),
   - lease-state -> recovery-action mapping,
   - stop-row lease-handoff witness linkage.
2. `capabilities.change_morphisms` gains same-owner active lease-id vectors:
   - preserve existing lease id on same-owner active claim paths,
   - reject deterministic transition expectations that attempt lease-id override,
   - paired local/external invariance rows.
3. evaluator parity is updated in
   `tools/conformance/run_capability_vectors.py` to match current lock-safe
   claim semantics and harness stop/handoff contract checks.
4. capability docs are updated:
   - `draft/CAPABILITY-VECTORS`
   - `draft/CONFORMANCE`

### Rationale
Harness runtime/retry contracts were promoted to draft (Decision 0111), but
capability vectors did not yet encode deterministic harness recovery rows. We
also needed explicit executable coverage for same-owner active lease-id
preservation from lock-safe multi-writer claim semantics.

### Consequences
- Conformance now rejects deterministic drift in harness stop/handoff and
  recovery mapping behavior.
- Multi-writer claim semantics are checked for same-owner lease-id stability,
  not only contention/stale paths.
- Docs/spec conformance language is aligned with executable vector rows for
  both capabilities.

---

## 2026-02-23 — Decision 0113: Keep harness typestate scoped under `capabilities.change_morphisms` with explicit split triggers

### Decision
Adopt a bundled claim policy for harness typestate closure/mutation gating:

1. `draft/HARNESS-TYPESTATE` remains capability-scoped under
   `capabilities.change_morphisms` (no new executable capability ID now).
2. `draft/CAPABILITY-REGISTRY.json` remains unchanged at the current executable
   capability set; harness typestate conformance remains part of the existing
   `capabilities.change_morphisms` claim surface.
3. A dedicated typestate capability claim MAY be introduced later only when one
   or more split triggers is met:
   - independent claimability is required (operators need to claim typestate
     closure without claiming full change-morphism projection/mutation scope, or
     the inverse),
   - independent operation ownership is required (typestate execution routes no
     longer fit the existing change-morphism doctrine-operation surface),
   - independent conformance lifecycle is required (typestate vectors/checks must
     evolve/deprecate on a release cadence materially decoupled from
     change-morphism vectors).
4. If split triggers are met, the change MUST be decision-logged and include
   coordinated updates to:
   - `draft/CAPABILITY-REGISTRY.json`,
   - `draft/SPEC-INDEX`,
   - `draft/CONFORMANCE`,
   - `draft/CAPABILITY-VECTORS`,
   - docs/coherence marker checks.

### Rationale
This keeps the claim surface minimal while preserving expressiveness. Current
runtime and conformance evidence already routes typestate closure through the
same operational mutation discipline as change morphisms. Introducing a separate
claim now would add topology (new claim, vectors, checker branching) without a
clear independent authority boundary.

### Consequences
- Capability topology remains compact (no new claim lane unless justified by
  execution or lifecycle decoupling).
- Typestate fail-closed behavior remains enforced and testable under an existing
  capability claim.
- Future split decisions are constrained by explicit triggers instead of ad-hoc
  claim proliferation.

---

## 2026-02-23 — Decision 0114: Add executable topology-budget contract and consolidate redundant doc topology

### Decision
Adopt one executable topology-budget contract and reduce redundant design/doc
nodes while preserving authority boundaries.

1. Add `specs/process/TOPOLOGY-BUDGET.json` as the canonical threshold contract
   for measurable topology metrics.
2. Extend `tools/ci/check_drift_budget.py` with deterministic topology metrics
   and explicit fail/warn semantics:
   - fail classes remain under `driftClasses`,
   - non-failing budget pressure is emitted under `warningClasses`.
3. Consolidate doctrine-site authority input to one canonical input surface:
   - `draft/DOCTRINE-SITE-INPUT.json` is authoritative,
   - `draft/DOCTRINE-SITE.json` and `draft/DOCTRINE-OP-REGISTRY.json` are generated views.
4. Consolidate micro-fragment design docs:
   - harness session/trajectory/KPI runbooks fold into
     `docs/design/TUSK-HARNESS-CONTRACT.md` sections,
   - EV Stage 1/Stage 3 runbooks fold into
     `docs/design/EV-COHERENCE-OVERVIEW.md`,
   - SigPi compatibility alias doc folds into `docs/design/SQUEAK-DESIGN.md`.

### Rationale
The repository already enforces semantic/control-plane coherence but lacked a
first-class quantitative topology budget surface. Adding one machine contract
enables deterministic budget reporting while consolidation removes redundant
doc/input nodes without changing executable authority.

### Consequences
- CI now reports both drift failures and warning-grade topology pressure.
- Doctrine-site input duplication is reduced while MCP parity keeps direct
  operation-registry consumption.
- Design index complexity is lower, with fewer fragment files to keep coherent.

---

## 2026-02-23 — Decision 0115: Enforce explicit Harness+Squeak runtime-route parity in doctrine and control-plane gates

### Decision
Adopt a fail-closed runtime-route parity contract and executable checker path:

1. Add `runtimeRouteBindings` to `draft/CONTROL-PLANE-CONTRACT.json` with
   canonical required operation routes:
   - `op/ci.run_gate`
   - `op/ci.run_gate_terraform`
   and required transport/runtime morphism coverage.
2. Extend `tools/ci/control_plane_contract.py` and
   `tools/ci/check_drift_budget.py` so contract/loader/doctrine-operation
   parity rejects on missing runtime route bindings.
3. Add explicit doctrine operation routing for runtime parity checker:
   - `op/conformance.runtime_orchestration` ->
     `tools/conformance/check_runtime_orchestration.py`
   via `draft/DOCTRINE-SITE-INPUT.json` (with generated site/registry refresh).
4. Add deterministic runtime orchestration vectors and cached suite integration:
   - `tests/conformance/fixtures/runtime-orchestration/`
   - `tools/conformance/run_runtime_orchestration_vectors.py`
   - `tools/conformance/run_fixture_suites.py --suite runtime-orchestration`.
5. Promote doctrine gate command surface to include runtime-route parity:
   `mise run doctrine-check` now runs site coherence + runtime orchestration
   parity + MCP doctrine-operation parity + doctrine-inf vectors.

### Rationale
Runtime orchestration between Harness, Squeak, and destination Tusk/Gate was
architecturally specified but not fully encoded as one executable parity lane.
Adding a typed route contract plus checker/vectors closes that gap without
introducing a second semantic authority path.

### Consequences
- Missing/partial runtime route bindings now fail closed in drift and doctrine
  gate surfaces.
- Runtime orchestration conformance has dedicated golden/adversarial vectors.
- Docs/index/traceability now reference the explicit runtime-route parity
  checker as part of doctrine closure.

---

## 2026-02-23 — Decision 0116: Place control-plane bundle profile (`C_cp`/`E_cp`) in the typed control-plane contract

### Decision
Declare the control-plane bundle profile directly in
`draft/CONTROL-PLANE-CONTRACT.json` under `controlPlaneBundleProfile` (rather
than introducing a separate draft spec), with canonical typed fields:

1. `contextFamily.id = C_cp` with required repository-state context and
   context-morphism kind sets.
2. `artifactFamily.id = E_cp` with canonical control-plane artifact references.
3. explicit reindex/coherence obligations plus required commutation witness.
4. explicit cover/glue obligations for worker decomposition and merge
   compatibility.
5. explicit authority split: semantic authority remains
   `PREMATH-KERNEL`/`GATE`/`BIDIR-DESCENT`; control-plane role is projection and
   parity only.

### Rationale
This profile is consumed by runtime/checker/parity wrappers that already load
`CONTROL-PLANE-CONTRACT.json`. Keeping the bundle contract in the same typed
artifact minimizes topology while making `C_cp`/`E_cp` executable and
fail-closed through the existing loader/test surfaces.

### Consequences
- `C_cp`/`E_cp` now have one machine-checked authority surface.
- Downstream KCIR/self-hosting tasks can consume the profile without adding a
  parallel architecture spec node.
- Spec index and draft README now link the profile placement explicitly, so
  authority boundaries remain unambiguous.

---

## 2026-02-23 — Decision 0117: Canonicalize control-plane artifact mappings through `controlPlaneKcirMappings`

### Decision
Adopt one machine-readable KCIR mapping surface in
`draft/CONTROL-PLANE-CONTRACT.json` under `controlPlaneKcirMappings` with:

1. canonical mapping rows for:
   - instruction envelopes,
   - proposal payloads,
   - coherence obligations/check payloads,
   - doctrine-route bindings,
   - CI required-decision inputs.
2. deterministic identity/digest lineage bindings:
   `digestAlgorithm=sha256`, `refProfilePath=policies/ref/sha256_detached_v1.json`,
   and canonical `normalizerId` / `policyDigest` field anchors.
3. explicit legacy compatibility/deprecation policy:
   non-KCIR semantic encodings are `projection_only`, forbidden as authority,
   and bounded by a support window aligned with schema rollover epoch.

### Rationale
Control-plane mapping logic was split across wrappers and implicit conventions.
One typed mapping table gives downstream core/parity work a canonical IR boundary
without introducing a separate architecture node.

### Consequences
- Mapping drift for instruction/proposal/coherence/doctrine/decision inputs is
  now fail-closed through the control-plane contract loader/tests.
- Legacy non-KCIR encodings remain compatibility-only and cannot become a
  parallel authority path.
- Downstream KCIR self-hosting tasks can consume one canonical mapping artifact.

---

## 2026-02-23 — Decision 0118: Expand runtime-orchestration conformance with path-boundary, mapping-row, and invariance vectors

### Decision
Extend runtime-orchestration executable conformance to cover additional
control-plane bundle closure points:

1. enforce routed operation path boundary for runtime routes:
   bound doctrine operations MUST resolve under `tools/ci/*` for this checker
   surface (reject fail-closed on bypass path drift).
2. validate optional `controlPlaneKcirMappings.mappingTable` row-shape when
   present (`instructionEnvelope`, `proposalPayload`,
   `coherenceCheckPayload`, `requiredDecisionInput`, `coherenceObligations`,
   `doctrineRouteBinding`).
3. add runtime-orchestration vector coverage for:
   - mapping-row golden + adversarial rejects,
   - operation-path bypass adversarial reject,
   - profile-permuted invariance pairs with deterministic parity checks.

### Rationale
Phase-2 KCIR self-hosting closure needs executable proof that adapter boundaries
cannot drift to non-canonical paths and that optional mapping-table surfaces
stay typed when supplied. Existing route/morphism checks were necessary but not
sufficient for this boundary.

### Consequences
- Runtime-orchestration vectors now cover golden/adversarial/invariance shapes.
- Control-plane bundle closure has explicit fail-closed coverage for path
  bypass and mapping-row drift.
- Doctrine/conformance gates retain one runtime checker entrypoint while
  carrying denser boundary evidence for KCIR phase-2 closure.

---

## 2026-02-24 — Decision 0119: Complete phase-3 gate authority migration and synchronize docs/traceability surfaces

### Decision
Complete KCIR self-hosting phase-3 authority placement for CI gate execution:

1. Canonical gate authority for governance promotion and KCIR mapping checks is
   the premath core CLI command surface:
   - `premath governance-promotion-check`
   - `premath kcir-mapping-check`
2. Python CI wrappers (`tools/ci/governance_gate.py`,
   `tools/ci/kcir_mapping_gate.py`) are adapter-only transports and MUST NOT
   re-introduce normative gate semantics.
3. Runtime-orchestration + capability conformance suites include explicit
   phase-3 command-surface vectors for these gate surfaces.
4. Draft/doc index and traceability surfaces are synchronized to this authority
   placement.

### Rationale
Phase-3 required removing remaining wrapper-local gate semantics and proving the
new core-authority path with deterministic conformance evidence. Without this,
the repository risked dual authority paths (core + wrapper logic drift).

### Consequences
- Wrapper surfaces remain orchestration-compatible while normative gate
  semantics execute in one premath-native lane.
- Runtime/conformance/docs now expose the same phase-3 gate boundary
  (`governancePromotionCheck`/`kcirMappingCheck`) with deterministic failure
  classes.
- Phase-3 closure can proceed through docs/traceability completion without
  stale transition-state language on gate authority placement.

---

## 2026-02-24 — Decision 0120: Worldization docs closure with overlay-only torsor posture

### Decision
Clarify and lock the repository north-star as worldized semantic authority:

1. `README.md` and `docs/design/ARCHITECTURE-MAP.md` explicitly define
   `world == premath` and the one-lane authority split (kernel/checker
   authority vs adapter IO routing).
2. `WORLD-REGISTRY` and `WORLD-PROFILES-CONTROL` are the canonical world-route
   narrative anchors for lease/instruction/ci witness routing.
3. Torsor/extension interpretation is explicitly retained as optional
   non-authority overlay (`overlay.torsor_ext.v1`) and forbidden as direct
   route-bound admissibility authority.

### Rationale
The implementation path reached executable world-route enforcement and vector
coverage, but newcomer-facing docs still under-explained the north-star and the
overlay boundary. This increased coherence risk by leaving room for
misinterpreting overlays as parallel authority lanes.

### Consequences
- Newcomer narrative and architecture map now match executable world-route
  behavior.
- Torsor/extension usage is constrained to proposal/evidence interpretation
  surfaces with fail-closed misuse posture.
- Decision and operations lanes now carry explicit evidence for the worldization
  closure pass.

---

## 2026-02-24 — Decision 0121: Make `world-registry-check` the single world-semantics execution lane and split vector topology

### Decision
For world-route validation, adopt one executable semantic lane:

1. `premath world-registry-check` is the canonical executable world checker
   surface, including derivation of required world-route families/bindings from
   `CONTROL-PLANE-CONTRACT` host-action mappings.
2. Wrapper/runtime checker surfaces (`check_runtime_orchestration.py`) remain
   transport/format adapters and MUST NOT duplicate host-action-to-world binding
   semantics.
3. Conformance topology is split explicitly:
   - world semantic vectors live in `world-core` suite,
   - runtime-orchestration suite retains adapter/runtime-route parity vectors and
     drops duplicate world semantic vectors.

### Rationale
World semantics were partially duplicated in Python wrappers and duplicated again
in runtime vector lanes. That raised drift risk and cognitive load for newcomer
reasoning about authority placement.

### Consequences
- World-route requirement derivation now lives in one core lane
  (`world_registry_check` command implementation).
- Runtime wrappers consume core checker output and classify adapter-level
  failures without becoming authority.
- Docs/spec index/traceability surfaces can point to one canonical
  world-semantics map and a non-overlapping vector split.

---

## 2026-02-24 — Decision 0122: Adopt fiber structured-concurrency profile as transport/runtime lane (not semantic authority)

### Decision
Add a typed fiber lifecycle profile to the transport/runtime lane with:

1. new typed transport actions:
   - `fiber.spawn`
   - `fiber.join`
   - `fiber.cancel`
2. world-route binding contract:
   - `route.fiber.lifecycle -> world.fiber.v1`
   - morphism row `wm.control.fiber.lifecycle`
3. raw spec and design companion:
   - `raw/FIBER-CONCURRENCY`
   - `docs/design/FIBER-CONCURRENCY.md`

### Rationale
We need a structured-concurrency model that is stable for agent/runtime control
surfaces while keeping semantic admissibility in one kernel/Gate lane. This
separates effect-style orchestration semantics from runtime backend choice
(OTP/local/RPC) without introducing a parallel authority path.

### Consequences
- Transport registry now carries fiber lifecycle action rows in addition to
  lease lifecycle rows.
- Runtime adapters can dispatch typed fiber envelopes through one command
  surface and preserve deterministic metadata/witness references.
- World/profile docs now include `world.fiber.v1` as an operational profile
  candidate while retaining kernel/checker semantic authority boundaries.

---

## 2026-02-24 — Decision 0123: Bind fiber lifecycle transport actions into control-plane KCIR mapping table

### Decision
Extend `controlPlaneKcirMappings.mappingTable` with one canonical row:

1. `fiberLifecycleAction`
   - `sourceKind = transport.fiber.lifecycle.v1`
   - `targetDomain = kcir.node`
   - `targetKind = transport.fiber.lifecycle.witness.v1`
   - `identityFields = [actionId, semanticDigest, policyDigest]`

And update strict mapping-gate expected declared rows to include this entry.

### Rationale
Fiber transport actions were typed at the transport/world layer but not yet
declared in the canonical KCIR mapping table. Adding this row glues structured
concurrency effects to the same control-plane KCIR identity surface used by
instruction/proposal/coherence/doctrine/required-decision rows.

### Consequences
- Strict `kcir-mapping-check` remains fail-closed with the extended declared-row
  set.
- Runtime-orchestration mapping-row conformance now checks the fiber row shape.
- CI/test adapters consuming declared KCIR rows now report `7` declared rows.

---

## 2026-02-24 — Decision 0124: Add deterministic SITE-RESOLVE K0 contract for INF/SITE/WORLD routing

### Decision
Add promoted draft contract `specs/premath/draft/SITE-RESOLVE.md` and wire it
into index/traceability surfaces as the K0 resolver boundary for site-based
operation routing:

1. define canonical `SitePackage` projection shape over:
   `DOCTRINE-SITE-INPUT`, generated `DOCTRINE-SITE`,
   generated `DOCTRINE-OP-REGISTRY`, and `CONTROL-PLANE-CONTRACT`.
2. define deterministic resolver envelopes:
   - `premath.site_resolve.request.v1`
   - `premath.site_resolve.response.v1`
3. make selection order normative and fixed:
   `candidate gather -> capability/policy filter -> world-route validation -> overlap/glue decision`.
4. define deterministic tie-break and fail-closed outcomes for:
   - unbound (`site_resolve_unbound`)
   - ambiguous (`site_resolve_ambiguous`)
5. require accepted output to include stable route/site/world refs and
   projection digests suitable for KCIR authority handoff.

### Rationale
Resolver semantics were implied across doctrine-site/world-route contracts, but
not declared in one promoted contract. This created ambiguity around selection
order, ambiguity handling, and stable handoff fields. A dedicated K0 contract
reduces drift and gives upcoming implementation work one explicit authority
target.

### Consequences
- Resolver implementation work can now target one promoted contract with
  deterministic ordering and failure-class posture.
- Index and traceability surfaces include the resolver contract in the higher
  CI/CD reading path.
- World-route and doctrine-site execution lanes remain semantic authorities;
  resolver output stays projection/handoff material (no parallel admissibility
  lane).

---

## 2026-02-24 — Decision 0125: Add doctrine operation class policy contract and fail-closed route eligibility gating

### Decision
Adopt an explicit operation-class policy in doctrine-site authority input and
generated operation registry:

1. `DOCTRINE-SITE-INPUT.operationRegistry.operationClassPolicy` defines
   canonical classes:
   - `route_bound`
   - `read_only_projection`
   - `tooling_only`
2. every operation row in `operationRegistry.operations[]` MUST carry
   `operationClass`.
3. route-bound operations MUST carry `routeEligibility` metadata and MUST match
   one declared `worldRouteBindings` family.
4. non-route classes MUST remain resolver-ineligible and MUST NOT appear in
   world-route bindings.
5. doctrine-site generation/checking enforces this contract fail closed.

### Rationale
Resolver/world-route implementation needed an explicit precondition that
distinguishes route-eligible operations from read/projection and tooling lanes.
Without classed operation intent, resolver scope could drift and introduce
parallel mutation/authority behavior.

### Consequences
- doctrine operation rows are now explicitly typed by authority intent.
- route eligibility is deterministic and checker-enforced before resolver
  implementation.
- non-route classes are constrained to non-authority lanes while still allowing
  explicit tooling/mutation surfaces where intended.

---

## 2026-02-24 — Decision 0126: Make site-packages the source-of-truth for doctrine-site artifacts

### Decision
Adopt a generation-first source model for doctrine-site authorities:

1. introduce canonical authoring layout:
   - `specs/premath/site-packages/<site-id>/SITE-PACKAGE.json`
   - package kind: `premath.site_package.v1`
2. generate `draft/DOCTRINE-SITE-INPUT.json` from site-package source.
3. continue generating `draft/DOCTRINE-SITE.json` and
   `draft/DOCTRINE-OP-REGISTRY.json` from canonical site input.
4. enforce fail-closed source parity in doctrine-site checker and generator:
   tracked input/map/registry must equal generated outputs.
5. reject missing package root, missing package file, duplicate package file, and
   package/input/class/world-route drift.

### Rationale
Authoring was still effectively split across generated and hand-maintained
artifacts. Making site-package source explicit reduces topology sprawl and
ensures one deterministic authoring lane for resolver/world-route preparation.

### Consequences
- doctrine-site generation/checking now includes input parity enforcement from
  package source.
- manual edits to generated input/map/registry are rejected as drift.
- resolver follow-on implementation can consume a deterministic site-package ->
  site-input -> generated-artifact flow.

---

## 2026-02-24 — Decision 0127: Add deterministic doctrine generation digest contract and fail-closed guardrail

### Decision
Add and enforce one digest authority artifact:

- `specs/premath/draft/DOCTRINE-SITE-GENERATION-DIGEST.json`
  (`premath.doctrine_site_generation_digest.v1`)

The generator/checker contract now requires:

1. `generate_doctrine_site.py` writes and checks digest rows for:
   - generated site input
   - generated doctrine site map
   - generated doctrine operation registry
2. `check_doctrine_site.py` validates tracked digest contract parity against
   generated outputs.
3. `docs-coherence-check` validates digest contract shape and digest parity
   against canonical artifact digests.

### Rationale
Generation parity checks detect drift, but a dedicated digest contract gives one
small, auditable guardrail artifact that can be consumed by CI/docs surfaces
without re-deriving generation topology from prose.

### Consequences
- doctrine generated artifacts are now protected by both roundtrip parity and an
  explicit digest contract.
- manual drift in generated artifacts or digest rows fails closed in doctrine and
  docs coherence gates.

---

## 2026-02-24 — Decision 0128: Cut over doctrine-site authority to generated-only lane with explicit migration contract

### Decision
Adopt and enforce one deterministic migration/cutover contract:

- `specs/premath/draft/DOCTRINE-SITE-CUTOVER.json`
  (`premath.doctrine_site_cutover.v1`).

Contract requirements:

1. include one bounded compatibility window phase with explicit
   `windowStartDate`/`windowEndDate`,
2. include one cutover phase with explicit `effectiveFromDate`,
3. select active behavior via deterministic `currentPhaseId`,
4. when active phase disables legacy/manual lanes, reject:
   - legacy `sourceKind` fallback authority input,
   - operation-registry override authority injection.

Repository posture in this decision:

- active phase is `generated_only` (effective `2026-02-24`),
- compatibility/manual lanes are fail-closed.

### Rationale
Generation-first source-of-truth was in place, but legacy loader paths still
allowed manual/global authority fallbacks. A deterministic cutover contract
turns migration posture into an auditable artifact and removes parallel
authority ambiguity.

### Consequences
- doctrine-site generation/check surfaces now require and enforce cutover
  contract posture.
- legacy/manual authority paths are hard-rejected under active generated-only
  phase.
- docs/spec/conformance surfaces now expose one bounded migration story with a
  concrete cutoff point.

---

## 2026-02-25 — Decision 0129: Declare explicit Grothendieck constructor authority for control-plane worldization

### Decision
Adopt constructor-first authority posture for control-plane worldization and
make it explicit across promoted contracts:

1. `WORLD-REGISTRY` now declares one explicit constructor object shape for
   active profiles (`premath.world_grothendieck_constructor.v1`) and requires
   deterministic derivation from:
   - world registry rows,
   - doctrine-site input + operation registry rows,
   - control-plane contract bindings.
2. `DOCTRINE-SITE` now declares total, unambiguous operation-to-route binding
   as constructor-input contract (route-bound totality, non-route exclusion,
   deterministic fail-closed posture).
3. `PREMATH-COHERENCE` now states constructor-first check-role authority:
   wrappers and fixture runners are replay/parity/orchestration lanes only.
4. `UNIFICATION-DOCTRINE` now links §12 operationalization to explicit
   constructor materialization and overlay non-authority rules.
5. `SPEC-INDEX` and traceability matrix now reflect constructor-first
   worldization as a non-negotiable architectural invariant.

### Rationale
The architecture already operated as a Grothendieck-style bundle over
context-indexed world routes, but the constructor object and total-binding
contract were only implicit across multiple files. Making this explicit reduces
ambiguity, prevents wrapper/fixture semantic drift, and gives implementation a
single authority target.

### Consequences
- Implementation can converge on one constructor authority lane in core
  (`premath-kernel`/`premath-coherence`) without parallel semantics in Python
  or fixture runners.
- Route/world/evidence failures now map cleanly to deterministic unbound /
  ambiguity / morphism-drift classes in one boundary story.
- Torsor extension surfaces remain expressiveness overlays only and cannot
  become authority targets.

---

## 2026-02-25 — Decision 0130: Reconcile topology-budget thresholds with promoted draft/spec traceability cardinality

### Decision
Adjust topology-budget thresholds for two cardinality metrics to match the
current promoted baseline while preserving fail-closed pressure against further
topology growth:

1. `draftSpecNodes`: `warnAbove` 32 -> 34, `failAbove` 34 -> 36
2. `specTraceabilityRows`: `warnAbove` 32 -> 34, `failAbove` 34 -> 36

No other topology budget metrics are changed.

### Rationale
Repository baseline gates were failing on `topology_budget_drift` solely because
the promoted draft set and traceability matrix reached 36 rows while the budget
still hard-failed above 34. This update removes stale-budget false negatives
without weakening discipline: current cardinality now sits at the fail boundary
and remains warning/fail sensitive to the next increments.

### Consequences
- `ci-drift-budget-check` and `baseline` no longer fail on current promoted
  cardinality alone.
- Topology pressure remains explicit:
  - warning pressure starts above 34,
  - fail-closed posture starts above 36.
- Future spec promotions still require either topology reduction or explicit,
  decision-logged budget adjustment.

---

## 2026-02-25 — Decision 0131: Reduce doctrine-site source topology by pruning derivable LLM link edges

### Decision
Reduce doctrine-site edge topology by removing seven source edges from
`SITE-PACKAGE` that duplicated connectivity already implied by generated
operation bindings and required doctrine/control checks:

1. `e.doctrine.llm_instruction`
2. `e.doctrine.llm_proposal`
3. `e.ci.llm_instruction`
4. `e.ci.llm_proposal`
5. `e.llm_instruction.llm_proposal`
6. `e.llm_proposal.bidir`
7. `e.llm_instruction.op.run_instruction`

Regenerated artifacts are authoritative (`DOCTRINE-SITE-INPUT`,
`DOCTRINE-SITE`, generation digest, and generated inventory).

### Rationale
`doctrineSiteEdgeCount` exceeded the warning budget due to redundant source
edges that were not required for operation reachability, route/world parity, or
MCP/doctrine control-plane checks. Keeping only canonical source connectivity
plus generated operation edges preserves semantics while lowering topology load.

### Consequences
- doctrine-site topology is reduced from 72 edges to 65 edges.
- drift-budget warning for `doctrineSiteEdgeCount` is cleared without changing
  thresholds.
- doctrine/control checks remain green with no operation-registry parity loss.

---

## 2026-02-25 — Decision 0132: Exclude index/traceability control docs from promoted draft topology count

### Decision
Reclassify `specs/premath/draft/SPEC-INDEX.md` and
`specs/premath/draft/SPEC-TRACEABILITY.md` as informational control documents
(`status: informational`) rather than promoted draft spec nodes.

To keep traceability parity consistent with promoted draft detection, remove
their matrix rows from `SPEC-TRACEABILITY`.

### Rationale
These two documents govern navigation and coverage reporting for promoted draft
specs, but they are not semantic contract authorities in the same class as the
draft specs they index. Counting them as promoted nodes created avoidable
topology warning pressure without increasing semantic coverage.

### Consequences
- `draftSpecNodes` and `specTraceabilityRows` drop by 2 (36 -> 34), clearing
  warning pressure without threshold changes.
- `check_spec_traceability.py` parity remains exact because promoted draft set
  and matrix rows are reduced together.
- semantic authority scope is unchanged; only control-doc classification is
  tightened.

---

## 2026-02-25 — Decision 0133: Adopt explicit WDAC-1 architecture contract for world-descent execution order

### Decision
Adopt `WDAC-1` in `docs/design/ARCHITECTURE-MAP.md` as the canonical
architecture contract for world descent, with explicit lane ownership and
execution order.

`WDAC-1` defines:

1. lane ownership boundaries across semantic, constructor, check-role, and
   wrapper lanes,
2. no-parallel-authority constraints for wrapper/adapter surfaces,
3. architecture-first execution order for world-descent epics:
   architecture -> spec/index+doctrine glue -> control-plane parity ->
   implementation -> conformance -> docs closure.

The design onboarding surface (`docs/design/README.md`) now links directly to
`ARCHITECTURE-MAP` §0.1 before downstream spec-chain reading.

### Rationale
World-descent constraints existed across specs and runbooks, but the
architecture-level contract and sequencing were implicit. Making WDAC-1
explicit reduces planning drift, keeps execution order stable across sessions,
and prevents wrapper lanes from reintroducing parallel authority semantics.

### Consequences
- New world-descent work is anchored to one explicit architecture contract.
- Docs now provide a single first stop for authority boundaries and ordering.
- Spec and implementation slices remain linked to the same lane map, reducing
  ambiguity during issue decomposition and review.

---

## 2026-02-25 — Decision 0134: Migrate traceability matrix validation to checker-native CLI surface

### Decision
Move promoted draft traceability matrix validation from Python script surface
to native checker command surface:

1. Add `premath spec-traceability-check` as the canonical validator for
   `specs/premath/draft/SPEC-TRACEABILITY.md` parity against promoted draft set.
2. Rewire `mise run traceability-check` to execute only the CLI checker.
3. Remove `tools/conformance/check_spec_traceability.py` from active command
   surface.

### Rationale
Traceability parity is deterministic checker logic and belongs on the same
native command surface as other migrated CI/control checks. Keeping it in Python
adds avoidable semantic split and extra command-surface cognitive load.

### Consequences
- traceability validation now runs through one checker-native command boundary.
- baseline/task wiring no longer depends on a dedicated Python entrypoint for
  this check family.
- docs and traceability references now point to `premath spec-traceability-check`
  as the active command surface.

---

## 2026-02-25 — Decision 0135: Migrate branch-policy validation to checker-native CLI surface

### Decision
Move GitHub branch/ruleset policy validation from Python script surface to
native checker command surface:

1. Add `premath branch-policy-check` as the canonical command for policy
   contract validation against fixture or live GitHub rules payloads.
2. Rewire:
   - `mise run ci-branch-policy-check`
   - `mise run ci-branch-policy-check-live`
   to execute the CLI checker.
3. Remove legacy Python branch-policy checker/test entrypoints from active task
   surface.

### Rationale
Branch-policy enforcement is a governance checker concern and should share the
same command-surface authority model as other migrated CI/control checks.
Consolidating this removes one more Python-only semantic lane and reduces
surface drift risk.

### Consequences
- branch-policy fixture validation and live-server drift checks now route
  through one checker-native CLI boundary.
- `ci-pipeline-test` now exercises branch-policy via CLI smoke test
  (`branch_policy_check_json_smoke`) rather than Python unit test lane.
- repository branch-policy checker surface aligns better with minimum encoding /
  maximum expressiveness posture.

---

## 2026-02-25 — Decision 0136: Route doctrine MCP parity check through checker-native CLI

### Decision
Move doctrine MCP operation parity checking to checker-native CLI and wire
`doctrine-check` task through that surface:

1. add `premath doctrine-mcp-parity-check` for deterministic MCP tool coverage
   + morphism classification parity checks,
2. rewire `mise run doctrine-check` to execute the CLI command instead of the
   Python checker for this family,
3. update `docs-coherence` expected doctrine-check command list and pipeline
   smoke coverage to checker-native command surface.

### Rationale
MCP doctrine parity is a control/doctrine checker concern and should live on the
same CLI authority surface as other migrated checks. This reduces one more
semantic Python lane while preserving deterministic parity behavior.

### Consequences
- doctrine-check now executes runtime-orchestration + MCP parity through
  `premath-cli` command surfaces.
- `ci-pipeline-test` doctrine parity coverage now uses
  `doctrine_mcp_parity_check_json_smoke`.
- legacy Python checker file can remain temporarily as a compatibility/path
  reference lane, but active enforcement route is checker-native.

---

## 2026-02-27 — Decision 0137: Make instruction runtime routing explicit and transport-first

### Decision
Tighten control-plane routing authority for instruction execution:

1. Define `runtimeRouteBindings.requiredOperationRoutes.runInstruction` in
   `draft/CONTROL-PLANE-CONTRACT.json` with explicit
   `routeFamilyId=route.instruction_execution`,
   `operationId=op/ci.run_instruction`, and required morphisms.
2. Make `hostActionSurface.requiredActions["instruction.run"].canonicalCli`
   transport-first:
   `premath transport-dispatch --action instruction.run --payload '<json>' --json`.
3. Update doctrine world-descent requirement derivation to honor per-runtime-route
   `routeFamilyId` (defaulting to `route.gate_execution` only when absent),
   rather than forcing all runtime routes into `route.gate_execution`.

### Rationale
Without explicit per-route family mapping, adding instruction runtime routing to
`runtimeRouteBindings` produced a false world-route obligation on
`route.gate_execution`. Declaring route family at the runtime-route row and
routing `instruction.run` through transport keeps architecture intent explicit:
runtime routes map to their world families, adapters remain thin, and doctrine
checks enforce the intended shape.

### Consequences
- runtime-orchestration checks now validate three runtime routes explicitly:
  `runGate`, `runGateTerraform`, and `runInstruction`.
- world-route derivation no longer conflates instruction execution with gate
  execution when runtime routes are expanded.
- host-action command mapping for `instruction.run` now matches the active
  transport-dispatch execution boundary.
