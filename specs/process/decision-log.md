# Decision Log

This log records decisions that intentionally constrain future changes.

---

## 2026-02-19 — Decision 0001: Premath Kernel bundle commitment ("v0.1")

### Decision
We commit to a **profile-preserving** specification structure:

1. **Kernel stays minimal and ontology-agnostic.**
   - The normative kernel is `draft/PREMATH-KERNEL`.
   - Definability is **behavior**: coherent reindexing + locality + **contractible descent** on the Grothendieck topology generated by the declared coverage.
   - The kernel does **not** hardcode a semantic universe (Set/Gpd/∞-groupoids). It is parameterized by an ambient sameness level `V` with a chosen notion of equivalence `≈`.

2. **Backend-generic binding is a first-class seam.**
   - Reference binding is delegated to profiles via `project_ref` / `verify_ref` (see `draft/REF-BINDING`).
   - Kernel and opcode contracts MUST be phrased in terms of canonical bytes + `project_ref`, never a specific hash function.

3. **Operational totality is expressed via normalization + obligation discharge.**
   - `draft/NORMALIZER` and `draft/BIDIR-DESCENT` are part of the baseline "full" story.
   - In `normalized` mode, equality is **only** reference equality on normalized comparison refs (`cmpRef`).

4. **Gemini-style ∞-topos framing is adopted only as a semantics profile / optional dial.**
   - `raw/SEMANTICS-INFTOPOS` is informational (model-theoretic).
   - `raw/HYPERDESCENT`, `raw/UNIVERSE`, and `raw/SPLIT-PRESENTATION` are optional capabilities/extensions.

### Rationale
This locks in the original intent: **Premath is a definability gate (a linter), not a foundation**.

We still gain reviewer-facing strength by providing a canonical ∞-topos semantics profile and optional "final dial" extensions, without forcing those commitments on all constructors/backends.

### Consequences
- Future work that strengthens coherence (hypercovers), adds universes/comprehension, or requires strict presentations MUST be introduced as explicit capabilities/extensions.
- The next engineering step is no longer "define definability"; it is to build **running code + vectors** for the baseline bundle.

### Next milestone (binding)
Milestone M1: a conformance suite + at least one reference verifier implementation that:

- computes `project_ref` for at least one backend profile,
- normalizes NF deterministically and compares by `cmpRef`,
- emits and discharges Gate obligations deterministically.

---

## 2026-02-19 — Decision 0002: Proof-carrying overlap + cocycle witnesses

### Decision
We standardize an **optional Gate-witness seam** for descent checks:

- `O_ASSERT_OVERLAP` (OBJ opcode `0x05`): certifies pairwise overlap compatibility.
- `O_ASSERT_TRIPLE`  (OBJ opcode `0x06`): certifies triple-overlap coherence ("cocycle" check).

Both opcodes return `Unit` and are parameterized by the active constructor's restriction + equality.

### Rationale
This makes descent **trace-internal**: the Gate does not need to recompute overlap constraints from scratch,
and implementations can move overlap checks into a verified certificate layer.

### Consequences
- These opcodes are OPTIONAL in the raw kernel: they are a certified seam, not a mandatory feature.
- They enable incremental hardening: later work can add proof-carrying *uniqueness/contractibility* witnesses
  beyond brute-force enumeration.

---

## 2026-02-20 — Decision 0003: Contractible gluing as a proof-scheme hook

### Decision
We standardize an **optional Gate-witness seam** for stack-safe uniqueness / contractible gluing that is
explicitly **proof-scheme driven**:

- `O_ASSERT_CONTRACTIBLE` (OBJ opcode `0x07`) takes:
  - `schemeId: Bytes32` (opaque label), and
  - `proofBytes: bytes` (opaque payload)

and certifies that the glue space for a descent datum is **contractible** at the constructor’s sameness level.

Unsupported `schemeId` values MUST be rejected deterministically.

### Rationale
The kernel requires *contractibility* (stack-safe uniqueness), but does not prescribe how to prove it.
In engineering settings, brute-force enumeration is sometimes acceptable (toy models), but production
settings may require compressed proofs (e.g. RLNC decoding, lattice/norm arguments, solver certificates).

Making contractibility verification scheme-driven preserves:

- **backend agnosticism** (no hardcoded cryptography), and
- **proof agnosticism** (no forced proof system),

while still allowing KCIR traces to carry their own uniqueness certificates.

### Consequences
- The toy suite may implement a default scheme (e.g. `toy.enumerate.v1`) purely for determinism.
- Production backends can adopt additional `schemeId` values without changing kernel law text.

---

## 2026-02-20 — Decision 0004: First promotion batch from raw to draft

### Decision
Promote the governance/conformance spine to `draft` status:

- `draft/SPEC-INDEX`
- `draft/CONFORMANCE`
- `draft/CAPABILITY-VECTORS`
- `draft/CHANGE-MORPHISMS`

These remain under `specs/premath/raw/` path for link stability; authoritative
status is the front-matter `status` field.

### Rationale
These documents now define the invariant closure contract used by implementation
and CI:

- profile-invariant kernel/Gate outcomes,
- explicit optional capability claims,
- canonical change-morphism discipline.

Promoting this layer first reduces process ambiguity while keeping technical
surface area controlled.

### Consequences
- Future changes in this layer are expected to behave as draft contracts between
  editor and implementers.
- Conformance and fixture scaffolding for these capabilities are now part of the
  expected running-code discipline.

---

## 2026-02-20 — Decision 0005: Semantic-core promotion from raw to draft

### Decision
Promote the semantic-core contract files to `draft` status:

- `draft/PREMATH-KERNEL`
- `draft/GATE`
- `draft/BIDIR-DESCENT`
- `draft/WITNESS-ID`

Files remain in `specs/premath/raw/` for stable path references; normative
status is the front-matter field.

### Rationale
These files are the load-bearing semantic contract for runtime invariance:

- kernel laws,
- admissibility gate classes,
- operational discharge model,
- deterministic witness identity.

Promoting this batch aligns process state with current implementation and vector
usage, and reduces ambiguity about contract maturity.

### Consequences
- Changes to these specs should now be treated as draft-contract changes and be
  paired with vector/runtime evidence.
- Remaining raw specs can be promoted in later focused batches.

---

## 2026-02-20 — Decision 0006: Interop-core promotion and KCIR core rename

### Decision
Promote the Interop Core contract files to `draft` status:

- `draft/KCIR-CORE` (renamed from legacy id `KCIR-V2-CORE`)
- `draft/NF`
- `draft/REF-BINDING`
- `draft/WIRE-FORMATS`
- `draft/ERROR-CODES`

Rename spec identity from `KCIR-V2-CORE` to `KCIR-CORE` across references.

### Rationale
This batch stabilizes the interop artifact boundary and removes version-biased
naming in the core model reference for greenfield evolution.

### Consequences
- Dependencies and cross-spec references now target `draft/KCIR-CORE`.
- Conformance/interop reading orders now resolve through the renamed core spec.
- Remaining `v2` labels outside this core reference are informational/versioned
  naming and can be migrated separately if desired.

---

## 2026-02-20 — Decision 0007: Draft specs moved to `specs/premath/draft/`

### Decision
Move all promoted draft specs out of `specs/premath/raw/` into
`specs/premath/draft/`.

### Rationale
Directory semantics should match lifecycle semantics:

- `raw/` for experimentation and informational material,
- `draft/` for active contract specs.

This removes ambiguity about normative authority and improves navigation.

### Consequences
- Internal references for promoted specs now use `draft/<SPEC>`.
- `raw/README.md` is narrowed to raw-only scope.
- `draft/README.md` becomes the contract entry point for promoted specs.

---

## 2026-02-20 — Decision 0008: Process docs moved to `specs/process/`

### Decision
Move process governance docs out of `specs/premath/process/` into:

- `specs/process/coss.md`
- `specs/process/decision-log.md`

### Rationale
Process policy applies across the Premath spec lifecycle and should not appear
as a subtype of one lifecycle bucket (`premath/`).

Placing process at `specs/process/` clarifies authority and reduces path
ambiguity in promoted draft/raw specs.

### Consequences
- Draft/raw spec front matter now points to `../../process/coss.md`.
- Repository-level references now use `specs/process/decision-log.md`.

---

## 2026-02-20 — Decision 0009: Add raw operational stack specs (`TUSK`, `SQUEAK`, `CI`)

### Decision
Publish the current operational architecture as raw specs:

- `raw/TUSK-CORE`
- `raw/SQUEAK-CORE`
- `raw/CI-TOPOS`

and index them from:

- `raw/V2-SPECS`
- `draft/SPEC-INDEX` (informative-only references)

### Rationale
We need a documented operational boundary while preserving kernel stability:

- `tusk-core` captures single-world execution contracts,
- `squeak-core` captures inter-world transport contracts,
- `ci-topos` captures closure-style conformance gating.

Keeping this layer raw allows iteration without prematurely hardening runtime
interfaces as conformance requirements.

### Consequences
- The kernel/draft conformance surface remains unchanged.
- KCIR remains optional capability/evidence machinery, not a kernel dependency.
- Promotion of operational specs to draft requires dedicated vectors and
  conformance claims.

---

## 2026-02-21 — Decision 0010: Doctrine-to-operation site map and checker

### Decision
Add a draft, machine-checkable doctrine-to-operation site contract:

- `specs/premath/draft/DOCTRINE-SITE.md`
- `specs/premath/draft/DOCTRINE-SITE.json`

and enforce it with:

- `tools/conformance/check_doctrine_site.py`
- `mise run doctrine-check`

Baseline gates now include doctrine-site validation.

### Rationale
We need an explicit path from meta-doctrine (`DOCTRINE-INF`) to operational
entrypoints (`tools/ci/*`, `tools/conformance/*`) so architecture drift is
auditable and detectable.

The site map makes this path concrete as nodes/covers/edges and binds edge
morphism IDs to declared preservation contracts.

### Consequences
- Declaration-bearing specs must stay coherent with the site map.
- Operational gate entrypoints must remain reachable from doctrine root.
- Refactors touching doctrine declarations, site map, or gate tooling are now
  expected to pass the doctrine-site checker in baseline CI.

---

## 2026-02-21 — Decision 0011: Add LLM instruction doctrine contract

### Decision
Add a draft doctrine contract for typed LLM instruction handling:

- `specs/premath/draft/LLM-INSTRUCTION-DOCTRINE.md`

and map it into the doctrine-to-operation site:

- `specs/premath/draft/DOCTRINE-SITE.json`

### Rationale
Instruction-envelope execution is already operational in this repository
(`tools/ci/run_instruction.sh` + CI witness output), but it needed explicit
doctrine constraints for:

- typed vs unknown instruction classification,
- authority split (LLM proposal vs kernel/runtime admissibility),
- deterministic instruction-to-witness binding.

### Consequences
- Higher-order CI/CD reading order now includes `draft/LLM-INSTRUCTION-DOCTRINE`.
- Doctrine-site coherence checks now include instruction doctrine nodes/edges.
- Instruction tooling remains execution surface only; semantic authority remains
  in kernel/runtime layers.

---

## 2026-02-21 — Decision 0012: Add executable instruction-typing capability vectors

### Decision
Promote instruction typing checks into executable capability conformance with:

- capability id: `capabilities.instruction_typing`
- vectors under:
  `tests/conformance/fixtures/capabilities/capabilities.instruction_typing/`
- runner support in:
  `tools/conformance/run_capability_vectors.py`

### Rationale
The instruction doctrine requires explicit `typed(kind)` / `unknown(reason)`
classification and deterministic handling. We need executable vectors to keep
this behavior regression-resistant and profile-invariant.

### Consequences
- `python3 tools/conformance/run_capability_vectors.py` now executes instruction
  typing vectors by default.
- Fixture/invariance stub checks now include this capability track.
- Claim surfaces (`SPEC-INDEX`, `CAPABILITY-VECTORS`, `CONFORMANCE`) now
  include `capabilities.instruction_typing`.

---

## 2026-02-21 — Decision 0013: Wire instruction doctrine into runtime witness flow

### Decision
Extend `tools/ci/run_instruction.py` to enforce doctrine-level instruction
classification at runtime:

- classify each envelope as `typed(kind)` or `unknown(reason)`,
- reject `unknown(reason)` when `typingPolicy.allowUnknown` is false,
- emit `instructionClassification` and `typingPolicy` in CI witness artifacts.

### Rationale
Doctrine and conformance capability checks were in place, but the operational
instruction runner did not yet surface classification in runtime artifacts.
This closes the spec-to-operation loop.

### Consequences
- instruction witness records now carry explicit typing metadata.
- unroutable unknown instructions fail deterministically before gate execution.
- instruction envelope examples/documentation now include optional typing fields.

---

## 2026-02-21 — Decision 0014: Collapse capability IDs to minimal canonical set

### Decision
Align executable capability IDs with the draft governance vocabulary by
collapsing aliases:

- `capabilities.change_projection` -> `capabilities.change_morphisms`
- `capabilities.ci_required_witness` -> `capabilities.ci_witnesses`

The executable conformance surface now uses:

- `capabilities.normal_forms`
- `capabilities.kcir_witnesses`
- `capabilities.commitment_checkpoints`
- `capabilities.squeak_site`
- `capabilities.ci_witnesses`
- `capabilities.instruction_typing`
- `capabilities.change_morphisms`

### Rationale
Governance drift appeared when runtime/docs used capability IDs not present in
`draft/CAPABILITY-VECTORS` and `draft/CONFORMANCE`. We prefer minimal encoding:
one canonical identifier per capability claim unless expansion is explicitly
promoted as new doctrine.

### Consequences
- `tools/conformance/run_capability_vectors.py` defaults are now canonical and
  draft-aligned.
- capability fixtures were merged/renamed to match canonical IDs.
- docs and command-surface references now use the canonical capability names.

---

## 2026-02-21 — Decision 0015: Introduce explicit profile-overlay lane (`specs/premath/profile`)

### Decision
Add an explicit profile-overlay lane under `specs/premath/profile/` and treat
overlay specs as:

- additive to base draft claims,
- normative only when explicitly claimed,
- required to compile into deterministic checker/discharge behavior.

Initial overlay adopted in-repo:

- `profile/ADJOINTS-AND-SITES`

`draft/SPEC-INDEX` is updated to include:

- profile-overlay claim guidance,
- normative scope for claimed overlays,
- a reading order for adjoints-and-sites implementation.

### Rationale
We need a place for mathematically stronger but optional structures (for example
adjoint/Beck-Chevalley overlays) without inflating baseline kernel obligations.

This keeps the kernel small while allowing policy-scoped strengthening that is
auditable and capability-claim driven.

### Consequences
- Base kernel and existing capability claims remain unchanged unless an overlay
  is explicitly claimed.
- Future overlays should land in `specs/premath/profile/` and wire through
  `draft/SPEC-INDEX` and conformance claims.
- Overlay work should avoid duplicating semantic authority in orchestration
  layers; checker/discharge remains the authority boundary.

---

## 2026-02-22 — Decision 0016: Pre-execution instruction failures MUST emit typed reject witnesses

### Decision
Instruction-envelope execution now emits first-class reject witness artifacts
when validation fails before check execution (schema/shape, policy allowlist,
proposal binding):

- witness kind remains `ci.instruction.v1`,
- verdict is `rejected`,
- `rejectStage` is `pre_execution`,
- `failureClasses` are deterministic typed classes.

Provider-neutral instruction pipeline behavior is updated so validation failures
still produce these artifacts rather than returning only stderr/exit status.

### Rationale
The control plane needs one auditable witness surface for both runtime check
failures and pre-execution admission failures. Without this, invalid envelopes
create blind spots in observation and multiagent coordination.

### Consequences
- `tools/ci/run_instruction.py` now writes reject witnesses on invalid envelopes.
- `tools/ci/pipeline_instruction.py` now ensures invalid-envelope runs still
  emit witness artifacts.
- CI witness conformance now includes reject-witness determinism checks for
  failure-class stability.

---

## 2026-02-22 — Decision 0017: Add executable adjoints/sites capability vectors

### Decision
Introduce executable capability claim `capabilities.adjoints_sites` for the
`profile/ADJOINTS-AND-SITES` overlay with vectors that enforce deterministic
obligation compilation/discharge bound to `(normalizerId, policyDigest)`.

The executable surface now checks obligations for:

- `adjoint_triangle`
- `beck_chevalley_sigma`
- `beck_chevalley_pi`
- `refinement_invariance`

### Rationale
The profile overlay existed as normative text but had no executable claim
surface. This left adjoint/site coherence behavior outside the conformance loop.
Adding vectors keeps overlay claims auditable and regression-resistant.

### Consequences
- `tools/conformance/run_capability_vectors.py` now runs
  `capabilities.adjoints_sites`.
- Conformance fixtures now include golden/adversarial/invariance vectors for
  adjoint/site obligations.
- `draft/CAPABILITY-VECTORS`, `draft/CONFORMANCE`, and `draft/SPEC-INDEX`
  now include the new capability claim semantics.

---

## 2026-02-22 — Decision 0018: Enforce capability-gated instruction-linked issue mutations

### Decision
Strengthen MCP `instruction-linked` mutation policy for issue/dep writes:

- instruction witness must be `accepted`,
- instruction witness must carry `policyDigest` in an allowed mutation scope,
- instruction witness must carry capability claims including:
  - base: `capabilities.change_morphisms`
  - per-action claim (or wildcard `capabilities.change_morphisms.all`)

Action claims are enforced for:
`issue.add`, `issue.update`, `issue.claim`, `issue.discover`, and `dep.add`.

### Rationale
Instruction linkage by presence alone is too permissive. Mutation authorization
must be capability-scoped and policy-scoped so agents cannot mutate long-running
work memory outside declared boundaries.

### Consequences
- `crates/premath-cli/src/commands/mcp_serve.rs` now enforces capability and
  policy gating on instruction-linked mutations.
- instruction witness links now expose `capabilityClaims`.
- instruction runner/checker surfaces now validate/carry optional
  `capabilityClaims` fields.

---

## 2026-02-22 — Decision 0019: Introduce deterministic multiagent claim-lease protocol

### Decision
Extend issue mutation surface with deterministic lease lifecycle semantics:

- `issue.claim` now binds claim ownership to a lease tuple
  (`lease_id`, owner, expiry),
- add `issue.lease_renew` and `issue.lease_release` mutations,
- add `issue.lease_projection` read model for deterministic stale/contended
  lease classification.

Lease-contention and lease-lifecycle failures are typed with deterministic
failure classes (for example `lease_contention_active`, `lease_stale`,
`lease_owner_mismatch`, `lease_id_mismatch`).

### Rationale
Instruction-scoped mutation authorization was in place, but concurrent agents
still needed deterministic coordination primitives to avoid implicit work
stealing and long-running claim drift. A lease protocol narrows operational
degrees of freedom while preserving explicit handoff/renew flows.

### Consequences
- `premath-bd` issue schema now includes first-class lease state.
- MCP mutation surface includes renew/release actions and lease projection.
- `capabilities.change_morphisms` executable vectors now cover lease claim
  transitions, renew/release lifecycle transitions, active-contention rejects,
  and stale/contended projection invariants.

---

## 2026-02-22 — Decision 0020: Adopt draft spec traceability matrix with explicit coverage targets

### Decision
Adopt `draft/SPEC-TRACEABILITY` as the canonical matrix mapping promoted draft
specs to executable conformance/check surfaces.

The matrix introduces explicit status classes:

- `covered`
- `instrumented`
- `gap`

and requires every `gap` row to reference a concrete target ID.

### Rationale
Conformance vectors were strong for capability claims, but coverage boundaries
for several promoted draft specs were implicit and distributed across docs/tests.

A single traceability surface reduces planning drift, makes gaps explicit, and
gives issue discovery a deterministic source of truth.

### Consequences
- `draft/SPEC-TRACEABILITY` is now part of promoted draft documentation and is
  linked from `draft/README`, `draft/SPEC-INDEX`, and `draft/CONFORMANCE`.
- current explicit targets include:
  - `T-IC-01` (interop-core executable vectors),
  - `T-GATE-01` (canonical gate vectors),
  - `T-WID-01` (witness-id conformance vectors),
  - `T-DINF-01` (doctrine-inf semantic coverage upgrade),
  - `T-KERNEL-01` (cross-model kernel vector profile),
  - `T-INDEX-01` (index/traceability integrity check).

---

## 2026-02-22 — Decision 0021: Execute T-IC-01 with first-class interop-core vectors

### Decision
Implement and merge executable Interop Core vector coverage under
`tests/conformance/fixtures/interop-core/` with deterministic runner
`tools/conformance/run_interop_core_vectors.py`, and wire it into
`mise run conformance-run`.

Covered slices:

- `draft/KCIR-CORE` (domain table minimum),
- `draft/REF-BINDING` (projection + verify digest/profile/domain semantics),
- `draft/NF` (ObjNF/MorNF parser contracts, including `PullAtom` claim gate),
- `draft/WIRE-FORMATS` (registered wire parse behavior),
- `draft/ERROR-CODES` (registry membership checks).

### Rationale
`T-IC-01` was the largest explicit traceability gap for promoted draft specs.
Closing it converts Interop Core from mostly indirect instrumentation into a
deterministic vectored surface in merge-gated conformance runs.

### Consequences
- `mise run conformance-run` now executes interop-core vectors before capability
  vectors.
- `draft/SPEC-TRACEABILITY` rows for `KCIR-CORE`, `REF-BINDING`, `NF`,
  `WIRE-FORMATS`, and `ERROR-CODES` move to `covered`.
- Remaining open coverage upgrades continue under `T-GATE-01`, `T-WID-01`,
  `T-DINF-01`, `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0022: Execute T-GATE-01 with canonical gate vectors

### Decision
Implement and merge executable Gate vectors under
`tests/conformance/fixtures/gate/` with deterministic runner
`tools/conformance/run_gate_vectors.py`, and wire it into
`mise run conformance-run`.

Covered gate-law classes:

- `stability_failure` (`GATE-3.1`)
- `locality_failure` (`GATE-3.2`)
- `descent_failure` (`GATE-3.3`)
- `glue_non_contractible` (`GATE-3.4`)

### Rationale
`GATE` coverage previously depended on unit/toy paths without a canonical
conformance fixture suite in `tests/conformance/fixtures/gate/`. This made the
traceability target `T-GATE-01` an explicit open gap.

### Consequences
- `mise run conformance-run` now executes gate vectors in addition to interop
  and capability vectors.
- `draft/SPEC-TRACEABILITY` marks `GATE.md` as `covered`.
- Open traceability upgrades now continue under `T-WID-01`, `T-DINF-01`,
  `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0023: Execute T-WID-01 with witness-id conformance vectors

### Decision
Implement and merge executable Witness-ID vectors under
`tests/conformance/fixtures/witness-id/` with deterministic runner
`tools/conformance/run_witness_id_vectors.py`, and wire it into
`mise run conformance-run` through the fixture-suite runner.

Covered Witness-ID requirements:

- stability under excluded-field variation (`message`, `sources`, `details`),
- sensitivity to canonical witness-key fields (`class`, `lawRef`, `tokenPath`,
  `context`),
- deterministic witness-id computation for fixed key material.

### Rationale
`WITNESS-ID.md` was only instrumented via unit tests. `T-WID-01` required a
first-class conformance vector suite in the merge-gated conformance surface so
determinism/sensitivity behavior is validated at fixture level.

### Consequences
- `mise run conformance-run` now executes witness-id vectors alongside interop,
  gate, and capability suites.
- `draft/SPEC-TRACEABILITY` marks `WITNESS-ID.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01`, `T-KERNEL-01`, and
  `T-INDEX-01`.

---

## 2026-02-22 — Decision 0024: Execute T-INDEX-01 with deterministic traceability matrix check

### Decision
Implement and merge deterministic traceability matrix integrity validation via
`tools/conformance/check_spec_traceability.py`, and wire it into
`mise run baseline` as `mise run traceability-check`.

Coverage checks enforce:

- every promoted draft spec under `specs/premath/draft/` appears exactly once
  in `draft/SPEC-TRACEABILITY`,
- matrix status classes are restricted to `covered|instrumented|gap`,
- `gap` rows require concrete target IDs (`T-*-*`),
- no matrix rows reference unknown draft specs.

### Rationale
`SPEC-INDEX`/traceability coverage was previously instrumentation-by-convention.
`T-INDEX-01` required a deterministic executable surface to prevent drift
between promoted draft spec inventory and matrix rows.

### Consequences
- `mise run baseline` now includes `mise run traceability-check`.
- `draft/SPEC-TRACEABILITY` marks `SPEC-INDEX.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01` and `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0025: Execute T-DINF-01 with doctrine-inf semantic boundary vectors

### Decision
Extend doctrine validation with executable law-level checks for declared
preserved/not-preserved morphism boundaries via
`tools/conformance/run_doctrine_inf_vectors.py` and fixture suite
`tests/conformance/fixtures/doctrine-inf/`, and include these vectors in
`mise run doctrine-check`.

Covered doctrine boundary checks:

- edge morphisms must lie within destination `preserved` declarations,
- edge morphisms declared `notPreserved` reject deterministically,
- overlap between `preserved` and `notPreserved` declarations rejects
  deterministically.

### Rationale
`DOCTRINE-INF.md` coverage was previously graph/declaration coherence only.
`T-DINF-01` required executable semantic boundary checks that enforce doctrine
declaration meaning, not just declaration presence.

### Consequences
- `mise run doctrine-check` now runs both doctrine-site coherence and
  doctrine-inf semantic boundary vectors.
- `draft/SPEC-TRACEABILITY` marks `DOCTRINE-INF.md` as `covered`.
- Open traceability upgrades continue under `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0026: Execute T-KERNEL-01 with cross-model kernel profile vectors

### Decision
Implement and merge a canonical cross-model kernel profile vector suite under
`tests/conformance/fixtures/kernel-profile/` with deterministic runner
`tools/conformance/run_kernel_profile_vectors.py`, and wire it into
`mise run conformance-run` via the cached fixture-suite runner.

Covered kernel profile checks:

- stable semantic result parity (`accepted|rejected`) across toy and KCIR toy
  evidence surfaces for shared scenarios,
- stable failure tuple parity (`class`, `lawRef`, `witnessId`) across both
  surfaces for rejected scenarios,
- deterministic expected-outcome validation for each canonical vector.

### Rationale
`PREMATH-KERNEL.md` coverage previously remained `instrumented` through host
tests and toy suites without a canonical cross-model profile for reproducible
comparison. `T-KERNEL-01` required a dedicated deterministic conformance vector
surface that compares kernel-law outcomes across multiple evidence
representations.

### Consequences
- `mise run conformance-run` now executes `kernel-profile` vectors alongside
  interop-core, gate, witness-id, and capability suites under KCIR-style cache
  bindings.
- `draft/SPEC-TRACEABILITY` marks `PREMATH-KERNEL.md` as `covered`.
- The traceability target backlog (`T-*-*`) is currently empty.

---

## 2026-02-22 — Decision 0027: Expand Observation Surface with coherence projections

### Decision
Extend `Observation Surface v0` to include explicit coherence projections in
`summary.coherence` and expose them through observe query surfaces and the docs
dashboard:

- policy drift projection,
- unknown instruction-classification rate,
- proposal reject-class aggregation,
- ready-vs-blocked open-issue partition integrity,
- stale/contended lease-claim health.

Implementation surfaces:

- reducer/query: `tools/ci/observation_surface.py`
- semantic invariance checks: `tools/ci/check_observation_semantics.py`
- reducer tests: `tools/ci/test_observation_surface.py`
- observe read models: `crates/premath-surreal/src/observation.rs`,
  `crates/premath-ux/src/lib.rs`,
  `crates/premath-cli/src/commands/observe.rs`
- dashboard: `docs/observation/index.html`

### Rationale
Coherence v1 needed a single operator-facing observation surface that reports
not only required-gate verdict state but also control-plane coherence risks
(policy drift, unknown typing pressure, proposal failure shape, issue partition
integrity, and lease staleness/contention). Without these projections,
attention routing remained under-specified.

### Consequences
- `observe latest` and `observe needs_attention` now include coherence
  projection data for downstream tools/dashboards.
- `needsAttention` is now raised for rejected/error state *or* coherence
  attention reasons.
- Observation semantics checks now validate coherence-attention consistency.

---

## 2026-02-22 — Decision 0028: Extend doctrine-site operation coverage to doctrine-inf vectors

### Decision
Add the doctrine-inf executable vector runner as a first-class doctrine-site
operation node:

- `op/conformance.doctrine_inf` ->
  `tools/conformance/run_doctrine_inf_vectors.py`

and bind it into `draft/DOCTRINE-SITE.json` covers/edges so it is reachable
from doctrine root under the same CI control-loop ancestry as other doctrine
operations.

### Rationale
`mise run doctrine-check` executes both doctrine-site coherence checks and
doctrine-inf semantic boundary vectors. The site map previously represented only
`check_doctrine_site.py`, leaving the second doctrine-check operation outside
the audited doctrine-to-operation graph.

### Consequences
- doctrine-site reachability checks now include
  `tools/conformance/run_doctrine_inf_vectors.py`.
- `draft/DOCTRINE-SITE.md` repository notes now enumerate both doctrine
  conformance operation nodes.

---

## 2026-02-22 — Decision 0029: Add coherence contract checker and unify bidir proposal canonicalization

### Decision
Introduce a typed coherence-contract execution surface with deterministic
witnesses:

- new contract/checker crate: `crates/premath-coherence/`
- new CLI command: `premath coherence-check`
- canonical contract artifact: `specs/premath/draft/COHERENCE-CONTRACT.json`
- normative draft doc: `specs/premath/draft/PREMATH-COHERENCE.md`
- baseline gate integration: `mise run baseline` now includes
  `mise run coherence-check`.

For instruction proposal checking, remove duplicated conformance
canonicalization logic and require conformance vectors to use
`tools/ci/instruction_proposal.py` as the single source of canonical proposal
typing/digest behavior.

Additionally tighten envelope binding hygiene by rejecting leading/trailing
whitespace in top-level `normalizerId` and `policyDigest`.

### Rationale
The doctrine/checker split requires one deterministic control-plane coherence
surface that can reject contradictory docs/capability/gate/operation mappings
as typed obligations, and one canonical checker implementation for LLM proposal
canonicalization/discharge semantics. Duplicated canonicalizers create silent
drift risk between executable conformance and runtime instruction checking.

### Consequences
- Coherence is now executable and witness-producing through a merge-gated
  command surface (`coherence-check`).
- Bidir proposal typing/discharge semantics are now anchored to one Python
  checker implementation for both instruction execution and conformance vectors.
- Reject witnesses now fail closed on whitespace-bound binding fields that would
  otherwise bypass canonical policy/normalizer matching.

---

## 2026-02-22 — Decision 0030: Adopt issue.event.v1 replay boundary and projected dependency views

### Decision
For issue memory evolution, keep a single canonical edge encoding and add
deterministic projection/replay surfaces:

- add `issue.event.v1` in `premath-bd` as an append-only event envelope with
  deterministic migration from issue snapshot JSONL and deterministic replay.
- add `premath issue migrate-events` to emit `.premath/memory/events.jsonl`
  and fail closed on replay mismatch.
- keep one dependency encoding (`DepType`) and add semantic projections
  (`execution`, `gtd`, `groupoid`) via `premath dep project`.

### Rationale
The issue system needs minimum encoding with maximum expressiveness. Multiple
parallel edge schemas would duplicate semantics and drift. A single canonical
encoding plus projection views gives expressiveness for different workflows
(execution/GTD/groupoid) while preserving deterministic replay and auditable
state evolution.

### Consequences
- Snapshot memory now has a deterministic migration path to event-log memory.
- Replay equivalence is executable and test-gated.
- Workflow-specific dependency interpretations are explicit projection views,
  not schema forks.

---

## 2026-02-22 — Decision 0031: Align lease-claim conformance semantics with runtime state machine

### Decision
For issue lease/claim workflow semantics, make conformance vectors enforce the
same state machine as MCP runtime claim paths:

- stale lease claims are reclaimable (state may be normalized before claim),
- lease binding rejects ambiguous claim inputs (`ttl` + explicit expiry),
- lease TTL range is bounded,
- explicit lease expiry must be in the future,
- default lease-id derivation uses the same token normalization shape as runtime.

Add executable vectors for:

- stale lease reclaim golden path,
- invalid expiry reject,
- invalid TTL reject.

### Rationale
Lease/workflow control is a high-leverage orchestration boundary. Any drift
between executable conformance and runtime mutation semantics creates silent
multiagent coordination bugs.

### Consequences
- change-morphism conformance now catches stale-claim and lease-binding drift.
- runtime and conformance both fail-closed on invalid claim lease bindings.

---

## 2026-02-22 — Decision 0032: Make issue event memory projection bidirectional at CLI surface

### Decision
Expose deterministic event replay alongside migration:

- `premath issue migrate-events`: snapshot (`issues.jsonl`) -> event log
  (`issue.event.v1`)
- `premath issue replay-events`: event log (`issue.event.v1`) -> snapshot
  (`issues.jsonl`)

Replay writes a deterministic snapshot projection and reports equivalence to any
pre-existing snapshot at the target path.

### Rationale
Event memory should not be write-only from snapshot state. Operators and agents
need a deterministic, auditable projection path in both directions to support
rebuilds, cache invalidation, and reproducible substrate recovery.

### Consequences
- issue memory CLI now supports deterministic snapshot/event round-trips.
- replay idempotence and projection behavior are smoke-tested.

---

## 2026-02-22 — Decision 0033: Bind replay-cache hits to deterministic event and snapshot refs

### Decision
For event-memory replay, add deterministic cache binding and executable
conformance coverage:

- `premath issue replay-events` now accepts `--cache` (default derived from the
  target issues path) and emits:
  - `eventStreamRef` (`ev1_*`)
  - `snapshotRef` (`iss1_*`)
  - `cacheHit` and `cachePath`.
- cache hits are only valid when `(eventsPath, issuesPath, eventStreamRef,
  snapshotRef)` agree with current surfaces.
- replay writes are skipped on cache hit and on equivalent pre-existing
  snapshots.
- `capabilities.change_morphisms` gains replay-cache vectors:
  - golden stable hit,
  - adversarial ref mismatch reject,
  - local/external invariance pair.

### Rationale
Replay caching should reduce work without introducing hidden authority. The
cache must be a deterministic witness-bound optimization, not a separate state
oracle.

### Consequences
- replay projections are content-addressed and auditable.
- conformance enforces replay-cache binding semantics and invariance profiles.

---

## 2026-02-22 — Decision 0034: Promote NORMALIZER to draft and align Interop Full normative surface

### Decision
Promote `NORMALIZER` from raw to draft lifecycle and make all normative
Interop Full references point to `draft/NORMALIZER`.

Concretely:

- move `specs/premath/raw/NORMALIZER.md` to
  `specs/premath/draft/NORMALIZER.md`,
- set lifecycle frontmatter to `slug: draft` and `status: draft`,
- update cross-spec references from `raw/NORMALIZER` to `draft/NORMALIZER`,
- add `NORMALIZER.md` to the draft traceability matrix.

### Rationale
`NORMALIZER` is required for Interop Full claims and is already treated as a
normative dependency by `BIDIR-DESCENT`, capability vectors, and conformance
surfaces. Keeping it in raw status created lifecycle ambiguity and weakened
spec-index coherence.

### Consequences
- Interop Full normative scope is lifecycle-consistent.
- draft traceability now includes explicit coverage for `NORMALIZER.md`.
- raw-spec surface is reduced to genuinely non-promoted tracks.

---

## 2026-02-22 — Decision 0035: Add KCIR proposal refs as the canonical instruction/proposal boundary

### Decision
Extend instruction proposal ingestion so canonical proposal payloads produce a
deterministic KCIR ref and carry it through witness surfaces:

- add deterministic `proposalKcirRef` (`kcir1_*`) derivation in
  `tools/ci/instruction_proposal.py`,
- permit optional declared `proposalKcirRef` in proposal payloads and reject on
  mismatch (`proposal_kcir_ref_mismatch`),
- emit `proposalKcirRef` inside `proposalIngest` witness payloads from
  `tools/ci/run_instruction.py`,
- expose `proposal kcir ref` in instruction pipeline summaries,
- add instruction-typing adversarial vector
  `proposal_kcir_ref_mismatch_reject`.

### Rationale
`proposalDigest` alone is a local digest. The unification path needs one
portable IR boundary so instruction/proposal/coherence surfaces can reference
the same canonical proposal identity in a KCIR-compatible namespace.

### Consequences
- proposal witness lineage is now KCIR-addressable (`kcir1_*`).
- deterministic conformance coverage now rejects declared KCIR ref drift.
- docs now prefer `proposalKcirRef` as canonical external key while retaining
  `proposalDigest` for compatibility.

---

## 2026-02-22 — Decision 0036: Promote unification doctrine for minimum encoding and maximum expressiveness

### Decision
Add `draft/UNIFICATION-DOCTRINE` as a normative architecture doctrine surface
and link it from `SPEC-INDEX`, `draft/README`, and `SPEC-TRACEABILITY`.

Doctrine rule:

- one canonical encoding per authority boundary,
- deterministic expressive projections layered over that encoding.

### Rationale
Multiple ongoing threads (issue memory, instruction/proposal checking,
coherence, capability overlays) share the same reduction objective. A single
doctrine avoids local schema forks and keeps expressiveness in projections
instead of authority duplication.

### Consequences
- architectural coherence now has an explicit draft doctrine anchor.
- future reductions can be judged against a single canonical boundary rule.

---

## 2026-02-22 — Decision 0037: Deprecate ROADMAP as planning authority; issue graph + decision log are canonical

### Decision
Keep `specs/premath/raw/ROADMAP.md` as an informative orientation document,
but explicitly deprecate it as a source of active execution truth.

Canonical planning authority is now:

- `.premath/issues.jsonl` for active work graph/state,
- `specs/process/decision-log.md` for binding architectural/process decisions.

Add docs-coherence enforcement so `raw/ROADMAP` must contain explicit authority
markers pointing to those surfaces.

### Rationale
The roadmap phase sketch is useful context but drifts quickly. Active work
selection and ordering is already deterministic and queryable via the issue
graph. Binding intent is already captured in the decision log. Treating roadmap
text as execution authority duplicates state and reintroduces ambiguity.

### Consequences
- planning authority is now singular and machine-checkable.
- roadmap drift can no longer silently become a competing source of truth.

---

## 2026-02-22 — Decision 0038: Define raw capability-spec promotion policy and queue

### Decision
Define and publish lifecycle policy for optional capability-adjacent raw specs:
`raw/SQUEAK-SITE` and `raw/TUSK-CORE`.

Policy:

- raw capability specs may be exercised by executable vectors while still
  lifecycle-raw;
- capability claims bind only the capability-scoped normative clauses listed in
  `SPEC-INDEX` §5.4;
- promotion to draft requires deterministic vectors, deterministic
  witness/failure mappings, and an issue-backed migration plan with decision-log
  record.

Track promotion-prep as explicit issue queue:

- `bd-44` for `raw/SQUEAK-SITE`,
- `bd-45` for `raw/TUSK-CORE`.

### Rationale
Capability scope and lifecycle scope are different axes. We need explicit rules
that preserve expressive optionality while preventing accidental draft-level
authority from raw text drift.

### Consequences
- optional raw capability docs now have explicit retention/promotion criteria.
- promotion work is queryable as first-class issue graph state, not implicit
  intent.

---

## 2026-02-22 — Decision 0039: Adopt phased parity migration contract for Python adapters -> premath-coherence core

### Decision
Add a normative migration profile in `draft/PREMATH-COHERENCE` defining how
Python checker/gate surfaces move to `premath-coherence` core authority.

The profile fixes:

- authority boundary (Python as adapter only; no semantic duplication),
- parity contract keys (result, failure classes, binding fields, projection
  digests, proposal identity keys),
- phased cutover (`phase_0_inventory` -> `phase_4_deprecate_legacy`),
- rollback safety constraints (path switch only, witness-first fail-closed).

### Rationale
Without a concrete migration contract, the repo can drift into parallel
authoritative semantics between Python and Rust paths. The phased parity rule
keeps one authority boundary while preserving safe operational cutover.

### Consequences
- migration work for `bd-27`/`bd-34` now has explicit phase and parity targets.
- future cutovers can be judged by deterministic witness parity rather than
  narrative equivalence.

---

## 2026-02-22 — Decision 0040: Keep SQUEAK-SITE lifecycle-raw with explicit law/vector mapping

### Decision
Retain `raw/SQUEAK-SITE` in raw lifecycle state (do not promote to draft yet),
while tightening capability-scoped law coverage:

- add explicit adversarial vector for `site_glue_missing`,
- publish explicit law-boundary -> vector mapping inside `raw/SQUEAK-SITE`,
- keep `capabilities.squeak_site` normative scope bound to claimed clauses and
  executable vectors.

### Rationale
Squeak runtime-location contracts are still an active operational design surface
across local/external runner profiles. Promotion now would freeze a surface that
is still being normalized. We can preserve determinism and safety by tightening
vector-mapped capability boundaries while keeping the full spec lifecycle-raw.

### Consequences
- all currently declared site-class reject outcomes are now explicitly mapped to
  executable vectors (`site_overlap_mismatch`, `site_glue_missing`,
  `site_glue_non_contractible`).
- lifecycle authority remains coherent: capability clauses are executable and
  claim-bound, while full-document evolution remains open until promotion
  criteria are met.

---

## 2026-02-22 — Decision 0041: Keep TUSK-CORE lifecycle-raw with explicit runtime vector mapping

### Decision
Retain `raw/TUSK-CORE` in raw lifecycle state (do not promote to draft yet),
while tightening deterministic boundary evidence through a dedicated fixture
suite:

- add executable `tusk-core` conformance vectors run via
  `tools/conformance/run_tusk_core_vectors.py`,
- wire `tusk-core` into cached `conformance-run` suite execution,
- map `raw/TUSK-CORE` runtime boundary clauses to explicit vector IDs and
  Gate-class/law-ref outcomes.

### Rationale
`tusk-core` remains an active runtime contract surface with ongoing profile and
execution-shape iteration. Promotion now would freeze a boundary still under
active operational refinement. We can preserve deterministic authority by
binding runtime failure-class semantics to explicit vectors while keeping full
document lifecycle-raw.

### Consequences
- required mapping paths in `raw/TUSK-CORE` (§5.2/§8) now have executable
  vector evidence across accepted, locality, descent, and glue-contractibility
  outcomes.
- lifecycle authority remains coherent: contract text can iterate, while
  failure mapping behavior is pinned by deterministic vectors and merge gates.

---

## 2026-02-22 — Decision 0042: Unify proposal identity validation through one KCIR-bound authority path

### Decision
Complete the next `bd-31` unification slice by enforcing one shared proposal
identity validator and documenting the explicit KCIR boundary profile:

- add `validate_proposal_payload(...)` in `tools/ci/instruction_proposal.py` as
  the single validator for canonical proposal payload + declared
  `proposalDigest`/`proposalKcirRef` checks,
- route capability vector proposal checks through that shared validator (remove
  duplicated in-file declared-ref validation),
- publish explicit KCIR proposal projection mapping and deprecation rule in
  `draft/UNIFICATION-DOCTRINE` and `draft/LLM-PROPOSAL-CHECKING`,
- add dedicated unit tests for proposal validator behavior and include them in
  `ci-pipeline-test`.

### Rationale
Duplicate proposal identity validation logic across CI and conformance surfaces
creates unnecessary degrees of freedom and drift risk. A single validation path
keeps minimum encoding at the authority boundary while preserving expressive
projections.

### Consequences
- proposal identity checks now have one authoritative implementation path
  reused by instruction and conformance surfaces.
- KCIR proposal projection shape is explicit and portable (`kcir.proposal.v1`).
- migration away from duplicate proposal identity encodings is now concrete and
  test-gated.
