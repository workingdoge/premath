# Decision Log

This log records decisions that intentionally constrain future changes.

---

## 2026-02-19 — Decision 0001: Premath Kernel bundle commitment ("v0.1")

### Decision
We commit to a **profile-preserving** specification structure:

1. **Kernel stays minimal and ontology-agnostic.**
   - The normative kernel is `draft/PREMATH-KERNEL`.
   - Definability is **behavior**: coherent reindexing + locality + **contractible descent** on the Grothendieck topology generated by the declared coverage.
   - The kernel does **not** hardcode a semantic universe (Set/Gpd/∞-groupoids). It is parameterized by an ambient sameness level `V` with a chosen notion of equivalence `≈`.

2. **Backend-generic binding is a first-class seam.**
   - Reference binding is delegated to profiles via `project_ref` / `verify_ref` (see `draft/REF-BINDING`).
   - Kernel and opcode contracts MUST be phrased in terms of canonical bytes + `project_ref`, never a specific hash function.

3. **Operational totality is expressed via normalization + obligation discharge.**
   - `draft/NORMALIZER` and `draft/BIDIR-DESCENT` are part of the baseline "full" story.
   - In `normalized` mode, equality is **only** reference equality on normalized comparison refs (`cmpRef`).

4. **Gemini-style ∞-topos framing is adopted only as a semantics profile / optional dial.**
   - `raw/SEMANTICS-INFTOPOS` is informational (model-theoretic).
   - `raw/HYPERDESCENT`, `raw/UNIVERSE`, and `raw/SPLIT-PRESENTATION` are optional capabilities/extensions.

### Rationale
This locks in the original intent: **Premath is a definability gate (a linter), not a foundation**.

We still gain reviewer-facing strength by providing a canonical ∞-topos semantics profile and optional "final dial" extensions, without forcing those commitments on all constructors/backends.

### Consequences
- Future work that strengthens coherence (hypercovers), adds universes/comprehension, or requires strict presentations MUST be introduced as explicit capabilities/extensions.
- The next engineering step is no longer "define definability"; it is to build **running code + vectors** for the baseline bundle.

### Next milestone (binding)
Milestone M1: a conformance suite + at least one reference verifier implementation that:

- computes `project_ref` for at least one backend profile,
- normalizes NF deterministically and compares by `cmpRef`,
- emits and discharges Gate obligations deterministically.

---

## 2026-02-19 — Decision 0002: Proof-carrying overlap + cocycle witnesses

### Decision
We standardize an **optional Gate-witness seam** for descent checks:

- `O_ASSERT_OVERLAP` (OBJ opcode `0x05`): certifies pairwise overlap compatibility.
- `O_ASSERT_TRIPLE`  (OBJ opcode `0x06`): certifies triple-overlap coherence ("cocycle" check).

Both opcodes return `Unit` and are parameterized by the active constructor's restriction + equality.

### Rationale
This makes descent **trace-internal**: the Gate does not need to recompute overlap constraints from scratch,
and implementations can move overlap checks into a verified certificate layer.

### Consequences
- These opcodes are OPTIONAL in the raw kernel: they are a certified seam, not a mandatory feature.
- They enable incremental hardening: later work can add proof-carrying *uniqueness/contractibility* witnesses
  beyond brute-force enumeration.

---

## 2026-02-20 — Decision 0003: Contractible gluing as a proof-scheme hook

### Decision
We standardize an **optional Gate-witness seam** for stack-safe uniqueness / contractible gluing that is
explicitly **proof-scheme driven**:

- `O_ASSERT_CONTRACTIBLE` (OBJ opcode `0x07`) takes:
  - `schemeId: Bytes32` (opaque label), and
  - `proofBytes: bytes` (opaque payload)

and certifies that the glue space for a descent datum is **contractible** at the constructor’s sameness level.

Unsupported `schemeId` values MUST be rejected deterministically.

### Rationale
The kernel requires *contractibility* (stack-safe uniqueness), but does not prescribe how to prove it.
In engineering settings, brute-force enumeration is sometimes acceptable (toy models), but production
settings may require compressed proofs (e.g. RLNC decoding, lattice/norm arguments, solver certificates).

Making contractibility verification scheme-driven preserves:

- **backend agnosticism** (no hardcoded cryptography), and
- **proof agnosticism** (no forced proof system),

while still allowing KCIR traces to carry their own uniqueness certificates.

### Consequences
- The toy suite may implement a default scheme (e.g. `toy.enumerate.v1`) purely for determinism.
- Production backends can adopt additional `schemeId` values without changing kernel law text.

---

## 2026-02-20 — Decision 0004: First promotion batch from raw to draft

### Decision
Promote the governance/conformance spine to `draft` status:

- `draft/SPEC-INDEX`
- `draft/CONFORMANCE`
- `draft/CAPABILITY-VECTORS`
- `draft/CHANGE-MORPHISMS`

These remain under `specs/premath/raw/` path for link stability; authoritative
status is the front-matter `status` field.

### Rationale
These documents now define the invariant closure contract used by implementation
and CI:

- profile-invariant kernel/Gate outcomes,
- explicit optional capability claims,
- canonical change-morphism discipline.

Promoting this layer first reduces process ambiguity while keeping technical
surface area controlled.

### Consequences
- Future changes in this layer are expected to behave as draft contracts between
  editor and implementers.
- Conformance and fixture scaffolding for these capabilities are now part of the
  expected running-code discipline.

---

## 2026-02-20 — Decision 0005: Semantic-core promotion from raw to draft

### Decision
Promote the semantic-core contract files to `draft` status:

- `draft/PREMATH-KERNEL`
- `draft/GATE`
- `draft/BIDIR-DESCENT`
- `draft/WITNESS-ID`

Files remain in `specs/premath/raw/` for stable path references; normative
status is the front-matter field.

### Rationale
These files are the load-bearing semantic contract for runtime invariance:

- kernel laws,
- admissibility gate classes,
- operational discharge model,
- deterministic witness identity.

Promoting this batch aligns process state with current implementation and vector
usage, and reduces ambiguity about contract maturity.

### Consequences
- Changes to these specs should now be treated as draft-contract changes and be
  paired with vector/runtime evidence.
- Remaining raw specs can be promoted in later focused batches.

---

## 2026-02-20 — Decision 0006: Interop-core promotion and KCIR core rename

### Decision
Promote the Interop Core contract files to `draft` status:

- `draft/KCIR-CORE` (renamed from legacy id `KCIR-V2-CORE`)
- `draft/NF`
- `draft/REF-BINDING`
- `draft/WIRE-FORMATS`
- `draft/ERROR-CODES`

Rename spec identity from `KCIR-V2-CORE` to `KCIR-CORE` across references.

### Rationale
This batch stabilizes the interop artifact boundary and removes version-biased
naming in the core model reference for greenfield evolution.

### Consequences
- Dependencies and cross-spec references now target `draft/KCIR-CORE`.
- Conformance/interop reading orders now resolve through the renamed core spec.
- Remaining `v2` labels outside this core reference are informational/versioned
  naming and can be migrated separately if desired.

---

## 2026-02-20 — Decision 0007: Draft specs moved to `specs/premath/draft/`

### Decision
Move all promoted draft specs out of `specs/premath/raw/` into
`specs/premath/draft/`.

### Rationale
Directory semantics should match lifecycle semantics:

- `raw/` for experimentation and informational material,
- `draft/` for active contract specs.

This removes ambiguity about normative authority and improves navigation.

### Consequences
- Internal references for promoted specs now use `draft/<SPEC>`.
- `raw/README.md` is narrowed to raw-only scope.
- `draft/README.md` becomes the contract entry point for promoted specs.

---

## 2026-02-20 — Decision 0008: Process docs moved to `specs/process/`

### Decision
Move process governance docs out of `specs/premath/process/` into:

- `specs/process/coss.md`
- `specs/process/decision-log.md`

### Rationale
Process policy applies across the Premath spec lifecycle and should not appear
as a subtype of one lifecycle bucket (`premath/`).

Placing process at `specs/process/` clarifies authority and reduces path
ambiguity in promoted draft/raw specs.

### Consequences
- Draft/raw spec front matter now points to `../../process/coss.md`.
- Repository-level references now use `specs/process/decision-log.md`.

---

## 2026-02-20 — Decision 0009: Add raw operational stack specs (`TUSK`, `SQUEAK`, `CI`)

### Decision
Publish the current operational architecture as raw specs:

- `raw/TUSK-CORE`
- `raw/SQUEAK-CORE`
- `raw/CI-TOPOS`

and index them from:

- `raw/V2-SPECS`
- `draft/SPEC-INDEX` (informative-only references)

### Rationale
We need a documented operational boundary while preserving kernel stability:

- `tusk-core` captures single-world execution contracts,
- `squeak-core` captures inter-world transport contracts,
- `ci-topos` captures closure-style conformance gating.

Keeping this layer raw allows iteration without prematurely hardening runtime
interfaces as conformance requirements.

### Consequences
- The kernel/draft conformance surface remains unchanged.
- KCIR remains optional capability/evidence machinery, not a kernel dependency.
- Promotion of operational specs to draft requires dedicated vectors and
  conformance claims.

---

## 2026-02-21 — Decision 0010: Doctrine-to-operation site map and checker

### Decision
Add a draft, machine-checkable doctrine-to-operation site contract:

- `specs/premath/draft/DOCTRINE-SITE.md`
- `specs/premath/draft/DOCTRINE-SITE.json`

and enforce it with:

- `tools/conformance/check_doctrine_site.py`
- `mise run doctrine-check`

Baseline gates now include doctrine-site validation.

### Rationale
We need an explicit path from meta-doctrine (`DOCTRINE-INF`) to operational
entrypoints (`tools/ci/*`, `tools/conformance/*`) so architecture drift is
auditable and detectable.

The site map makes this path concrete as nodes/covers/edges and binds edge
morphism IDs to declared preservation contracts.

### Consequences
- Declaration-bearing specs must stay coherent with the site map.
- Operational gate entrypoints must remain reachable from doctrine root.
- Refactors touching doctrine declarations, site map, or gate tooling are now
  expected to pass the doctrine-site checker in baseline CI.

---

## 2026-02-21 — Decision 0011: Add LLM instruction doctrine contract

### Decision
Add a draft doctrine contract for typed LLM instruction handling:

- `specs/premath/draft/LLM-INSTRUCTION-DOCTRINE.md`

and map it into the doctrine-to-operation site:

- `specs/premath/draft/DOCTRINE-SITE.json`

### Rationale
Instruction-envelope execution is already operational in this repository
(`tools/ci/run_instruction.sh` + CI witness output), but it needed explicit
doctrine constraints for:

- typed vs unknown instruction classification,
- authority split (LLM proposal vs kernel/runtime admissibility),
- deterministic instruction-to-witness binding.

### Consequences
- Higher-order CI/CD reading order now includes `draft/LLM-INSTRUCTION-DOCTRINE`.
- Doctrine-site coherence checks now include instruction doctrine nodes/edges.
- Instruction tooling remains execution surface only; semantic authority remains
  in kernel/runtime layers.

---

## 2026-02-21 — Decision 0012: Add executable instruction-typing capability vectors

### Decision
Promote instruction typing checks into executable capability conformance with:

- capability id: `capabilities.instruction_typing`
- vectors under:
  `tests/conformance/fixtures/capabilities/capabilities.instruction_typing/`
- runner support in:
  `tools/conformance/run_capability_vectors.py`

### Rationale
The instruction doctrine requires explicit `typed(kind)` / `unknown(reason)`
classification and deterministic handling. We need executable vectors to keep
this behavior regression-resistant and profile-invariant.

### Consequences
- `python3 tools/conformance/run_capability_vectors.py` now executes instruction
  typing vectors by default.
- Fixture/invariance stub checks now include this capability track.
- Claim surfaces (`SPEC-INDEX`, `CAPABILITY-VECTORS`, `CONFORMANCE`) now
  include `capabilities.instruction_typing`.

---

## 2026-02-21 — Decision 0013: Wire instruction doctrine into runtime witness flow

### Decision
Extend `tools/ci/run_instruction.py` to enforce doctrine-level instruction
classification at runtime:

- classify each envelope as `typed(kind)` or `unknown(reason)`,
- reject `unknown(reason)` when `typingPolicy.allowUnknown` is false,
- emit `instructionClassification` and `typingPolicy` in CI witness artifacts.

### Rationale
Doctrine and conformance capability checks were in place, but the operational
instruction runner did not yet surface classification in runtime artifacts.
This closes the spec-to-operation loop.

### Consequences
- instruction witness records now carry explicit typing metadata.
- unroutable unknown instructions fail deterministically before gate execution.
- instruction envelope examples/documentation now include optional typing fields.

---

## 2026-02-21 — Decision 0014: Collapse capability IDs to minimal canonical set

### Decision
Align executable capability IDs with the draft governance vocabulary by
collapsing aliases:

- `capabilities.change_projection` -> `capabilities.change_morphisms`
- `capabilities.ci_required_witness` -> `capabilities.ci_witnesses`

The executable conformance surface now uses:

- `capabilities.normal_forms`
- `capabilities.kcir_witnesses`
- `capabilities.commitment_checkpoints`
- `capabilities.squeak_site`
- `capabilities.ci_witnesses`
- `capabilities.instruction_typing`
- `capabilities.change_morphisms`

### Rationale
Governance drift appeared when runtime/docs used capability IDs not present in
`draft/CAPABILITY-VECTORS` and `draft/CONFORMANCE`. We prefer minimal encoding:
one canonical identifier per capability claim unless expansion is explicitly
promoted as new doctrine.

### Consequences
- `tools/conformance/run_capability_vectors.py` defaults are now canonical and
  draft-aligned.
- capability fixtures were merged/renamed to match canonical IDs.
- docs and command-surface references now use the canonical capability names.

---

## 2026-02-21 — Decision 0015: Introduce explicit profile-overlay lane (`specs/premath/profile`)

### Decision
Add an explicit profile-overlay lane under `specs/premath/profile/` and treat
overlay specs as:

- additive to base draft claims,
- normative only when explicitly claimed,
- required to compile into deterministic checker/discharge behavior.

Initial overlay adopted in-repo:

- `profile/ADJOINTS-AND-SITES`

`draft/SPEC-INDEX` is updated to include:

- profile-overlay claim guidance,
- normative scope for claimed overlays,
- a reading order for adjoints-and-sites implementation.

### Rationale
We need a place for mathematically stronger but optional structures (for example
adjoint/Beck-Chevalley overlays) without inflating baseline kernel obligations.

This keeps the kernel small while allowing policy-scoped strengthening that is
auditable and capability-claim driven.

### Consequences
- Base kernel and existing capability claims remain unchanged unless an overlay
  is explicitly claimed.
- Future overlays should land in `specs/premath/profile/` and wire through
  `draft/SPEC-INDEX` and conformance claims.
- Overlay work should avoid duplicating semantic authority in orchestration
  layers; checker/discharge remains the authority boundary.

---

## 2026-02-22 — Decision 0016: Pre-execution instruction failures MUST emit typed reject witnesses

### Decision
Instruction-envelope execution now emits first-class reject witness artifacts
when validation fails before check execution (schema/shape, policy allowlist,
proposal binding):

- witness kind remains `ci.instruction.v1`,
- verdict is `rejected`,
- `rejectStage` is `pre_execution`,
- `failureClasses` are deterministic typed classes.

Provider-neutral instruction pipeline behavior is updated so validation failures
still produce these artifacts rather than returning only stderr/exit status.

### Rationale
The control plane needs one auditable witness surface for both runtime check
failures and pre-execution admission failures. Without this, invalid envelopes
create blind spots in observation and multiagent coordination.

### Consequences
- `tools/ci/run_instruction.py` now writes reject witnesses on invalid envelopes.
- `tools/ci/pipeline_instruction.py` now ensures invalid-envelope runs still
  emit witness artifacts.
- CI witness conformance now includes reject-witness determinism checks for
  failure-class stability.

---

## 2026-02-22 — Decision 0017: Add executable adjoints/sites capability vectors

### Decision
Introduce executable capability claim `capabilities.adjoints_sites` for the
`profile/ADJOINTS-AND-SITES` overlay with vectors that enforce deterministic
obligation compilation/discharge bound to `(normalizerId, policyDigest)`.

The executable surface now checks obligations for:

- `adjoint_triangle`
- `beck_chevalley_sigma`
- `beck_chevalley_pi`
- `refinement_invariance`

### Rationale
The profile overlay existed as normative text but had no executable claim
surface. This left adjoint/site coherence behavior outside the conformance loop.
Adding vectors keeps overlay claims auditable and regression-resistant.

### Consequences
- `tools/conformance/run_capability_vectors.py` now runs
  `capabilities.adjoints_sites`.
- Conformance fixtures now include golden/adversarial/invariance vectors for
  adjoint/site obligations.
- `draft/CAPABILITY-VECTORS`, `draft/CONFORMANCE`, and `draft/SPEC-INDEX`
  now include the new capability claim semantics.

---

## 2026-02-22 — Decision 0018: Enforce capability-gated instruction-linked issue mutations

### Decision
Strengthen MCP `instruction-linked` mutation policy for issue/dep writes:

- instruction witness must be `accepted`,
- instruction witness must carry `policyDigest` in an allowed mutation scope,
- instruction witness must carry capability claims including:
  - base: `capabilities.change_morphisms`
  - per-action claim (or wildcard `capabilities.change_morphisms.all`)

Action claims are enforced for:
`issue.add`, `issue.update`, `issue.claim`, `issue.discover`, and `dep.add`.

### Rationale
Instruction linkage by presence alone is too permissive. Mutation authorization
must be capability-scoped and policy-scoped so agents cannot mutate long-running
work memory outside declared boundaries.

### Consequences
- `crates/premath-cli/src/commands/mcp_serve.rs` now enforces capability and
  policy gating on instruction-linked mutations.
- instruction witness links now expose `capabilityClaims`.
- instruction runner/checker surfaces now validate/carry optional
  `capabilityClaims` fields.

---

## 2026-02-22 — Decision 0019: Introduce deterministic multiagent claim-lease protocol

### Decision
Extend issue mutation surface with deterministic lease lifecycle semantics:

- `issue.claim` now binds claim ownership to a lease tuple
  (`lease_id`, owner, expiry),
- add `issue.lease_renew` and `issue.lease_release` mutations,
- add `issue.lease_projection` read model for deterministic stale/contended
  lease classification.

Lease-contention and lease-lifecycle failures are typed with deterministic
failure classes (for example `lease_contention_active`, `lease_stale`,
`lease_owner_mismatch`, `lease_id_mismatch`).

### Rationale
Instruction-scoped mutation authorization was in place, but concurrent agents
still needed deterministic coordination primitives to avoid implicit work
stealing and long-running claim drift. A lease protocol narrows operational
degrees of freedom while preserving explicit handoff/renew flows.

### Consequences
- `premath-bd` issue schema now includes first-class lease state.
- MCP mutation surface includes renew/release actions and lease projection.
- `capabilities.change_morphisms` executable vectors now cover lease claim
  transitions, renew/release lifecycle transitions, active-contention rejects,
  and stale/contended projection invariants.

---

## 2026-02-22 — Decision 0020: Adopt draft spec traceability matrix with explicit coverage targets

### Decision
Adopt `draft/SPEC-TRACEABILITY` as the canonical matrix mapping promoted draft
specs to executable conformance/check surfaces.

The matrix introduces explicit status classes:

- `covered`
- `instrumented`
- `gap`

and requires every `gap` row to reference a concrete target ID.

### Rationale
Conformance vectors were strong for capability claims, but coverage boundaries
for several promoted draft specs were implicit and distributed across docs/tests.

A single traceability surface reduces planning drift, makes gaps explicit, and
gives issue discovery a deterministic source of truth.

### Consequences
- `draft/SPEC-TRACEABILITY` is now part of promoted draft documentation and is
  linked from `draft/README`, `draft/SPEC-INDEX`, and `draft/CONFORMANCE`.
- current explicit targets include:
  - `T-IC-01` (interop-core executable vectors),
  - `T-GATE-01` (canonical gate vectors),
  - `T-WID-01` (witness-id conformance vectors),
  - `T-DINF-01` (doctrine-inf semantic coverage upgrade),
  - `T-KERNEL-01` (cross-model kernel vector profile),
  - `T-INDEX-01` (index/traceability integrity check).

---

## 2026-02-22 — Decision 0021: Execute T-IC-01 with first-class interop-core vectors

### Decision
Implement and merge executable Interop Core vector coverage under
`tests/conformance/fixtures/interop-core/` with deterministic runner
`tools/conformance/run_interop_core_vectors.py`, and wire it into
`mise run conformance-run`.

Covered slices:

- `draft/KCIR-CORE` (domain table minimum),
- `draft/REF-BINDING` (projection + verify digest/profile/domain semantics),
- `draft/NF` (ObjNF/MorNF parser contracts, including `PullAtom` claim gate),
- `draft/WIRE-FORMATS` (registered wire parse behavior),
- `draft/ERROR-CODES` (registry membership checks).

### Rationale
`T-IC-01` was the largest explicit traceability gap for promoted draft specs.
Closing it converts Interop Core from mostly indirect instrumentation into a
deterministic vectored surface in merge-gated conformance runs.

### Consequences
- `mise run conformance-run` now executes interop-core vectors before capability
  vectors.
- `draft/SPEC-TRACEABILITY` rows for `KCIR-CORE`, `REF-BINDING`, `NF`,
  `WIRE-FORMATS`, and `ERROR-CODES` move to `covered`.
- Remaining open coverage upgrades continue under `T-GATE-01`, `T-WID-01`,
  `T-DINF-01`, `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0022: Execute T-GATE-01 with canonical gate vectors

### Decision
Implement and merge executable Gate vectors under
`tests/conformance/fixtures/gate/` with deterministic runner
`tools/conformance/run_gate_vectors.py`, and wire it into
`mise run conformance-run`.

Covered gate-law classes:

- `stability_failure` (`GATE-3.1`)
- `locality_failure` (`GATE-3.2`)
- `descent_failure` (`GATE-3.3`)
- `glue_non_contractible` (`GATE-3.4`)

### Rationale
`GATE` coverage previously depended on unit/toy paths without a canonical
conformance fixture suite in `tests/conformance/fixtures/gate/`. This made the
traceability target `T-GATE-01` an explicit open gap.

### Consequences
- `mise run conformance-run` now executes gate vectors in addition to interop
  and capability vectors.
- `draft/SPEC-TRACEABILITY` marks `GATE.md` as `covered`.
- Open traceability upgrades now continue under `T-WID-01`, `T-DINF-01`,
  `T-KERNEL-01`, and `T-INDEX-01`.

---

## 2026-02-22 — Decision 0023: Execute T-WID-01 with witness-id conformance vectors

### Decision
Implement and merge executable Witness-ID vectors under
`tests/conformance/fixtures/witness-id/` with deterministic runner
`tools/conformance/run_witness_id_vectors.py`, and wire it into
`mise run conformance-run` through the fixture-suite runner.

Covered Witness-ID requirements:

- stability under excluded-field variation (`message`, `sources`, `details`),
- sensitivity to canonical witness-key fields (`class`, `lawRef`, `tokenPath`,
  `context`),
- deterministic witness-id computation for fixed key material.

### Rationale
`WITNESS-ID.md` was only instrumented via unit tests. `T-WID-01` required a
first-class conformance vector suite in the merge-gated conformance surface so
determinism/sensitivity behavior is validated at fixture level.

### Consequences
- `mise run conformance-run` now executes witness-id vectors alongside interop,
  gate, and capability suites.
- `draft/SPEC-TRACEABILITY` marks `WITNESS-ID.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01`, `T-KERNEL-01`, and
  `T-INDEX-01`.

---

## 2026-02-22 — Decision 0024: Execute T-INDEX-01 with deterministic traceability matrix check

### Decision
Implement and merge deterministic traceability matrix integrity validation via
`tools/conformance/check_spec_traceability.py`, and wire it into
`mise run baseline` as `mise run traceability-check`.

Coverage checks enforce:

- every promoted draft spec under `specs/premath/draft/` appears exactly once
  in `draft/SPEC-TRACEABILITY`,
- matrix status classes are restricted to `covered|instrumented|gap`,
- `gap` rows require concrete target IDs (`T-*-*`),
- no matrix rows reference unknown draft specs.

### Rationale
`SPEC-INDEX`/traceability coverage was previously instrumentation-by-convention.
`T-INDEX-01` required a deterministic executable surface to prevent drift
between promoted draft spec inventory and matrix rows.

### Consequences
- `mise run baseline` now includes `mise run traceability-check`.
- `draft/SPEC-TRACEABILITY` marks `SPEC-INDEX.md` as `covered`.
- Open traceability upgrades continue under `T-DINF-01` and `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0025: Execute T-DINF-01 with doctrine-inf semantic boundary vectors

### Decision
Extend doctrine validation with executable law-level checks for declared
preserved/not-preserved morphism boundaries via
`tools/conformance/run_doctrine_inf_vectors.py` and fixture suite
`tests/conformance/fixtures/doctrine-inf/`, and include these vectors in
`mise run doctrine-check`.

Covered doctrine boundary checks:

- edge morphisms must lie within destination `preserved` declarations,
- edge morphisms declared `notPreserved` reject deterministically,
- overlap between `preserved` and `notPreserved` declarations rejects
  deterministically.

### Rationale
`DOCTRINE-INF.md` coverage was previously graph/declaration coherence only.
`T-DINF-01` required executable semantic boundary checks that enforce doctrine
declaration meaning, not just declaration presence.

### Consequences
- `mise run doctrine-check` now runs both doctrine-site coherence and
  doctrine-inf semantic boundary vectors.
- `draft/SPEC-TRACEABILITY` marks `DOCTRINE-INF.md` as `covered`.
- Open traceability upgrades continue under `T-KERNEL-01`.

---

## 2026-02-22 — Decision 0026: Execute T-KERNEL-01 with cross-model kernel profile vectors

### Decision
Implement and merge a canonical cross-model kernel profile vector suite under
`tests/conformance/fixtures/kernel-profile/` with deterministic runner
`tools/conformance/run_kernel_profile_vectors.py`, and wire it into
`mise run conformance-run` via the cached fixture-suite runner.

Covered kernel profile checks:

- stable semantic result parity (`accepted|rejected`) across toy and KCIR toy
  evidence surfaces for shared scenarios,
- stable failure tuple parity (`class`, `lawRef`, `witnessId`) across both
  surfaces for rejected scenarios,
- deterministic expected-outcome validation for each canonical vector.

### Rationale
`PREMATH-KERNEL.md` coverage previously remained `instrumented` through host
tests and toy suites without a canonical cross-model profile for reproducible
comparison. `T-KERNEL-01` required a dedicated deterministic conformance vector
surface that compares kernel-law outcomes across multiple evidence
representations.

### Consequences
- `mise run conformance-run` now executes `kernel-profile` vectors alongside
  interop-core, gate, witness-id, and capability suites under KCIR-style cache
  bindings.
- `draft/SPEC-TRACEABILITY` marks `PREMATH-KERNEL.md` as `covered`.
- The traceability target backlog (`T-*-*`) is currently empty.

---

## 2026-02-22 — Decision 0027: Expand Observation Surface with coherence projections

### Decision
Extend `Observation Surface v0` to include explicit coherence projections in
`summary.coherence` and expose them through observe query surfaces and the docs
dashboard:

- policy drift projection,
- unknown instruction-classification rate,
- proposal reject-class aggregation,
- ready-vs-blocked open-issue partition integrity,
- stale/contended lease-claim health.

Implementation surfaces:

- reducer/query: `tools/ci/observation_surface.py`
- semantic invariance checks: `tools/ci/check_observation_semantics.py`
- reducer tests: `tools/ci/test_observation_surface.py`
- observe read models: `crates/premath-surreal/src/observation.rs`,
  `crates/premath-ux/src/lib.rs`,
  `crates/premath-cli/src/commands/observe.rs`
- dashboard: `docs/observation/index.html`

### Rationale
Coherence v1 needed a single operator-facing observation surface that reports
not only required-gate verdict state but also control-plane coherence risks
(policy drift, unknown typing pressure, proposal failure shape, issue partition
integrity, and lease staleness/contention). Without these projections,
attention routing remained under-specified.

### Consequences
- `observe latest` and `observe needs_attention` now include coherence
  projection data for downstream tools/dashboards.
- `needsAttention` is now raised for rejected/error state *or* coherence
  attention reasons.
- Observation semantics checks now validate coherence-attention consistency.

---

## 2026-02-22 — Decision 0028: Extend doctrine-site operation coverage to doctrine-inf vectors

### Decision
Add the doctrine-inf executable vector runner as a first-class doctrine-site
operation node:

- `op/conformance.doctrine_inf` ->
  `tools/conformance/run_doctrine_inf_vectors.py`

and bind it into `draft/DOCTRINE-SITE.json` covers/edges so it is reachable
from doctrine root under the same CI control-loop ancestry as other doctrine
operations.

### Rationale
`mise run doctrine-check` executes both doctrine-site coherence checks and
doctrine-inf semantic boundary vectors. The site map previously represented only
`check_doctrine_site.py`, leaving the second doctrine-check operation outside
the audited doctrine-to-operation graph.

### Consequences
- doctrine-site reachability checks now include
  `tools/conformance/run_doctrine_inf_vectors.py`.
- `draft/DOCTRINE-SITE.md` repository notes now enumerate both doctrine
  conformance operation nodes.

---

## 2026-02-22 — Decision 0029: Add coherence contract checker and unify bidir proposal canonicalization

### Decision
Introduce a typed coherence-contract execution surface with deterministic
witnesses:

- new contract/checker crate: `crates/premath-coherence/`
- new CLI command: `premath coherence-check`
- canonical contract artifact: `specs/premath/draft/COHERENCE-CONTRACT.json`
- normative draft doc: `specs/premath/draft/PREMATH-COHERENCE.md`
- baseline gate integration: `mise run baseline` now includes
  `mise run coherence-check`.

For instruction proposal checking, remove duplicated conformance
canonicalization logic and require conformance vectors to use
`tools/ci/instruction_proposal.py` as the single source of canonical proposal
typing/digest behavior.

Additionally tighten envelope binding hygiene by rejecting leading/trailing
whitespace in top-level `normalizerId` and `policyDigest`.

### Rationale
The doctrine/checker split requires one deterministic control-plane coherence
surface that can reject contradictory docs/capability/gate/operation mappings
as typed obligations, and one canonical checker implementation for LLM proposal
canonicalization/discharge semantics. Duplicated canonicalizers create silent
drift risk between executable conformance and runtime instruction checking.

### Consequences
- Coherence is now executable and witness-producing through a merge-gated
  command surface (`coherence-check`).
- Bidir proposal typing/discharge semantics are now anchored to one Python
  checker implementation for both instruction execution and conformance vectors.
- Reject witnesses now fail closed on whitespace-bound binding fields that would
  otherwise bypass canonical policy/normalizer matching.

---

## 2026-02-22 — Decision 0030: Adopt issue.event.v1 replay boundary and projected dependency views

### Decision
For issue memory evolution, keep a single canonical edge encoding and add
deterministic projection/replay surfaces:

- add `issue.event.v1` in `premath-bd` as an append-only event envelope with
  deterministic migration from issue snapshot JSONL and deterministic replay.
- add `premath issue migrate-events` to emit `.premath/memory/events.jsonl`
  and fail closed on replay mismatch.
- keep one dependency encoding (`DepType`) and add semantic projections
  (`execution`, `gtd`, `groupoid`) via `premath dep project`.

### Rationale
The issue system needs minimum encoding with maximum expressiveness. Multiple
parallel edge schemas would duplicate semantics and drift. A single canonical
encoding plus projection views gives expressiveness for different workflows
(execution/GTD/groupoid) while preserving deterministic replay and auditable
state evolution.

### Consequences
- Snapshot memory now has a deterministic migration path to event-log memory.
- Replay equivalence is executable and test-gated.
- Workflow-specific dependency interpretations are explicit projection views,
  not schema forks.

---

## 2026-02-22 — Decision 0031: Align lease-claim conformance semantics with runtime state machine

### Decision
For issue lease/claim workflow semantics, make conformance vectors enforce the
same state machine as MCP runtime claim paths:

- stale lease claims are reclaimable (state may be normalized before claim),
- lease binding rejects ambiguous claim inputs (`ttl` + explicit expiry),
- lease TTL range is bounded,
- explicit lease expiry must be in the future,
- default lease-id derivation uses the same token normalization shape as runtime.

Add executable vectors for:

- stale lease reclaim golden path,
- invalid expiry reject,
- invalid TTL reject.

### Rationale
Lease/workflow control is a high-leverage orchestration boundary. Any drift
between executable conformance and runtime mutation semantics creates silent
multiagent coordination bugs.

### Consequences
- change-morphism conformance now catches stale-claim and lease-binding drift.
- runtime and conformance both fail-closed on invalid claim lease bindings.

---

## 2026-02-22 — Decision 0032: Make issue event memory projection bidirectional at CLI surface

### Decision
Expose deterministic event replay alongside migration:

- `premath issue migrate-events`: snapshot (`issues.jsonl`) -> event log
  (`issue.event.v1`)
- `premath issue replay-events`: event log (`issue.event.v1`) -> snapshot
  (`issues.jsonl`)

Replay writes a deterministic snapshot projection and reports equivalence to any
pre-existing snapshot at the target path.

### Rationale
Event memory should not be write-only from snapshot state. Operators and agents
need a deterministic, auditable projection path in both directions to support
rebuilds, cache invalidation, and reproducible substrate recovery.

### Consequences
- issue memory CLI now supports deterministic snapshot/event round-trips.
- replay idempotence and projection behavior are smoke-tested.

---

## 2026-02-22 — Decision 0033: Bind replay-cache hits to deterministic event and snapshot refs

### Decision
For event-memory replay, add deterministic cache binding and executable
conformance coverage:

- `premath issue replay-events` now accepts `--cache` (default derived from the
  target issues path) and emits:
  - `eventStreamRef` (`ev1_*`)
  - `snapshotRef` (`iss1_*`)
  - `cacheHit` and `cachePath`.
- cache hits are only valid when `(eventsPath, issuesPath, eventStreamRef,
  snapshotRef)` agree with current surfaces.
- replay writes are skipped on cache hit and on equivalent pre-existing
  snapshots.
- `capabilities.change_morphisms` gains replay-cache vectors:
  - golden stable hit,
  - adversarial ref mismatch reject,
  - local/external invariance pair.

### Rationale
Replay caching should reduce work without introducing hidden authority. The
cache must be a deterministic witness-bound optimization, not a separate state
oracle.

### Consequences
- replay projections are content-addressed and auditable.
- conformance enforces replay-cache binding semantics and invariance profiles.

---

## 2026-02-22 — Decision 0034: Promote NORMALIZER to draft and align Interop Full normative surface

### Decision
Promote `NORMALIZER` from raw to draft lifecycle and make all normative
Interop Full references point to `draft/NORMALIZER`.

Concretely:

- move `specs/premath/raw/NORMALIZER.md` to
  `specs/premath/draft/NORMALIZER.md`,
- set lifecycle frontmatter to `slug: draft` and `status: draft`,
- update cross-spec references from `raw/NORMALIZER` to `draft/NORMALIZER`,
- add `NORMALIZER.md` to the draft traceability matrix.

### Rationale
`NORMALIZER` is required for Interop Full claims and is already treated as a
normative dependency by `BIDIR-DESCENT`, capability vectors, and conformance
surfaces. Keeping it in raw status created lifecycle ambiguity and weakened
spec-index coherence.

### Consequences
- Interop Full normative scope is lifecycle-consistent.
- draft traceability now includes explicit coverage for `NORMALIZER.md`.
- raw-spec surface is reduced to genuinely non-promoted tracks.

---

## 2026-02-22 — Decision 0035: Add KCIR proposal refs as the canonical instruction/proposal boundary

### Decision
Extend instruction proposal ingestion so canonical proposal payloads produce a
deterministic KCIR ref and carry it through witness surfaces:

- add deterministic `proposalKcirRef` (`kcir1_*`) derivation in
  `tools/ci/instruction_proposal.py`,
- permit optional declared `proposalKcirRef` in proposal payloads and reject on
  mismatch (`proposal_kcir_ref_mismatch`),
- emit `proposalKcirRef` inside `proposalIngest` witness payloads from
  `tools/ci/run_instruction.py`,
- expose `proposal kcir ref` in instruction pipeline summaries,
- add instruction-typing adversarial vector
  `proposal_kcir_ref_mismatch_reject`.

### Rationale
`proposalDigest` alone is a local digest. The unification path needs one
portable IR boundary so instruction/proposal/coherence surfaces can reference
the same canonical proposal identity in a KCIR-compatible namespace.

### Consequences
- proposal witness lineage is now KCIR-addressable (`kcir1_*`).
- deterministic conformance coverage now rejects declared KCIR ref drift.
- docs now prefer `proposalKcirRef` as canonical external key while retaining
  `proposalDigest` for compatibility.

---

## 2026-02-22 — Decision 0036: Promote unification doctrine for minimum encoding and maximum expressiveness

### Decision
Add `draft/UNIFICATION-DOCTRINE` as a normative architecture doctrine surface
and link it from `SPEC-INDEX`, `draft/README`, and `SPEC-TRACEABILITY`.

Doctrine rule:

- one canonical encoding per authority boundary,
- deterministic expressive projections layered over that encoding.

### Rationale
Multiple ongoing threads (issue memory, instruction/proposal checking,
coherence, capability overlays) share the same reduction objective. A single
doctrine avoids local schema forks and keeps expressiveness in projections
instead of authority duplication.

### Consequences
- architectural coherence now has an explicit draft doctrine anchor.
- future reductions can be judged against a single canonical boundary rule.

---

## 2026-02-22 — Decision 0037: Deprecate ROADMAP as planning authority; issue graph + decision log are canonical

### Decision
Keep `specs/premath/raw/ROADMAP.md` as an informative orientation document,
but explicitly deprecate it as a source of active execution truth.

Canonical planning authority is now:

- `.premath/issues.jsonl` for active work graph/state,
- `specs/process/decision-log.md` for binding architectural/process decisions.

Add docs-coherence enforcement so `raw/ROADMAP` must contain explicit authority
markers pointing to those surfaces.

### Rationale
The roadmap phase sketch is useful context but drifts quickly. Active work
selection and ordering is already deterministic and queryable via the issue
graph. Binding intent is already captured in the decision log. Treating roadmap
text as execution authority duplicates state and reintroduces ambiguity.

### Consequences
- planning authority is now singular and machine-checkable.
- roadmap drift can no longer silently become a competing source of truth.

---

## 2026-02-22 — Decision 0038: Define raw capability-spec promotion policy and queue

### Decision
Define and publish lifecycle policy for optional capability-adjacent raw specs:
`raw/SQUEAK-SITE` and `raw/TUSK-CORE`.

Policy:

- raw capability specs may be exercised by executable vectors while still
  lifecycle-raw;
- capability claims bind only the capability-scoped normative clauses listed in
  `SPEC-INDEX` §5.4;
- promotion to draft requires deterministic vectors, deterministic
  witness/failure mappings, and an issue-backed migration plan with decision-log
  record.

Track promotion-prep as explicit issue queue:

- `bd-44` for `raw/SQUEAK-SITE`,
- `bd-45` for `raw/TUSK-CORE`.

### Rationale
Capability scope and lifecycle scope are different axes. We need explicit rules
that preserve expressive optionality while preventing accidental draft-level
authority from raw text drift.

### Consequences
- optional raw capability docs now have explicit retention/promotion criteria.
- promotion work is queryable as first-class issue graph state, not implicit
  intent.

---

## 2026-02-22 — Decision 0039: Adopt phased parity migration contract for Python adapters -> premath-coherence core

### Decision
Add a normative migration profile in `draft/PREMATH-COHERENCE` defining how
Python checker/gate surfaces move to `premath-coherence` core authority.

The profile fixes:

- authority boundary (Python as adapter only; no semantic duplication),
- parity contract keys (result, failure classes, binding fields, projection
  digests, proposal identity keys),
- phased cutover (`phase_0_inventory` -> `phase_4_deprecate_legacy`),
- rollback safety constraints (path switch only, witness-first fail-closed).

### Rationale
Without a concrete migration contract, the repo can drift into parallel
authoritative semantics between Python and Rust paths. The phased parity rule
keeps one authority boundary while preserving safe operational cutover.

### Consequences
- migration work for `bd-27`/`bd-34` now has explicit phase and parity targets.
- future cutovers can be judged by deterministic witness parity rather than
  narrative equivalence.

---

## 2026-02-22 — Decision 0040: Keep SQUEAK-SITE lifecycle-raw with explicit law/vector mapping

### Decision
Retain `raw/SQUEAK-SITE` in raw lifecycle state (do not promote to draft yet),
while tightening capability-scoped law coverage:

- add explicit adversarial vector for `site_glue_missing`,
- publish explicit law-boundary -> vector mapping inside `raw/SQUEAK-SITE`,
- keep `capabilities.squeak_site` normative scope bound to claimed clauses and
  executable vectors.

### Rationale
Squeak runtime-location contracts are still an active operational design surface
across local/external runner profiles. Promotion now would freeze a surface that
is still being normalized. We can preserve determinism and safety by tightening
vector-mapped capability boundaries while keeping the full spec lifecycle-raw.

### Consequences
- all currently declared site-class reject outcomes are now explicitly mapped to
  executable vectors (`site_overlap_mismatch`, `site_glue_missing`,
  `site_glue_non_contractible`).
- lifecycle authority remains coherent: capability clauses are executable and
  claim-bound, while full-document evolution remains open until promotion
  criteria are met.

---

## 2026-02-22 — Decision 0041: Keep TUSK-CORE lifecycle-raw with explicit runtime vector mapping

### Decision
Retain `raw/TUSK-CORE` in raw lifecycle state (do not promote to draft yet),
while tightening deterministic boundary evidence through a dedicated fixture
suite:

- add executable `tusk-core` conformance vectors run via
  `tools/conformance/run_tusk_core_vectors.py`,
- wire `tusk-core` into cached `conformance-run` suite execution,
- map `raw/TUSK-CORE` runtime boundary clauses to explicit vector IDs and
  Gate-class/law-ref outcomes.

### Rationale
`tusk-core` remains an active runtime contract surface with ongoing profile and
execution-shape iteration. Promotion now would freeze a boundary still under
active operational refinement. We can preserve deterministic authority by
binding runtime failure-class semantics to explicit vectors while keeping full
document lifecycle-raw.

### Consequences
- required mapping paths in `raw/TUSK-CORE` (§5.2/§8) now have executable
  vector evidence across accepted, locality, descent, and glue-contractibility
  outcomes.
- lifecycle authority remains coherent: contract text can iterate, while
  failure mapping behavior is pinned by deterministic vectors and merge gates.

---

## 2026-02-22 — Decision 0042: Unify proposal identity validation through one KCIR-bound authority path

### Decision
Complete the next `bd-31` unification slice by enforcing one shared proposal
identity validator and documenting the explicit KCIR boundary profile:

- add `validate_proposal_payload(...)` in `tools/ci/instruction_proposal.py` as
  the single validator for canonical proposal payload + declared
  `proposalDigest`/`proposalKcirRef` checks,
- route capability vector proposal checks through that shared validator (remove
  duplicated in-file declared-ref validation),
- publish explicit KCIR proposal projection mapping and deprecation rule in
  `draft/UNIFICATION-DOCTRINE` and `draft/LLM-PROPOSAL-CHECKING`,
- add dedicated unit tests for proposal validator behavior and include them in
  `ci-pipeline-test`.

### Rationale
Duplicate proposal identity validation logic across CI and conformance surfaces
creates unnecessary degrees of freedom and drift risk. A single validation path
keeps minimum encoding at the authority boundary while preserving expressive
projections.

### Consequences
- proposal identity checks now have one authoritative implementation path
  reused by instruction and conformance surfaces.
- KCIR proposal projection shape is explicit and portable (`kcir.proposal.v1`).
- migration away from duplicate proposal identity encodings is now concrete and
  test-gated.

---

## 2026-02-22 — Decision 0043: Route instruction proposal discharge through core-backed CLI checker path

### Decision
Advance `bd-34` migration execution by moving instruction proposal semantic
evaluation off Python-local kernels and onto a core-backed CLI path:

- add `premath proposal-check --proposal <proposal.json> --json`,
- implement proposal canonicalization/digest/KCIR ref checks and deterministic
  obligation compile/discharge in `premath-coherence`,
- update `tools/ci/run_instruction.py` to delegate proposal ingest checks to the
  new CLI command (Python remains orchestration/witness shaping wrapper).

### Rationale
`run_instruction.py` previously executed proposal semantic kernels directly in
Python (`compile_proposal_obligations`/`discharge_proposal_obligations`), which
left a parallel authority path during migration. This step reduces that degree
of freedom by shifting the live instruction gate path to the core-backed
checker surface.

### Consequences
- instruction gate execution now uses core-backed proposal checking semantics.
- Python keeps policy/env orchestration responsibility but no longer owns
  proposal discharge semantics on the authoritative instruction path.
- migration work for `bd-34` is now in-progress with one concrete cutover lane
  completed; remaining parity migration surfaces still need consolidation.

---

## 2026-02-22 — Decision 0044: Run coherence-contract checks through cached conformance fixture-suite surface

### Decision
Add `coherence-contract` as a first-class suite in
`tools/conformance/run_fixture_suites.py`, executed by the authoritative
command:

- `premath coherence-check --contract specs/premath/draft/COHERENCE-CONTRACT.json --repo-root . --json`

and bind cache materialization to:

- `draft/COHERENCE-CONTRACT.json`,
- `tests/conformance/fixtures/coherence-transport`,
- `crates/premath-coherence/src`,
- CLI coherence command wrapper source.

### Rationale
`coherence-check` existed as a standalone baseline gate but not as part of the
shared cached fixture-suite execution surface. This left a duplicate execution
shape for conformance-style determinism and slowed repeated runs. Routing it
through the same cache scheme reduces degrees of freedom while preserving one
semantic authority path.

### Consequences
- coherence transport obligations are now executed on the same KCIR-style cache
  substrate as other executable fixture suites.
- repeated coherence-contract runs can short-circuit on deterministic cache
  hits.
- docs/fixture entrypoints now expose `coherence-contract` as a first-class
  executable suite in the conformance surface.

---

## 2026-02-22 — Decision 0045: Add raw site/sheaf/torsor semantics lane with foundations companion

### Decision
Add a new informational semantics lane for site/topos abstractions:

- `raw/CTX-SITE`
- `raw/SHEAF-STACK`
- `raw/TORSOR-EXT`

and add a foundations companion note:

- `docs/foundations/SITE-AND-TORSOR-NOTES.md`

without changing checker authority or conformance claims.

### Rationale
We need a compact expression of base/fibre, coverage, descent, and extension
ideas to guide coherence evolution, but we do not want to recreate Premath as a
parallel architecture. This lane provides semantic compression while preserving
the existing acceptance boundary (`checker -> obligations -> discharge ->
witness`).

### Consequences
- site/sheaf/stack/torsor vocabulary is now available as a shared design
  language for future coherence obligations.
- no new normative claim is introduced; all additions are lifecycle-raw or
  foundations notes.
- `draft/SPEC-INDEX` and `raw/README` now reference this lane explicitly so the
  abstraction path remains discoverable and coherent.

---

## 2026-02-22 — Decision 0046: Add site-coverage and glue-or-witness obligations to coherence-contract checker

### Decision
Extend `draft/COHERENCE-CONTRACT.json` and `premath-coherence` with three new
required obligations:

- `coverage_base_change`
- `coverage_transitivity`
- `glue_or_witness_contractibility`

backed by executable vectors under `tests/conformance/fixtures/coherence-site`.

### Rationale
Transport functoriality alone does not cover the full site/descent contract.
We need deterministic checks for cover pullback stability, cover transitivity,
and explicit glue-or-obstruction outcomes to keep the checker aligned with the
site/sheaf abstractions while preserving one acceptance authority path.

### Consequences
- coherence checker now enforces site-level coverage and descent outcome
  invariants in addition to transport law.
- cached `conformance-run` coherence-contract suite now depends on
  `coherence-site` fixtures for deterministic cache invalidation and replay.
- no new authority layer is introduced; all outcomes still flow through
  `premath coherence-check` witness emission.

---

## 2026-02-22 — Decision 0047: Kernel-own obligation->Gate authority registry with machine export

### Decision
Move canonical obligation->Gate mapping authority into `premath-kernel` and
export it as one typed registry surface:

- source authority: `crates/premath-kernel/src/obligation_registry.rs`
- Rust APIs: `obligation_to_failure_class`, `failure_class_to_law_ref`,
  `obligation_gate_registry`, `obligation_gate_registry_json`
- machine export command: `premath obligation-registry --json`

Downstream checker paths consume this authority instead of local duplicated
mapping constants.

### Rationale
The mapping is normative (`draft/BIDIR-DESCENT` §8.1 + `draft/GATE` class/law
surface) and should not live in a downstream checker implementation file. A
kernel-owned export reduces duplication and keeps the semantic boundary
single-source.

### Consequences
- proposal discharge in `premath-coherence` now imports kernel mapping APIs.
- coherence contract parity surface now points to kernel registry source for
  obligation-vocabulary checks.
- CLI/automation can consume one deterministic JSON registry artifact for
  cross-surface parity work (`bd-58`, `bd-59`, `bd-63`).

---

## 2026-02-22 — Decision 0048: Introduce shared CONTROL-PLANE-CONTRACT artifact for projection parity

### Decision
Add `draft/CONTROL-PLANE-CONTRACT.json` as a shared typed control-plane
artifact and wire two independent surfaces to consume it:

- CI projection engine (`tools/ci/change_projection.py`) now loads
  `projectionPolicy` + `checkIds` + `checkOrder` from this contract.
- Coherence gate-chain parity (`premath coherence-check`) now compares CI
  closure projected checks against the contract’s `requiredGateProjection`
  section instead of parsing Python source constants.

### Rationale
Control-plane constants (projection policy/check order) were duplicated in code
and checked by source scraping. Moving them to one typed artifact reduces
encoding duplication and establishes a common contract consumed by both CI
execution and coherence checking.

### Consequences
- `COHERENCE-CONTRACT` now references `controlPlaneContractPath` as the
  projection authority input.
- docs coherence checker now validates CI closure projected checks against
  `CONTROL-PLANE-CONTRACT` instead of `CHECK_ORDER` source parsing.
- this is the first `bd-63` slice; remaining scope includes migrating
  additional control-plane constants (witness class/binding keys and related
  roundtrip conformance vectors) onto the same contract artifact.

---

## 2026-02-22 — Decision 0049: Split CI witness failure lineage into operational vs semantic classes

### Decision
Adopt a typed failure-lineage split for CI witness summaries:

- `operationalFailureClasses`: control-plane execution classes.
- `semanticFailureClasses`: semantic lineage classes derived from Gate/proposal
  surfaces when available.
- `failureClasses`: deterministic set-union compatibility field.

Apply this split to `ci.required` and `ci.instruction` witnesses, and enforce
deterministic mapping in `verify_required_witness_payload` (used by both
`ci-verify-required` and `ci-decide-required`).

### Rationale
The prior single `failureClasses` surface collapsed operational and semantic
causes. That made CI decision surfaces less informative and weakened semantic
lineage preservation across kernel/coherence/CI boundaries.

### Consequences
- `ci.required` now carries semantic classes threaded from linked gate witness
  payloads (`gateWitnessRefs[].failureClasses`) while preserving operational
  `check_failed` classification.
- `ci.instruction` now separates pre-execution/control-plane failures from
  proposal-discharge semantic failures, while preserving the union field for
  compatibility.
- verification/decision paths now reject lineage-shape mismatches instead of
  accepting collapsed failure-class summaries when semantic lineage is present.

---

## 2026-02-22 — Decision 0050: Make capability parity generation-first via typed registry artifact

### Decision
Introduce `draft/CAPABILITY-REGISTRY.json` as the canonical typed executable
capability registry and consume it across parity surfaces:

- `tools/conformance/run_capability_vectors.py` default capability selection,
- `tools/conformance/check_docs_coherence.py` docs parity checks,
- `premath coherence-check` (`capability_parity` obligation).

Also replace coherence bidirectional checker source parsing with kernel-owned
typed obligation registry APIs (`obligation_gate_registry`,
`obligation_gate_registry_json`).

### Rationale
Capability and obligation parity checks still depended on language-specific
source scraping (`DEFAULT_EXECUTABLE_CAPABILITIES` tuple and map parsing).
That made parity fragile and duplicated authority across implementation files.
Typed registry artifacts/API exports preserve one authority path and reduce
hidden drift.

### Consequences
- capability parity now binds to a machine artifact (`CAPABILITY-REGISTRY.json`)
  instead of source constants.
- conformance/docs/coherence surfaces now share the same executable capability
  authority input.
- coherence scope checks now bind to kernel registry kind + obligation set via
  typed API export rather than parsing source text maps.

---

## 2026-02-22 — Decision 0051: Add machine branch-policy contract and live ruleset checker

### Decision
Introduce a tracked process policy artifact and checker for server-side GitHub
enforcement on `main`:

- policy artifact: `specs/process/GITHUB-BRANCH-POLICY.json`
- checker: `tools/ci/check_branch_policy.py`
  - fixture mode: `--rules-json ...` (deterministic local/CI parser check)
  - live mode: `--fetch-live` against
    `/repos/{owner}/{repo}/rules/branches/{branch}`
- baseline task integration (fixture mode):
  `mise run ci-branch-policy-check`
- manual live governance workflow:
  `.github/workflows/branch-policy.yml`

### Rationale
The repository observed remote push acceptance with bypass messaging despite
local `ci-required-attested` success. This indicates branch/ruleset authority
must be checked at the server surface, not inferred from local gate execution.

### Consequences
- branch-protection/ruleset shape now has a tracked policy contract in-repo.
- parser/contract drift is covered by deterministic test + fixture surfaces.
- live server checks are available as a first-class workflow with explicit
  admin-read token requirement (`PREMATH_BRANCH_POLICY_TOKEN`).
- governance hardening remains fail-closed on bypass actors under the tracked
  policy.

---

## 2026-02-22 — Decision 0052: Make doctrine-site mapping generation-first with typed source + operation registry

### Decision
Adopt a generation-first doctrine-site contract flow:

- add `draft/DOCTRINE-SITE-SOURCE.json` as the non-operation topology source,
- add `draft/DOCTRINE-OP-REGISTRY.json` as operation-node + CI-edge registry,
- generate `draft/DOCTRINE-SITE.json` deterministically from:
  - source topology,
  - operation registry,
  - declaration-bearing spec sections (`Doctrine Preservation Declaration (v0)`).

Require doctrine-site checker roundtrip parity (`generated == tracked`) in
addition to existing morphism/declaration/reachability checks.

### Rationale
`DOCTRINE-SITE.json` previously duplicated declaration sets directly, creating a
hand-maintained drift surface. Generation-first removes duplicate encoding,
keeps operation ancestry auditable, and preserves one canonical projection path.

### Consequences
- doctrine-site authority now has three explicit artifacts:
  `DOCTRINE-SITE-SOURCE.json` + `DOCTRINE-OP-REGISTRY.json` ->
  `DOCTRINE-SITE.json`.
- `tools/conformance/check_doctrine_site.py` now enforces roundtrip drift
  rejection and points to the generator for repair.
- new helper/generator/test surfaces:
  - `tools/conformance/doctrine_site_contract.py`
  - `tools/conformance/generate_doctrine_site.py`
  - `tools/conformance/test_doctrine_site_contract.py`

---

## 2026-02-22 — Decision 0053: Add boundary-authority invariance vectors across kernel/coherence/CI witness surfaces

### Decision
Extend `capabilities.ci_witnesses` executable vectors with a boundary-authority
lineage slice that validates one shared authority chain:

- kernel obligation registry mapping (`obligationKind -> failureClass`),
- proposal discharge failed-obligation classes,
- coherence scope registry kind + bidir obligation surface,
- CI witness semantic failure lineage (`semanticFailureClasses` plus union shape).

Add adversarial vectors for:

- obligation-registry mapping mismatch,
- stale generated doctrine-site digest material.

Add paired local/external invariance vectors for the same boundary-authority
scenario.

### Rationale
`bd-61` requires proving that authority mappings remain invariant across the
kernel/coherence/CI projection boundary, not just inside one witness format.
This closes the remaining parity gap after typed registry and generation-first
surfaces were introduced (`bd-57`, `bd-58`, `bd-59`, `bd-60`, `bd-63`).

### Consequences
- `tools/conformance/run_capability_vectors.py` now includes boundary-authority
  lineage validation in the `capabilities.ci_witnesses` evaluator.
- `tests/conformance/fixtures/capabilities/capabilities.ci_witnesses/` now
  contains:
  - `golden/boundary_authority_lineage_accept`,
  - `adversarial/boundary_authority_registry_mismatch_reject`,
  - `adversarial/boundary_authority_stale_generated_reject`,
  - `invariance/same_boundary_authority_local`,
  - `invariance/same_boundary_authority_external`.
- capability/conformance docs now explicitly require boundary-authority lineage
  parity and stale generated doctrine-site rejection under
  `capabilities.ci_witnesses`.

---

## 2026-02-22 — Decision 0054: Bind Interop ref vectors to a real profile-backed verifier surface

### Decision
Adopt a first-class reference profile artifact and route Interop ref vectors
through the canonical CLI verifier surface:

- add `policies/ref/sha256_detached_v1.json` as profile kind
  `premath.ref_profile.v1`,
- add `premath ref project` and `premath ref verify` commands in
  `premath-cli`,
- execute `interop-core` ref projection/verification vectors by invoking those
  CLI commands (not a Python-local digest shim),
- pin fixture refs to the profile fields
  (`schemeId=ref.sha256.detached.v1`,
  `paramsHash=sha256.detached.params.v1`).

### Rationale
`bd-36` requires "at least one real backend profile + reference verifier
implementation" for M1 coherence. The previous interop runner validated ref
logic using a Python simulation; that validated behavior but left the canonical
command surface unexercised. Binding vectors to the CLI closes that boundary and
reduces duplicate encoding.

### Consequences
- `project_ref`/`verify_ref` now have one typed implementation path in
  `premath-cli` with deterministic rejection classes.
- interop ref vectors now test the same command surface users and CI consume.
- CLI smoke coverage includes `ref project` and `ref verify` JSON surfaces.
- M1 reference verifier milestone criteria are satisfied at command surface +
  conformance levels.

---

## 2026-02-22 — Decision 0055: Retire legacy Python instruction-policy shim authority

### Decision
Remove `tools/ci/instruction_policy.py` and its dedicated unit surface
`tools/ci/test_instruction_policy.py`.

Keep instruction policy/allowlist/binding authority exclusively on the core
`premath instruction-check` path consumed via:

- `tools/ci/instruction_check_client.py`,
- `tools/ci/run_instruction.py`,
- `tools/ci/test_instruction_reject_witness.py`.

Update pipeline and traceability surfaces to reference core-backed tests only.

### Rationale
The Python instruction-policy module had become an unreferenced duplicate
semantic surface after instruction envelope validation moved into
`premath-coherence` and `premath-cli`. Keeping it introduced avoidable encoding
drift risk.

### Consequences
- `mise run ci-pipeline-test` no longer executes `test_instruction_policy.py`.
- traceability for `draft/LLM-PROPOSAL-CHECKING` now points to
  `test_instruction_check_client.py` + `test_instruction_reject_witness.py`.
- instruction policy semantics remain single-path and checker-owned.

---

## 2026-02-22 — Decision 0056: Add CwF strict presentation obligations to coherence-check

### Decision
Extend `premath coherence-check` and `draft/COHERENCE-CONTRACT.json` with four
strict CwF obligations:

- `cwf_substitution_identity`
- `cwf_substitution_composition`
- `cwf_comprehension_beta`
- `cwf_comprehension_eta`

Bind them to executable vectors under
`tests/conformance/fixtures/coherence-site/` and evaluate them through the same
deterministic site-obligation runner already used for cover/glue obligations.

### Rationale
Premath already separates semantic `≈` (kernel/fibration/site) from operational
`≡` surfaces used by deterministic CI/witness pipelines. CwF laws provide the
minimal strict substitution/comprehension contract needed at that operational
boundary without redefining kernel semantic authority.

### Consequences
- coherence contract required-obligation set grows by four CwF IDs.
- coherence-site fixture manifest now includes golden/adversarial vectors for
  strict substitution identity/composition and comprehension beta/eta.
- `draft/PREMATH-COHERENCE` now specifies CwF strictification obligations
  explicitly.

---

## 2026-02-22 — Decision 0057: Make instruction digest checker-authoritative on the instruction path

### Decision
Extend `premath instruction-check` output with canonical
`instructionDigest` (`instr1_<sha256(canonical-json)>`) and consume that value
directly in `tools/ci/run_instruction.py` when building instruction witnesses.

Keep Python wrappers as transport adapters only:

- no Python-side canonical digest recomputation on accepted instruction paths,
- stale local binary payload-shape drift is auto-healed by retrying through
  `cargo run --package premath-cli -- instruction-check ...`.

### Rationale
`bd-34` targets one authority path for checker semantics. Instruction digest
computation duplicated in Python was an avoidable parallel encoding surface.
Moving digest authority to core reduces drift risk and tightens deterministic
lineage from envelope check to witness emission.

### Consequences
- `ValidatedInstructionEnvelope` now includes `instructionDigest`.
- `run_instruction.py` now uses core-emitted digest for witness runtime payloads
  on accepted envelopes.
- `instruction_check_client.py` validates presence of `instructionDigest` and
  retries through cargo when a stale local binary emits older payload shape.
- instruction-path smoke and client/unit tests cover this fallback behavior.

---

## 2026-02-22 — Decision 0058: Move ci.required witness assembly to core `premath required-witness`

### Decision
Add a core `required-witness` command path and route
`tools/ci/run_required_checks.py` witness assembly through it.

This introduces:

- `premath-coherence` required witness runtime/output types and deterministic
  lineage assembly (`verdictClass`, operational/semantic failure unions),
- `premath-cli required-witness --runtime <json> --json`,
- `tools/ci/required_witness_client.py` as a thin transport adapter with
  stale-local-binary fallback to cargo.

### Rationale
`bd-34` requires reducing Python semantic authority in gate/check pipelines.
`run_required_checks.py` previously built `ci.required.v1` witness semantics
locally; that duplicated authority with the checker layer. Moving witness
assembly to core keeps wrappers transport-only and reduces drift risk.

### Consequences
- `run_required_checks.py` now sends runtime payload to core and consumes one
  authoritative `ci.required.v1` witness JSON output.
- CI pipeline test surface now includes dedicated required-witness client tests.
- CLI smoke coverage now includes `required-witness` JSON command surface.

---

## 2026-02-22 — Decision 0059: Move ci.required verification semantics to core `premath required-witness-verify`

### Decision
Add a core required witness verification path:

- `premath-coherence` now exposes deterministic required witness verification
  (`verify_required_witness_payload`) including projection parity, gate witness
  linkage integrity, native-required source constraints, and failure-lineage
  union checks.
- `premath-cli` adds `required-witness-verify --input <json> --json`.
- Python verifier helpers now delegate to core through
  `tools/ci/required_witness_verify_client.py` and keep filesystem loading as
  adapter-only behavior.

### Rationale
`bd-34` aims to remove Python-local checker authority from required/instruction
gate paths. Required witness validation previously lived in
`tools/ci/required_witness.py`, creating a parallel semantic surface.

### Consequences
- `tools/ci/required_witness.py` is now a thin adapter that forwards
  `{witness, changedPaths, nativeRequiredChecks, gateWitnessPayloads}` to core.
- `verify_required_witness.py` keeps orchestration but semantic verdicts come
  from core output (`errors`, `derived`).
- pipeline and CLI smoke surfaces now include
  `required-witness-verify` client/command tests.

---

## 2026-02-22 — Decision 0060: Move Delta→requiredChecks projection semantics to core `premath required-projection`

### Decision
Make required-check projection (`changedPaths -> requiredChecks + reasons +
projectionDigest`) core-owned:

- add `premath-coherence` projection evaluator
  (`project_required_checks`, `normalize_projection_paths`) with deterministic
  result shape,
- add `premath-cli required-projection --input <json> --json`,
- route `tools/ci/change_projection.py` projection evaluation through
  `tools/ci/required_projection_client.py` and keep Python-side logic limited to
  git delta discovery + wrapper orchestration.

Also bind required-witness verification to the same projection authority by
reusing `required_projection` logic inside `required_verify`.

### Rationale
`bd-34` requires one semantic authority path for CI gate projection surfaces.
Projection logic previously lived in Python (`change_projection.py`) and was
duplicated in core verification code. Moving this boundary to core removes
parallel encodings and reduces drift risk across run/verify/decide paths.

### Consequences
- `run_required_checks.py`, `verify_required_witness.py`,
  `decide_required.py`, and capability/conformance helpers now consume projection
  semantics through the core command/client path.
- `required_verify` and runtime projection now share one core implementation.
- pipeline and CLI smoke surfaces now include required-projection client/command
  tests.

---

## 2026-02-22 — Decision 0061: Move git/workspace delta detection to core `premath required-delta`

### Decision
Make changed-path detection (`repoRoot + optional fromRef/toRef -> {changedPaths,
source, fromRef, toRef}`) core-owned:

- add `premath-cli required-delta --input <delta_input.json> --json`,
- route `tools/ci/change_projection.py` delta detection through
  `tools/ci/required_delta_client.py`,
- keep Python wrappers as adapter-only orchestration surfaces.

### Rationale
`bd-34` targets one checker-owned semantic authority path for required-gate
planning. After Decision 0060, Python still owned git/workspace delta detection
rules; that left a second semantic boundary outside core command surfaces.
Moving this path into `premath-cli` reduces drift risk and aligns run/verify/
decide consumers on the same deterministic delta semantics.

### Consequences
- `change_projection.py` no longer embeds git ref fallback/source classification
  logic.
- required-gate pipeline tests now include `test_required_delta_client.py`.
- CLI smoke coverage now includes `required-delta` against a temporary git repo
  fixture.

---

## 2026-02-22 — Decision 0062: Move required decision attestation verification to core `premath required-decision-verify`

### Decision
Move decision-chain verification semantics (`decision + witness + delta +
actual digest bindings`) into core:

- add `premath-coherence` verifier
  (`verify_required_decision_request`),
- add `premath-cli required-decision-verify --input <json> --json`,
- route `tools/ci/verify_decision.py` through
  `tools/ci/required_decision_verify_client.py` and keep Python path as
  filesystem/path transport only.

### Rationale
After projection/delta/witness/verify/decide migrations, `verify_decision.py`
still carried cross-artifact semantic checks. This kept a second decision
authority surface in Python. Moving those checks into core keeps attestation
semantics checker-authoritative and reduces wrapper drift risk.

### Consequences
- decision-chain semantic checks now execute through one core command surface.
- pipeline tests include `test_required_decision_verify_client.py`.
- CLI smoke coverage includes `required-decision-verify`.

---

## 2026-02-22 — Decision 0063: Move required gate-ref and fallback payload synthesis to core `premath required-gate-ref`

### Decision
Move per-check gate reference assembly and fallback gate payload synthesis into
core semantics:

- add `premath-coherence` gate-ref builder (`build_required_gate_ref`),
- add `premath-cli required-gate-ref --input <json> --json`,
- route `tools/ci/run_required_checks.py` native/fallback gate ref assembly
  through `tools/ci/required_gate_ref_client.py`,
- route `tools/ci/emit_gate_witness.py` fallback envelope emission through the
  same core command surface.

### Rationale
`run_required_checks.py` previously owned semantic pieces of gate lineage
assembly (`sha256` projection, failure-class extraction, fallback envelope
materialization). That left a parallel authority path outside core checker
surfaces. This decision keeps wrappers in transport mode and makes gate-ref
lineage deterministic under one command surface.

### Consequences
- required-gate runtime wrappers no longer compute gate ref semantics locally.
- pipeline tests include `test_required_gate_ref_client.py`.
- CLI smoke coverage includes `required-gate-ref`.

---

## 2026-02-22 — Decision 0064: Deduplicate required client transport into shared `core_cli_client`

### Decision
Consolidate repeated Python wrapper transport behavior for required gate command
clients into one helper module:

- add `tools/ci/core_cli_client.py`,
- centralize premath binary resolution, temp JSON input handoff, stale local
  binary retry-to-cargo, deterministic failure-class extraction, and JSON
  decode/retry handling,
- keep per-client payload-shape validation local in each
  `required_*_client.py`.

### Rationale
After moving required gate semantics into core commands, wrappers still carried
duplicated transport code across seven client modules. That duplication
increased drift risk without adding semantic expressiveness. Centralizing
transport keeps wrappers thinner while preserving command-specific validation.

### Consequences
- `required_*_client.py` modules now encode only command metadata and payload
  shape validation.
- behavior parity remains covered by existing required-client tests and
  `ci-pipeline-test`.

---

## 2026-02-22 — Decision 0065: Route proposal-check Python client through shared core transport

### Decision
Adopt `tools/ci/core_cli_client.py` in
`tools/ci/proposal_check_client.py` and keep only proposal payload validation
plus proposal-specific failure-class mapping in the proposal client.

### Rationale
After Decision 0064, `proposal_check_client.py` still carried duplicate command
transport behavior. Reusing the shared helper removes another parallel wrapper
surface while keeping proposal-domain error semantics explicit.

### Consequences
- `proposal_check_client.py` now shares command transport behavior with
  required-gate clients.
- proposal-specific validation classes remain stable
  (`proposal_nondeterministic`, `proposal_kcir_ref_mismatch`,
  `proposal_invalid_step`).

---

## 2026-02-22 — Decision 0066: Route instruction-check/instruction-witness clients through shared core transport

### Decision
Adopt `tools/ci/core_cli_client.py` transport helpers in
`tools/ci/instruction_check_client.py` for both:

- `instruction-check` (path-input command),
- `instruction-witness` (runtime payload-input command with optional
  pre-execution flags).

Extend shared transport helpers with:

- path-input execution mode (`run_core_json_command_from_path`),
- optional extra command args,
- explicit invalid-json failure-class override.

### Rationale
Instruction clients still carried duplicated command transport logic after
Decision 0064/0065. Moving them onto the shared helper removes another
wrapper-level authority duplicate while preserving instruction-domain failure
classes.

### Consequences
- instruction client wrappers now follow the same minimum-encoding transport
  surface as required/proposal wrappers.
- `instruction_envelope_invalid_shape` remains the parse/shape failure class for
  instruction-check payload decoding failures.

---

## 2026-02-22 — Decision 0067: Enforce CI client transport parity with executable tests

### Decision
Add deterministic parity enforcement for CI command wrapper transport surfaces:

- introduce `tools/ci/test_client_transport_parity.py`,
- require required/proposal/instruction clients to import and use
  `tools/ci/core_cli_client.py`,
- ban reintroduction of local transport loops in those clients
  (tempfile command loops, inline stale-subcommand handling),
- include this test in `mise run ci-pipeline-test`.

### Rationale
After transport consolidation, parity needed an executable guard so wrapper
surfaces could not silently regress to duplicated local transport behavior.

### Consequences
- command-wrapper reduction has a concrete, merge-gated invariant.
- bd-33 parity scope now includes wrapper transport surface checks, not only
  docs/spec-level coherence.

---

## 2026-02-22 — Decision 0068: Add PREMATH-COHERENCE obligation-set parity to scope checker

### Decision
Extend `scope_noncontradiction` in `premath-coherence` to enforce parity between:

- required coherence obligation IDs implemented by the checker, and
- obligation IDs listed in `draft/PREMATH-COHERENCE` §3.

Add explicit contract surface bindings for the PREMATH-COHERENCE obligation
section bounds (`coherenceSpecPath`, `coherenceSpecObligationStart`,
`coherenceSpecObligationEnd`) and fail with deterministic classes when drift is
detected (`coherence_spec_missing_obligation`,
`coherence_spec_unknown_obligation`).

### Rationale
The checker already enforced parity between BIDIR obligation vocabulary and
kernel registry exports, but the coherence-obligation normative list itself was
not executable. This created a doc/runtime drift gap in the same obligation
family.

### Consequences
- coherence checker now guards PREMATH-COHERENCE §3 as an executable parity
  surface.
- contract surfaces explicitly bind both BIDIR and PREMATH-COHERENCE obligation
  sections.
- bd-33 parity coverage includes required coherence obligation vocabulary drift.

---

## 2026-02-22 — Decision 0069: Add end-to-end CLI rejection witness for coherence obligation drift

### Decision
Add a `premath-cli` smoke test that mutates `PREMATH-COHERENCE` §3 obligation
IDs via a temporary coherence contract binding and asserts `coherence-check`
returns a rejected witness with deterministic drift classes:

- `coherence.scope_noncontradiction.coherence_spec_missing_obligation`
- `coherence.scope_noncontradiction.coherence_spec_unknown_obligation`

### Rationale
Decision 0068 added checker-level parity enforcement and unit coverage, but the
CLI surface did not yet prove this drift path end-to-end. The smoke test closes
that boundary by validating witness behavior through the canonical command
surface.

### Consequences
- coherence obligation-list drift is now covered at both checker unit and CLI
  witness layers.
- bd-33 parity scope gains executable E2E regression protection for this drift
  class.

---

## 2026-02-22 — Decision 0070: Close coherence-contract cache bindings over contract-declared surfaces

### Decision
Update `tools/conformance/run_fixture_suites.py` so the `coherence-contract`
suite cache-input closure is derived from `draft/COHERENCE-CONTRACT.json`:

- include all `surfaces.*Path` and `surfaces.*Root` entries,
- include top-level `expectedOperationPaths[]`,
- keep baseline fallback inputs for deterministic behavior if contract parsing
  fails.

Add `tools/conformance/test_run_fixture_suites.py` and gate it in
`ci-pipeline-test`.

### Rationale
The prior cache binding for `coherence-contract` omitted several files read by
`coherence-check` (for example `PREMATH-COHERENCE`, `SPEC-INDEX`, capability
manifests, and operation paths). That allowed stale cache hits when those
surfaces changed.

### Consequences
- conformance cache validity for `coherence-contract` now tracks the full
  checker-read surface declared by contract.
- cache hits cannot bypass coherence-check execution after relevant doc/surface
  edits.

---

## 2026-02-22 — Decision 0071: Add cache-ref drift proof for coherence-spec changes

### Decision
Add a deterministic unit test in
`tools/conformance/test_run_fixture_suites.py` proving
`coherence-contract` suite cache refs drift when
`PREMATH-COHERENCE` content changes.

The test:

- uses the real `coherence-contract` suite input closure,
- swaps only the coherence-spec input path with a mutated temporary copy,
- asserts `params_hash` stays constant while `material_digest` and `cache_ref`
  both change.

### Rationale
Decision 0070 closed cache input coverage, but we still needed an executable
proof that the suite plan actually responds to edits on a contract-declared doc
surface and cannot produce stale cache hits.

### Consequences
- cache drift on coherence-spec edits is now explicitly regression-tested.
- `bd-33` gains stronger cache correctness evidence without expanding command
  surface.

---

## 2026-02-22 — Decision 0072: Add overlayDocs-derived files to coherence cache input closure

### Decision
Extend `load_coherence_contract_input_paths()` so `coherence-contract` cache
inputs include overlay markdown files derived from contract `overlayDocs`:

- each `overlayDocs` entry `x` maps to `specs/premath/{x}.md`.

Add unit coverage asserting inclusion of
`specs/premath/profile/ADJOINTS-AND-SITES.md`.

### Rationale
`coherence-check` evaluates overlay file existence in
`overlay_traceability`, but prior cache-input closure did not include those
derived file paths. That could allow stale cache hits when overlay files drift.

### Consequences
- coherence-contract cache bindings now include overlay file surfaces read by
  checker semantics.
- cache hits remain invalidated when overlay docs change or disappear.

---

## 2026-02-22 — Decision 0073: Bind coherence-contract cache inputs to kernel obligation authority source

### Decision
Extend `load_coherence_contract_input_paths()` to include:

- `crates/premath-kernel/src`

for the `coherence-contract` suite cache-input closure.

### Rationale
`coherence-check` consumes kernel obligation registry authority from
`premath-kernel`. Without binding kernel source into the suite cache plan,
changes to obligation authority could be skipped by stale conformance cache
hits.

### Consequences
- coherence-contract cache refs now drift when kernel obligation authority
  source changes.
- cache validity aligns with checker authority dependencies across
  kernel/coherence layers.

---

## 2026-02-22 — Decision 0074: Bind coherence-contract cache inputs to Cargo manifests

### Decision
Extend `load_coherence_contract_input_paths()` to include repository Cargo
manifests:

- `Cargo.toml`
- `Cargo.lock`

for `coherence-contract` suite cache-input closure.

### Rationale
`coherence-check` behavior can drift when dependency graph or crate feature
resolution changes. Without Cargo manifests in cache bindings, those changes
could be skipped by stale conformance cache hits.

### Consequences
- coherence-contract cache refs now invalidate on workspace dependency/feature
  changes.
- cache validity remains aligned with executable checker runtime composition.

---

## 2026-02-22 — Decision 0075: Introduce span/square commutation obligation and draft spec

### Decision
Add a first-class coherence obligation for typed span/square commutation:

- new required obligation id: `span_square_commutation`,
- new draft spec: `draft/SPAN-SQUARE-CHECKING`,
- new coherence-site vectors:
  - `golden/span_square_commutation_accept`
  - `adversarial/span_square_commutation_reject`.

Implement checker hook in `premath-coherence` via site-obligation evaluator
`evaluate_site_case_span_square_commutation`.

### Rationale
Pipeline/base-change witness squares were previously implicit across checker and
CI surfaces. Adding a minimal span/square typed layer makes this boundary
explicit without introducing a parallel authority surface.

### Consequences
- span/square commutation is now merge-gated under `coherence-check`.
- the new typed layer is integrated across spec index, unification doctrine,
  traceability matrix, and executable fixtures.

---

## 2026-02-22 — Decision 0076: Tighten span/square vectors with invariance and digest-mismatch adversarial coverage

### Decision
Extend `coherence-site` vectors for `span_square_commutation` with:

- invariance case:
  - `invariance/span_square_commutation_permuted_accept`
- adversarial digest mismatch case:
  - `adversarial/span_square_commutation_digest_mismatch_reject`.

### Rationale
Initial span/square vectors proved baseline accept/reject behavior. Additional
coverage closes two important boundaries:

- permutation invariance of span declarations,
- deterministic rejection when square witness digest is not bound to canonical
  square fields.

### Consequences
- span/square layer now has explicit invariance + digest-integrity checks in
  executable conformance fixtures.

---

## 2026-02-22 — Decision 0077: Require golden/adversarial polarity coverage per coherence-site obligation

### Decision
Tighten `coherence-site` checker semantics so each matched site obligation
vector set must include:

- at least one `golden/` vector, and
- at least one `adversarial/` vector.

Missing either polarity now rejects with deterministic failure classes:

- `coherence.<obligation_id>.missing_golden_vector`
- `coherence.<obligation_id>.missing_adversarial_vector`.

### Rationale
Site obligations are checker authority surfaces. Requiring both acceptance and
rejection exemplars for each obligation keeps the fixture contract expressive
while minimizing accidental under-specification.

### Consequences
- coherence checker now enforces per-obligation fixture polarity coverage.
- new unit tests cover missing-golden, missing-adversarial, and both-present
  passing cases.

---

## 2026-02-22 — Decision 0078: Require semantic polarity coverage for coherence-site obligations

### Decision
Extend `coherence-site` polarity enforcement so each matched site obligation
vector set must include semantic result polarity from `expect.result`:

- at least one vector with `accepted`,
- at least one vector with `rejected`.

Missing either semantic result polarity now rejects with deterministic failure
classes:

- `coherence.<obligation_id>.missing_expected_accepted_vector`
- `coherence.<obligation_id>.missing_expected_rejected_vector`.

### Rationale
Path prefix polarity (`golden/` and `adversarial/`) is necessary but not
sufficient. Semantic result polarity closes mislabeling gaps where prefixes can
look balanced while all vectors assert the same expected result.

### Consequences
- coherence checker now enforces both path polarity and semantic result
  polarity for site obligations.
- unit tests now cover missing-expected-accept, missing-expected-reject, and
  mixed semantic polarity pass cases.

---

## 2026-02-22 — Decision 0079: Scope coherence-site vector parsing by obligation map

### Decision
Require `coherence-site/manifest.json` to declare `obligationVectors` mapping
from obligation id to vector ids. Update checker semantics so each obligation
parses/evaluates only vectors in its mapped scope.

### Rationale
With one shared site manifest, malformed unrelated vectors could fail multiple
obligations. Obligation-scoped vector parsing removes that blast radius while
preserving one canonical fixture surface.

### Consequences
- coherence checker now emits deterministic manifest-scope failures when
  obligation mappings are missing or inconsistent.
- unscoped malformed vectors no longer fail untouched obligations.
- regression test added for scope isolation behavior.

---

## 2026-02-22 — Decision 0080: Enforce invariance-pair contract for coherence-site vectors

### Decision
Require `invariance/` site vectors to carry scenario/profile metadata and to be
validated as deterministic profile pairs:

- each invariance vector case MUST declare non-empty
  `semanticScenarioId` and `profile`,
- for each obligation id + `semanticScenarioId`, checker input MUST include
  exactly two invariance vectors with distinct profiles,
- paired vectors MUST evaluate to the same result and failure-class set.

### Rationale
Invariance vectors existed but were not structurally constrained as profile
pairs. Enforcing pair shape prevents drift where invariance is nominally present
but not actually tested across profile choices.

### Consequences
- coherence checker now emits deterministic invariance failures for missing
  metadata, missing/extra pairs, non-distinct profiles, or semantic mismatch.
- coherence-site fixtures now include explicit local/external pair vectors for
  invariance scenarios.
- unit tests now cover pair-count mismatch, pair-result mismatch, and passing
  invariance pairs.

---

## 2026-02-22 — Decision 0081: Harmonize invariance-pair contract across coherence fixture families

### Decision
Apply the same invariance-pair contract used by `coherence-site` to
`coherence-transport`:

- `invariance/` transport vectors MUST declare non-empty
  `semanticScenarioId` and `profile`,
- for each `semanticScenarioId` under `transport_functoriality`, checker input
  MUST include exactly two invariance vectors with distinct profiles,
- paired vectors MUST evaluate to identical result and failure-class sets.

### Rationale
Coherence fixture families were drifting: site vectors had enforced invariance
pair semantics while transport vectors only had single-vector invariance
coverage. One shared contract keeps the checker surface minimal and expressive.

### Consequences
- transport checker now emits deterministic invariance-pair failure classes
  aligned with site semantics.
- transport fixtures now include explicit local/external invariance pair vectors
  for the same semantic scenario.
- unit coverage now includes transport invariance pair-count mismatch,
  pair-result mismatch, and passing pair cases.

---

## 2026-02-22 — Decision 0082: Enforce transport polarity coverage parity

### Decision
Apply site-style polarity requirements to `coherence-transport` vectors under
`transport_functoriality`:

- require at least one matched `golden/` vector,
- require at least one matched `adversarial/` vector,
- require at least one matched `expectedResult = accepted`,
- require at least one matched `expectedResult = rejected`.

### Rationale
Transport checker semantics were still weaker than site semantics on polarity
coverage. Enforcing the same minimal polarity contract closes under-specification
without adding new surface types.

### Consequences
- transport checker now emits deterministic polarity failures aligned with site
  vocabulary:
  - `missing_golden_vector`
  - `missing_adversarial_vector`
  - `missing_expected_accepted_vector`
  - `missing_expected_rejected_vector`
- transport witness details now expose matched vector-kind and expected-result
  counters.
- unit tests now cover all four missing-polarity modes and one passing mixed
  polarity case.

---

## 2026-02-22 — Decision 0083: Clarify lane separation for SigPi, CwF, spans, and Squeak

### Decision
Adopt an explicit lane-separation contract for architectural composition:

1. semantic doctrine lane: kernel + Gate + bidirectional obligation authority,
2. strict checker lane: coherence/CwF strict-equality control-plane checks,
3. witness commutation lane: span/square typed commutation artifacts,
4. runtime transport lane: Squeak world/location transport and site checks.

SigPi (`\Sigma_f -| f* -| \Pi_f`, shorthand `sig\Pi`) obligations remain
semantic-lane authority.
Squeak transport/site evidence remains capability-scoped transport lane.
Composition between these lanes MUST route through one canonical obligation and
witness authority boundary; no second semantic authority schema is allowed.

### Rationale
Recent capability growth (adjoints-sites + Squeak + span/square + CwF
obligations) increases expressiveness but risks architectural duplication if lane
ownership is implicit.

Making lane boundaries explicit preserves the doctrine rule:
minimum canonical encoding, maximum derived expressiveness.

### Consequences
- `draft/UNIFICATION-DOCTRINE` now includes a normative lane map and composition
  constraints for SigPi + Squeak integration.
- `draft/SPEC-INDEX` now documents joint capability guidance and reading order
  for composed SigPi + Squeak systems.
- Future composed profiles should add vectors/contracts by routing through
  existing obligation/witness authority, not by adding parallel semantic
  encodings.

---

## 2026-02-22 — Decision 0084: Normalize SigPi naming and require spans in composed overlays

### Decision
Adopt one naming/notation convention and one composition boundary rule:

1. prose and identifier surfaces MUST use `SigPi` (not `Sig/Pi`),
2. mathematical rendering SHOULD use `\Sigma_f -| f* -| \Pi_f`
   (shorthand `sig\Pi` allowed),
3. composed SigPi + Squeak systems MUST route cross-lane pullback/base-change
   claims through typed span/square witnesses (`draft/SPAN-SQUARE-CHECKING`).

### Rationale
Topos/site and profile docs now rely on one composed semantic story. Keeping
names aligned and making spans explicit prevents drift where composition is
described semantically but under-specified operationally.

### Consequences
- `profile/ADJOINTS-AND-SITES` now includes explicit SigPi naming/notation and
  span/square projection boundary text.
- `draft/UNIFICATION-DOCTRINE` and `draft/SPEC-INDEX` now state SigPi +
  Squeak + spans composition in the same lane-separation language.
- Open issue wording should align with the same convention (`SigPi`, spans
  explicit in composition scope).

---

## 2026-02-22 — Decision 0085: Clarify Unified Evidence Plane contract and lane registry scaffold

### Decision
Clarify unification direction by adding two explicit artifacts:

1. `draft/UNIFICATION-DOCTRINE` §10 now defines a Unified Evidence Plane
   contract (`Ev : Ctx^op -> V`) with:
   - canonical attested evidence surface semantics,
   - universal factoring rule (`F => Ev`) for control-plane artifact families,
   - compact law set (transport, descent/glue-or-witness, determinism binding,
     authority-boundary non-bypass),
   - explicit span/square routing for cross-lane pullback/base-change claims.
2. `draft/CONTROL-PLANE-CONTRACT.json` now carries a machine-readable lane
   registry scaffold:
   - `evidenceLanes`,
   - `laneArtifactKinds`,
   - `laneOwnership`,
   - `laneFailureClasses`.

### Rationale
Unification intent was distributed across lane-separation prose and issue notes.
Adding an explicit `Ev` contract and lane constants reduces ambiguity and gives
one stable reference for future checker/conformance integration.

### Consequences
- `draft/SPEC-INDEX` now points to the Unified Evidence Plane contract in
  `UNIFICATION-DOCTRINE` §10 and adds a dedicated reading path.
- `tools/ci/control_plane_contract.py` now validates and exports optional lane
  registry fields for deterministic adapter use.
- Full lane-registry enforcement in `premath-coherence` remains tracked as
  implementation work (contract constants exist; checker parity enforcement is
  a follow-up).

---

## 2026-02-22 — Decision 0086: Add composed overlay execution contract and ordering guidance

### Decision
Clarify the composed SigPi + spans + Squeak path by adding one explicit profile
execution contract:

1. `profile/ADJOINTS-AND-SITES` adds Section 10 with:
   - capability/required-check routing guidance,
   - composed obligation boundary language,
   - authority mapping table across kernel/coherence/span-square/profile/runtime,
   - deterministic witness-lineage requirements.
2. `draft/SPEC-INDEX` reading guidance now points composed integrations to
   `profile/ADJOINTS-AND-SITES` Section 10.
3. `docs/design/ARCHITECTURE-MAP` includes a current unification execution
   order to keep issue execution aligned with one authority path.

### Rationale
Lane-separation and Unified Evidence Plane rules existed, but composed-overlay
execution details were split across multiple docs. A single composed profile
section plus explicit ordering guidance reduces drift during active unification
work.

### Consequences
- composed overlay ownership and required-check routing are now explicit in one
  profile location.
- architecture-level docs now show an operational sequence that matches active
  unification issues.
- no semantic authority moved: kernel/gate remain admissibility authority.

---

## 2026-02-22 — Decision 0087: Consolidate design docs into explicit runtime/control lanes

### Decision
Consolidate non-normative design surfaces into explicit lanes and add a
canonical Squeak transport/placement design entrypoint:

1. `docs/design/README.md` now defines lane groups:
   - Tusk runtime (inside one world),
   - Squeak/SigPi transport+placement (between worlds),
   - control/CI architecture composition.
2. Add `docs/design/SQUEAK-DESIGN.md` as canonical design guidance for Squeak
   transport/placement.
3. Retain `docs/design/TUSK-SIGPI.md` as a compatibility alias that points to
   `SQUEAK-DESIGN.md`.

### Rationale
`docs/design` mixed Tusk-specific and cross-layer control/transport material in
one presentation, which made boundary ownership unclear and increased drift risk
between runtime and transport guidance.

### Consequences
- design docs now have one explicit canonical path for Squeak transport and
  runtime placement.
- legacy references to `TUSK-SIGPI.md` continue to resolve without breakage.
- normative authority remains unchanged under `specs/`.

---

## 2026-02-22 — Decision 0088: Enforce lane-registry parity in coherence gate-chain checks

### Decision
Close the contract-to-checker gap for lane registry scaffolding by enforcing
optional `CONTROL-PLANE-CONTRACT` lane fields in `gate_chain_parity`:

1. when lane fields are present, `premath-coherence` MUST validate lane IDs for
   non-empty uniqueness,
2. `laneArtifactKinds` MUST bind only to declared lane IDs with non-empty kind
   sets,
3. `laneOwnership` MUST preserve checker-core CwF ownership boundaries and
   require cross-lane witness routing through `span_square_commutation`,
4. `laneFailureClasses` MUST include the required lane-boundary class surface.

### Rationale
Decision 0085 introduced the lane-registry scaffold as a typed contract
artifact, but checker parity enforcement remained a follow-up. Leaving this gap
open risked contract drift where lane boundaries existed in schema only.

### Consequences
- `crates/premath-coherence` now emits deterministic
  `coherence.gate_chain_parity.*` failures for lane registry violations.
- unit tests cover accept/reject cases for duplicate lane IDs, unknown lane-kind
  bindings, missing cross-lane routes, and ownership boundary violations.
- `draft/PREMATH-COHERENCE` §4.3 now states lane-registry fail-closed parity
  behavior when lane fields are present.

---

## 2026-02-22 — Decision 0089: Add executable lane-ownership vectors to gate-chain parity

### Decision
Extend `gate_chain_parity` with executable vector coverage for lane-ownership
boundaries by routing it through the existing coherence-site fixture harness:

1. add `gate_chain_parity` vector scope to
   `tests/conformance/fixtures/coherence-site/manifest.json`,
2. add smoke vectors for:
   - accepted canonical lane ownership + span/square route,
   - rejected checker-core ownership violation,
   - rejected missing cross-lane route,
3. add invariance pair vectors (`local`/`external`) for the same semantic lane
   ownership scenario.

### Rationale
Unit tests covered lane-registry enforcement, but boundary behavior still lacked
fixture-level executable evidence in the same conformance path used by other
coherence obligations.

### Consequences
- `gate_chain_parity` now emits `laneOwnershipVectors` witness details with
  matched polarity/invariance accounting.
- conformance closure validates lane-ownership boundaries through
  `premath coherence-check` and `mise run conformance-run`.

---

## 2026-02-22 — Decision 0090: Add composed SigPi+Squeak+span capability vectors

### Decision
Extend `capabilities.adjoints_sites` vectors with a composed cross-lane slice
that requires:

1. combined capability claim surface (`capabilities.adjoints_sites` +
   `capabilities.squeak_site`),
2. cross-lane pullback/base-change routing through
   `span_square_commutation`,
3. deterministic span-square witness digest material,
4. deterministic runtime transport location binding (`loc1_*` refs),
5. local/external invariance for the same composed semantic scenario.

### Rationale
Composed overlay contract text existed in profile/spec docs, but executable
capability vectors were still lane-local. Adding composed vectors closes the
traceability gap between profile doctrine and conformance execution.

### Consequences
- `tools/conformance/run_capability_vectors.py` now evaluates composed
  adjoints-site vectors with deterministic failure classes:
  `cross_lane_capability_missing`, `cross_lane_route_missing`,
  `cross_lane_witness_mismatch`, and `cross_lane_transport_mismatch`.
- `tests/conformance/fixtures/capabilities/capabilities.adjoints_sites/`
  includes composed golden/adversarial/invariance vectors.
- `draft/CAPABILITY-VECTORS` and
  `profile/ADJOINTS-AND-SITES` now explicitly require composed route/transport
  vector coverage.

---

## 2026-02-22 — Decision 0091: Route Observation projection through one core projector path

### Decision
Unify Observation Surface projection for CI/CLI consumers through one core
projector command path:

1. add `premath observe-build` as the canonical projector entrypoint,
2. implement projection/build logic in `premath-surreal` (`build_surface`,
   `build_events`) with deterministic fail-closed behavior,
3. migrate `mise run ci-observation-build` to `premath observe-build`,
4. migrate semantic invariance check to compare against a fresh
   `premath observe-build` result,
5. keep `tools/ci/observation_surface.py` as a compatibility wrapper that calls
   the core projector command (no parallel reducer authority).

### Rationale
Observation projection semantics were previously encoded in Python while CLI/MCP
query surfaces consumed a separate Rust path. That duplicated projector logic
and created drift risk in summary/coherence projections.

### Consequences
- CI build/check and CLI observation surfaces now share one projector authority
  path.
- deterministic observation projection remains available to scripts/tests via a
  compatibility wrapper.
- new CLI smoke coverage and `premath-surreal` unit coverage guard the unified
  projector behavior.

---

## 2026-02-22 — Decision 0092: Add fail-closed drift-budget sentinel gate

### Decision
Add one deterministic drift-budget checker task to the baseline closure:

1. introduce `tools/ci/check_drift_budget.py` and `mise run ci-drift-budget-check`,
2. fail closed with deterministic `driftClasses` across:
   - SPEC-INDEX capability map vs CAPABILITY-REGISTRY/COHERENCE-CONTRACT docs map,
   - CONTROL-PLANE lane bindings vs coherence checker lane expectations,
   - COHERENCE-CONTRACT required obligation sets vs checker-exported required sets,
   - canonical SigPi notation policy in normative docs,
   - coherence-suite cache input closure for coherence/control-plane loaders.

### Rationale
`coherence-check` and docs-coherence checks validate many invariants, but drift
signals were distributed across outputs and not exposed as one compact control
plane sentinel surface. A single fail-closed drift-budget check tightens
unification execution and gives one deterministic summary for CI consumption.

### Consequences
- baseline now includes `ci-drift-budget-check`,
- CI tooling docs and command surfaces include the new gate,
- added deterministic unit tests (`tools/ci/test_drift_budget.py`) covering each
  drift class and cache-closure input scope expectations.

---

## 2026-02-22 — Decision 0093: Add control-plane schema lifecycle contract and alias-window enforcement

### Decision
Adopt one typed schema lifecycle table in
`draft/CONTROL-PLANE-CONTRACT.json` and route client-side kind validation
through it.

Implemented scope:

1. add `schemaLifecycle` with canonical kind families for:
   - `*.contract.v*` control-plane kind,
   - required/instruction witness kinds,
   - required decision kind,
   - required projection policy kind,
   - required delta kind;
2. allow compatibility aliases only with explicit `supportUntilEpoch` and
   canonical `replacementKind`,
3. resolve accepted aliases to canonical kind during validation,
4. fail closed deterministically when alias windows are expired or kinds are
   unsupported.

### Rationale
Version and alias handling existed as ad-hoc string checks across CI clients.
That made compatibility policy implicit and harder to audit. A single lifecycle
table keeps minimum encoding while preserving controlled compatibility windows.

### Consequences
- `tools/ci/control_plane_contract.py` is now the canonical lifecycle resolver
  for schema kind families.
- required witness/decision/projection/delta and instruction witness client
  validators now consume the shared resolver.
- tests now cover:
  - accepted legacy alias behavior inside support window,
  - deterministic rejection past support window (`expired` failure path).
- `draft/UNIFICATION-DOCTRINE` now states normative lifecycle/deprecation rules
  for contract/witness/projection kind families and migration witness
  expectations.

---

## 2026-02-22 — Decision 0094: Enforce schema lifecycle epoch discipline in CI loader paths

### Decision
Tighten `schemaLifecycle` validation in `tools/ci/control_plane_contract.py`
with one deterministic rollover policy:

1. all compatibility aliases in one lifecycle table MUST share one
   `supportUntilEpoch` rollover epoch,
2. rollover runway (`supportUntilEpoch - activeEpoch`) MUST be strictly
   positive,
3. rollover runway MUST be bounded to 12 months in the CI implementation
   profile.

Validation remains fail-closed during control-plane contract load.

### Rationale
Alias-window checks were present, but rollover discipline across families was
implicit. Without one shared epoch and bounded runway, compatibility windows can
drift and silently accumulate long-lived aliases.

### Consequences
- CI loader/import surfaces now reject mixed rollover epochs and unbounded alias
  runway at contract load time.
- exported lifecycle metadata now includes deterministic epoch-discipline fields
  (`rolloverEpoch`, `aliasRunwayMonths`, `maxAliasRunwayMonths`) for downstream
  diagnostics.
- unit coverage in `tools/ci/test_control_plane_contract.py` now includes
  mixed-epoch and overlong-runway rejection paths.

---

## 2026-02-22 — Decision 0095: Make Unified Evidence Plane factorization explicitly fail-closed

### Decision
Tighten `draft/UNIFICATION-DOCTRINE` Unified Evidence Plane (`§10`) to require
explicit universal factorization semantics:

1. implementations claiming Unified Evidence Plane MUST define one indexed
   evidence family `Ev : Ctx^op -> V`,
2. each control-plane artifact family MUST factor through one deterministic
   natural transformation `eta_F : F => Ev`,
3. factorization MUST be unique up to canonical projection equality for fixed
   deterministic bindings,
4. non-factorable or ambiguous factorization MUST reject deterministically via
   fail-closed factorization classes.

### Rationale
The doctrine already declared one evidence surface, but wording remained partly
advisory (`SHOULD`) and did not state the fail-closed boundary when routing is
missing or ambiguous. Explicit factorization semantics tighten the authority
boundary with minimum additional encoding.

### Consequences
- `draft/UNIFICATION-DOCTRINE` now defines deterministic fail-closed
  factorization classes:
  - `unification.evidence_factorization.missing`
  - `unification.evidence_factorization.ambiguous`
  - `unification.evidence_factorization.unbound`
- `draft/SPEC-INDEX` now requires (MUST) unified evidence factoring in lane
  ownership guidance.
- `tools/conformance/check_docs_coherence.py` now enforces marker-level presence
  for Unified Evidence factoring and fail-closed boundary language in normative
  docs.

---

## 2026-02-22 — Decision 0096: Promote span/square composition laws to executable coherence surface

### Decision
Extend `draft/SPAN-SQUARE-CHECKING` and `span_square_commutation` checking to
cover composition laws explicitly:

1. add optional `compositionLaws` witness surface for span/square law rows,
2. bind each composition law row to deterministic digest
   (`sqlw1_ + SHA256(JCS(LawCore))`),
3. require accepted-law coverage for:
   - `span_identity`,
   - `span_associativity`,
   - `square_identity`,
   - `square_associativity_horizontal`,
   - `square_associativity_vertical`,
   - `square_hv_compatibility`,
   - `square_interchange`,
4. evaluate square expressions through deterministic horizontal/vertical
   composition normalization with fail-closed shape checks.

### Rationale
Span/square checking previously validated only single-square commutation. The
algebraic closure track (`bd-123`) requires composition as first-class witness
data so pipeline/base-change coherence is expressed as one typed executable
surface, not as implicit prose-only laws.

### Consequences
- `premath-coherence` now evaluates optional composition-law expressions and
  enforces deterministic accepted/rejected law semantics.
- coherence-site fixtures include new vectors:
  - `golden/span_square_commutation_composition_accept`
  - `adversarial/span_square_commutation_composition_missing_law_reject`
  - `invariance/span_square_commutation_composition_accept`
  - `invariance/span_square_commutation_composition_accept_external`
- docs coherence checks now enforce composition-law markers in
  `SPAN-SQUARE-CHECKING` and `PREMATH-COHERENCE`.

---

## 2026-02-22 — Decision 0097: Define CwF <-> sig\Pi bridge as vocabulary-preserving boundary

### Decision
Specify an explicit bridge contract between strict CwF checker equalities and
semantic SigPi obligations without changing ownership lanes.

Implemented scope:

1. add normative bridge section to `profile/ADJOINTS-AND-SITES`:
   - strict vs semantic authority split,
   - admissible bridge morphisms,
   - CwF->semantic law mapping table,
   - deterministic failure/ownership constraints;
2. add checker-boundary clause in `draft/PREMATH-COHERENCE` requiring bridge
   routing to preserve existing obligation IDs;
3. add lane-reference updates in `draft/SPEC-INDEX` and
   `draft/UNIFICATION-DOCTRINE` so bridge behavior remains explicit in the
   canonical unification path.

### Rationale
CwF strict equalities and SigPi semantic obligations were already present but
their translation boundary was implicit. Explicit bridge mapping closes a drift
gap while preserving the minimum-encoding rule: no new authority vocabulary and
no re-ownership of checker/semantic lanes.

### Consequences
- CwF bridge semantics are now explicit and traceable in normative docs.
- Bridge mapping is fail-closed and vocabulary-preserving:
  checker keeps `cwf_*`; semantic lane keeps
  `stability/locality/descent_*/adjoint_*`.
- `tools/conformance/check_docs_coherence.py` now enforces bridge markers in
  `ADJOINTS-AND-SITES`, `PREMATH-COHERENCE`, and `SPEC-INDEX`.

---

## 2026-02-22 — Decision 0098: Add cross-layer obstruction algebra and conformance roundtrip

### Decision
Adopt a typed cross-layer obstruction algebra as a secondary projection over
existing failure classes, with deterministic roundtrip semantics.

Implemented scope:

1. `draft/UNIFICATION-DOCTRINE` now defines §11 (`Cross-layer Obstruction
   Algebra`) with:
   - constructor families (`semantic`, `structural`, `lifecycle`,
     `commutation`),
   - deterministic projection pair (`project_obstruction`,
     `canonical_obstruction_class`),
   - initial mapping table spanning Gate/BIDIR, coherence, lifecycle, and
     unification factorization classes,
   - issue-memory projection tag convention (`obs.<family>.<tag>`).
2. `capabilities.ci_witnesses` now includes executable obstruction roundtrip
   vectors (golden + adversarial).
3. capability evaluator now checks deterministic constructor/class roundtrip and
   deterministic issue-tag projection for fixed source classes.

### Rationale
Failure classes were already deterministic inside each lane, but cross-layer
reasoning lacked one typed projection surface for analysis/discovery. Adding an
algebraic projection keeps minimum encoding (source classes unchanged) while
improving expressiveness for coherence/issue-memory workflows.

### Consequences
- Source failure-class authority remains unchanged; obstruction constructors are
  additive metadata only.
- Cross-layer roundtrip is now executable under `capabilities.ci_witnesses`.
- docs coherence checks enforce presence of obstruction algebra clauses and
  capability-vector coverage language.

---

## 2026-02-22 — Decision 0099: Define Tusk harness contract as runtime-control overlay

### Decision
Adopt a concise harness contract for long-running agents as a Tusk runtime
control overlay (design layer), without adding a new semantic authority path.

Implemented scope:

1. add `docs/design/TUSK-HARNESS-CONTRACT.md` defining:
   - hook model: `boot` / `step` / `stop`,
   - durability boundaries (fresh-context restartability, compaction/offload,
     explicit sub-agent boundaries),
   - deterministic verification/retry boundary,
   - trajectory/evidence capture contract;
2. map harness clauses to existing surfaces:
   - `mcp-serve` (instruction-linked mutation path),
   - instruction pipeline + witness verification/decision,
   - Observation Surface v0 projection/query,
   - issue/event memory substrates;
3. record explicit current gaps and a 2-4 slice implementation plan
   (handoff artifact, feature ledger, trajectory rows, retry-policy table);
4. cross-link harness overlay from `docs/design/README.md`,
   `docs/design/TUSK-ARCHITECTURE.md`, and `docs/design/ARCHITECTURE-MAP.md`.

### Rationale
The unification closure track needs a concrete long-run execution contract for
agents, but semantic authority must remain in kernel/checker/discharge
surfaces. A Tusk harness overlay gives operational structure with minimum
encoding and avoids duplicating admissibility semantics in CI or planner layers.

### Consequences
- Harness behavior is now explicit and composable with existing runtime/control
  surfaces.
- No change to semantic authority boundaries:
  model outputs remain proposals; checker/discharge/witness artifacts remain
  authoritative.
- Follow-on implementation can proceed as bounded slices without forcing full
  mathematical generalization up front.

---

## 2026-02-22 — Decision 0100: Canonical harness retry-policy contract for pipeline wrappers

### Decision
Adopt one digest-bound retry-policy artifact for provider-neutral pipeline
wrappers and enforce it through a shared helper.

Implemented scope:

1. add canonical retry policy registry + artifact:
   - `policies/control/README.md`
   - `policies/control/harness-retry-policy-v1.json`
2. add shared deterministic policy helper:
   - `tools/ci/harness_retry_policy.py`
   - validates schema + digest
   - parses witness failure classes
   - returns typed attempt-level retry/escalation decisions
3. enforce policy in wrapper entrypoints:
   - `tools/ci/pipeline_required.py`
   - `tools/ci/pipeline_instruction.py`
4. emit retry policy + retry history in wrapper summary outputs.

### Rationale
The harness contract required fail-closed classify/retry/escalate behavior, but
the operational table was implicit. A single digest-bound policy keeps retry
logic deterministic and shared across required/instruction wrapper paths without
moving semantic authority out of checker/witness surfaces.

### Consequences
- Retry behavior is now explicit, auditable, and test-covered in one policy
  surface.
- Wrapper failures classify from emitted witness artifacts, not ad-hoc stderr.
- Escalation actions are typed (`issue_discover`, `mark_blocked`, `stop`), with
  automatic issue-memory mutation wiring left as follow-on work.

---

## 2026-02-22 — Decision 0101: Bind terminal retry escalation actions to premath-bd mutations

### Decision
Bind terminal retry escalation actions from provider-neutral pipeline wrappers
to `premath issue` mutation commands via one shared bridge.

Implemented scope:

1. add shared bridge:
   - `tools/ci/harness_escalation.py`
2. wrapper integration:
   - `tools/ci/pipeline_required.py`
   - `tools/ci/pipeline_instruction.py`
3. action mapping:
   - `issue_discover` -> `premath issue discover`
   - `mark_blocked` -> `premath issue update --status blocked --notes ...`
   - `stop` -> no mutation
4. active issue context contract:
   - `PREMATH_ACTIVE_ISSUE_ID` (fallback `PREMATH_ISSUE_ID`)
   - optional `PREMATH_ISSUES_PATH`

### Rationale
Retry policy classification without mutation execution leaves escalation as
informational output only. Binding terminal actions into `premath-bd` keeps
harness state progression in the same issue-memory authority surface and closes
the operational loop for long-running workflows.

### Consequences
- Terminal escalation now creates/updates issue-memory state deterministically
  when active issue context is present.
- Missing issue context produces deterministic skipped-escalation metadata.
- Mutation command failures are fail-closed in wrappers (non-success return
  with typed escalation error metadata).

---

## 2026-02-22 — Decision 0102: Promote harness retry/escalation bindings into typed spec surfaces

### Decision
Bind harness retry/escalation semantics into normative control-plane spec
artifacts rather than design docs only.

Implemented scope:

1. extend `draft/CONTROL-PLANE-CONTRACT.json` with `harnessRetry`:
   - policy kind/path,
   - escalation action vocabulary,
   - active issue context env keys and issues-path env key.
2. extend `tools/ci/control_plane_contract.py` loader + exported constants for
   `harnessRetry` and fail-closed contract validation.
3. extend drift-budget sentinel parity checks for harness retry fields.
4. update spec text:
   - `draft/PREMATH-COHERENCE` gate-chain parity semantics include
     `harnessRetry` contract presence/shape checks.
   - `raw/PREMATH-CI` adds retry/escalation control-loop binding clauses.
   - `draft/SPEC-INDEX` marks harness retry/escalation as part of
     `draft/CONTROL-PLANE-CONTRACT` informative control-plane constants.

### Rationale
The implementation had working retry/escalation behavior, but spec authority
was primarily in design docs + decision log. Typing these bindings into the
control-plane contract reduces drift risk and keeps CI/coherence loaders
fail-closed on schema divergence.

### Consequences
- Harness retry/escalation contract is now machine-bound in typed spec payloads.
- Drift checks enforce loader/contract parity for retry/escalation fields.
- Control-plane semantics remain non-authoritative for kernel admissibility.

---

## 2026-02-22 — Decision 0103: Resolve retry escalation issue context via harness-session fallback

### Decision
Extend terminal retry escalation issue-context resolution with a deterministic
fallback to harness-session artifacts, and bind that fallback into control-plane
contract checks.

Implemented scope:

1. escalation issue-context resolution order in `tools/ci/harness_escalation.py`:
   - `PREMATH_ACTIVE_ISSUE_ID`,
   - `PREMATH_ISSUE_ID`,
   - harness-session artifact `issueId` from:
     - `PREMATH_HARNESS_SESSION_PATH` (override),
     - `.premath/harness_session.json` (default).
2. fail-closed behavior for malformed/unreadable harness-session artifacts:
   - `escalation_session_invalid`,
   - `escalation_session_read_failed`.
3. contract + loader + drift-budget bindings:
   - `draft/CONTROL-PLANE-CONTRACT.json` `harnessRetry` adds:
     `sessionPathEnvKey`, `sessionPathDefault`, `sessionIssueField`,
   - `tools/ci/control_plane_contract.py` exports corresponding constants,
   - `tools/ci/check_drift_budget.py` enforces parity.
4. tests/docs/spec updates:
   - escalation fallback + fail-closed tests,
   - design docs now document env+session fallback as canonical path,
   - `draft/PREMATH-COHERENCE` parity text includes harness-session bindings.

### Rationale
Retry escalation mutation paths were wired but depended on explicit env setup in
every run context. Harness-session artifacts already carry active issue identity
for long-run continuity, so they should participate in deterministic fallback
resolution to reduce skipped escalations without adding parallel semantics.

### Consequences
- Escalation mutation paths are available in more harness executions by default.
- Missing issue context remains explicit (`skipped_missing_issue_context`) only
  after env+session resolution fails.
- Control-plane drift checks now fail closed if harness-session contract fields
  drift between spec payload and loader/checker surfaces.

---

## 2026-02-22 — Decision 0104: Adopt multi-lane work-memory contract

### Decision
Adopt one explicit work-memory lane split and write-discipline contract:

1. issue graph lane: `.premath/issues.jsonl` (authoritative mutable work state),
2. operations lane: `.premath/OPERATIONS.md` (operational conventions/evidence),
3. doctrine/decision lane: `specs/*` + `specs/process/decision-log.md`
   (boundary/lifecycle authority).

Implementation documentation:

- `docs/design/MEMORY-LANES-CONTRACT.md`

Associated surface updates:

- `docs/design/README.md` lane-map index,
- `AGENTS.md` memory-lane discipline section,
- `.premath/OPERATIONS.md` evidence table now carries `Issue` + `Decision`
  columns for deterministic cross-lane references.

### Rationale
Issue rows alone are insufficient for long-run agent memory: we also need stable
operational conventions/evidence and explicit doctrine decisions. Making the
lane split explicit keeps memory expressive while preserving one authority
boundary per concern.

### Consequences
- Agents/operators now have a canonical location for each class of memory write.
- Cross-lane references become deterministic (`issue-id`, optional
  `decision-id`) instead of ad-hoc note expansion.
- Issue-note compaction work (`bd-129`) is now naturally scoped as lane hygiene
  instead of implicit style preference.

---

## 2026-02-22 — Decision 0105: Add schema lifecycle governance modes (`rollover|freeze`)

### Decision
Extend control-plane schema lifecycle semantics with explicit governance mode
metadata and fail-closed validation.

Implemented scope:

1. add `schemaLifecycle.governance` in
   `draft/CONTROL-PLANE-CONTRACT.json` with:
   - `mode` (`rollover|freeze`)
   - `decisionRef`
   - `owner`
   - `rolloverCadenceMonths` (rollover-only)
   - `freezeReason` (freeze-only)
2. enforce deterministic governance validation in
   `tools/ci/control_plane_contract.py`:
   - rollover requires aliases and cadence-bound runway,
   - freeze requires no aliases and explicit freeze reason.
3. enforce schema-lifecycle governance checking in
   `crates/premath-coherence` gate-chain parity path.
4. extend drift-budget parity checks for loader-exported governance fields.
5. add process-level governance contract doc:
   - `specs/process/SCHEMA-LIFECYCLE-GOVERNANCE.md`
6. wire cross-references from lifecycle specs/design docs.

### Rationale
Lifecycle policy previously encoded epoch/runway mechanics but did not make
governance state explicit. We need deterministic distinction between active
rollover and explicit freeze states, plus accountable references for each
transition.

### Consequences
- Lifecycle checks now fail closed on governance-state mismatches, not only on
  alias expiry/format errors.
- Rollover cadence and freeze exceptions are now machine-checkable and linked to
  decision-log authority.
- Lifecycle semantics are no longer CI-loader-only; coherence checker now
  enforces the same governance state boundary.

---

## 2026-02-22 — Decision 0106: Stage Unified Evidence Plane typed internalization with deterministic rollback

### Decision
Define a normative staged migration path for Premath-native typed evidence
objects under `draft/UNIFICATION-DOCTRINE` §10.6.

Implemented scope:

1. add `§10.6 Typed evidence-object internalization stages (v0)` with four
   stages:
   - Stage 0: projection-locked parity,
   - Stage 1: typed-core dual projection,
   - Stage 2: canonical typed authority with compatibility alias,
   - Stage 3: typed-first cleanup.
2. require deterministic stage-gate preservation of:
   - universal factoring (`eta_F : F => Ev`),
   - deterministic bindings (`normalizerId + policyDigest`),
   - fail-closed factorization boundaries.
3. require deterministic rollback semantics:
   - no second authority artifact,
   - prior canonical identity bindings preserved,
   - decision-log + issue linkage before re-promotion.
4. cross-link migration guidance from `draft/SPEC-INDEX` lane ownership and the
   Unified Evidence Plane reading path.
5. enforce marker-level docs coherence checks for the new staged contract.

### Rationale
Unified Evidence Plane factorization was explicit, but migration from
payload-first witnesses to typed evidence objects remained roadmap-level.
Explicit staged gates and rollback constraints keep migration expressive while
preserving the minimum-encoding authority boundary.

### Consequences
- Typed `Ev` migration is now normative and replay-auditable.
- Compatibility windows remain lifecycle-governed rather than ad-hoc.
- Stage failures are handled by deterministic rollback, not parallel authority
  execution paths.

---

## 2026-02-22 — Decision 0107: Define Stage 1 typed-core profile and parity class boundary for `Ev`

### Decision
Add a minimal normative Stage 1 profile/class contract under
`draft/UNIFICATION-DOCTRINE` §10.6 to make typed-core dual-projection claims
machine-checkable.

Implemented scope:

1. add `§10.6.1 Stage 1 typed-core profile (minimum)` requiring:
   - one profile kind identifier,
   - deterministic binding fields (`normalizerId`, `policyDigest`),
   - one canonical typed-core identity function,
   - one deterministic authority->typed-core projection.
2. add `§10.6.2 Stage 1 dual-projection parity contract` requiring deterministic
   parity tuple evaluation and fail-closed rejection classes:
   - `unification.evidence_stage1.parity.missing`
   - `unification.evidence_stage1.parity.mismatch`
   - `unification.evidence_stage1.parity.unbound`
3. clarify in `draft/SPEC-INDEX` lane guidance that Stage 1 parity claims are
   bound to `§10.6.2` fail-closed class boundary.
4. extend docs-coherence checks/tests to enforce marker-level presence for the
   new Stage 1 profile and class contract text.

### Rationale
`§10.6` already defined staged internalization, but Stage 1 lacked explicit
minimal profile fields and deterministic parity error vocabulary. That left the
first implementation step underspecified.

### Consequences
- Stage 1 now has a precise minimum contract without introducing parallel
  semantic authority.
- Implementations can assert/reject Stage 1 parity deterministically with one
  stable class surface.
- Docs coherence checks now fail closed if Stage 1 profile/class clauses drift.

---

## 2026-02-22 — Decision 0108: Bind Stage 1 parity/rollback to executable vectors and deterministic rollback witness classes

### Decision
Complete Stage 1 execution slices by binding parity + rollback contracts into
coherence-site vectors, checker details, and normative rollback class surfaces.

Implemented scope:

1. extend `draft/UNIFICATION-DOCTRINE` with
   `§10.6.3 Stage 1 deterministic rollback witness contract`, including
   canonical rollback classes:
   - `unification.evidence_stage1.rollback.precondition`
   - `unification.evidence_stage1.rollback.identity_drift`
   - `unification.evidence_stage1.rollback.unbound`
2. extend `draft/CONTROL-PLANE-CONTRACT.json` with:
   - `evidenceStage1Parity` (typed-core parity metadata),
   - `evidenceStage1Rollback` (rollback witness metadata).
3. extend `premath-coherence` `gate_chain_parity` checks with fail-closed
   Stage 1 rollback validation classes:
   - `coherence.gate_chain_parity.stage1_rollback_invalid`
   - `coherence.gate_chain_parity.stage1_rollback_precondition_missing`
   - `coherence.gate_chain_parity.stage1_rollback_failure_class_mismatch`
   - `coherence.gate_chain_parity.stage1_rollback_unbound`
4. extend coherence-site `gate_chain_parity` vectors with Stage 1
   accept/reject rows (`gate_chain_parity_stage1_*`) and route site evaluator
   details through `stage1Parity` + `stage1Rollback`.
5. extend docs/traceability + control-plane loader parity:
   - docs coherence enforces Stage 1 parity/rollback marker language and
     contract shape checks,
   - traceability row for `UNIFICATION-DOCTRINE` now names Stage 1 vector
     surface,
   - `tools/ci/control_plane_contract.py` + drift-budget checks include Stage 1
     parity/rollback typed fields.

### Rationale
Stage 1 parity classes existed normatively, but executable coverage and rollback
class boundaries were still split across prose/checker-only surfaces. We need
one deterministic contract path from doctrine text to vectors to checker output.

### Consequences
- Stage 1 parity and rollback paths are now machine-checkable end-to-end in
  the same gate-chain parity pipeline.
- Rollback metadata is no longer an implicit design note; it is typed contract
  material with deterministic class mapping.
- Coherence and drift-budget checks now fail closed on Stage 1 parity/rollback
  contract drift.
